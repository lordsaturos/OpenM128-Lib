__text_start:
__start:
    004B EFCF      LDI	R28,0xFF
    004C E0D4      LDI	R29,4
    004D BFCD      OUT	0x3D,R28
    004E BFDE      OUT	0x3E,R29
    004F 51C0      SUBI	R28,0x10
    0050 40D0      SBCI	R29,0
    0051 EA0A      LDI	R16,0xAA
    0052 8308      STD	Y+0,R16
    0053 2400      CLR	R0
    0054 E2E5      LDI	R30,0x25
    0055 E0F1      LDI	R31,1
    0056 E011      LDI	R17,1
    0057 32EB      CPI	R30,0x2B
    0058 07F1      CPC	R31,R17
    0059 F011      BEQ	0x005C
    005A 9201      ST	R0,Z+
    005B CFFB      RJMP	0x0057
    005C 8300      STD	Z+0,R16
    005D E7E0      LDI	R30,0x70
    005E E0F0      LDI	R31,0
    005F E0A0      LDI	R26,0
    0060 E0B1      LDI	R27,1
    0061 E010      LDI	R17,0
    0062 39E5      CPI	R30,0x95
    0063 07F1      CPC	R31,R17
    0064 F021      BEQ	0x0069
    0065 95C8      LPM
    0066 9631      ADIW	R30,1
    0067 920D      ST	R0,X+
    0068 CFF9      RJMP	0x0062
    0069 940E02DE  CALL	_main
_exit:
    006B CFFF      RJMP	_exit
_speaData:
  y                    --> Y+4
  j                    --> Y+0
  i                    --> R10
  len                  --> R12
  dat                  --> Y+16
    006C 940E0304  CALL	push_arg4
    006E 940E03B8  CALL	push_gset4
    0070 9728      SBIW	R28,0x8
    0071 88CC      LDD	R12,Y+20
FILE: D:\ICC_H\Software.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                       
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Software_H
(0041) #define Software_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) 
(0046) /* 兼容一般程序员的常用写法 */
(0047) typedef unsigned char	uchar;
(0048) typedef unsigned int	uint;
(0049) typedef unsigned long	ulong;
(0050) typedef signed char		schar;
(0051) typedef signed int		sint;
(0052) typedef signed long		slong;
(0053) 
(0054) /* 为方便移植，建议使用下面写法 */
(0055) typedef unsigned char	bool;
(0056) typedef unsigned char	uint8;
(0057) typedef unsigned int	uint16;
(0058) typedef unsigned long   uint32;
(0059) typedef signed  char	sint8;
(0060) typedef signed	int		sint16;
(0061) typedef signed	long	sint32;
(0062) typedef signed  char	int8;
(0063) typedef signed  int		int16;
(0064) typedef signed  long	int32;
(0065) 
(0066) /* 下面写法一般不推荐 */
(0067) //typedef unsigned char ubyte;
(0068) //typedef unsigned int	uword;
(0069) //typedef unsigned long udword;
(0070) //typedef signed   char	sbyte;
(0071) //typedef signed   int	sword;
(0072) //typedef signed   long	sdword;
(0073) 
(0074) /* 一般程序定义的默认值 */
(0075) //#define NULL			0
(0076) //#define EOF			-1
(0077) //#define TRUE   		1
(0078) //#define FALSE  		0
(0079) //#define YES   		1
(0080) //#define NO  			0
(0081) //#define ON			1
(0082) //#define OFF			0
(0083) //#define ENABLE   		1
(0084) //#define DISABLE		0
(0085) //#define CRR			1
(0086) //#define ERR			0
(0087) //#define RIGHT			1
(0088) //#define WRONG			0
(0089) //#define SUCCESS		1
(0090) //#define FAILURE		0
(0091) //#define PI			3.1415926	//3.1415926535897932
(0092) 
(0093) /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
(0094) //#define _CALLOC(a)		( (a *)calloc(n,sizeof(a)) )
(0095) //#define _MALLOC(a)		( (a *)malloc(sizeof(a)) )
(0096) //#define _MIN(a,b)			( (a) < (b) ? (a) : (b) )
(0097) //#define _MAX(a,b)			( (a) > (b) ? (a) : (b) )
(0098) //#define _EXCHANGE(a,b)	{ int t; t=a; a=b; b=t; }
(0099) //#define _TOLOWER(c)		( (c)+32 )
(0100) //#define _TOUPPER(c)		( (c)-32 )
(0101) 
(0102) //#ifndef BIT
(0103) //#define BIT(x)	( 1<<(x) )
(0104) //#endif
(0105) 
(0106) /*--------------------------------------------------------------------
(0107) 函数全称：数据拆字
(0108) 函数功能：
(0109) 注意事项：D<=999999,C<=6
(0110) 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
(0111) 输    入：
(0112) 返    回：无
(0113) --------------------------------------------------------------------*/
(0114) uint8 dataElem[6];
(0115) void speaData(uint32 dat,sint8 len)
(0116) {
(0117)     uint8 i;
(0118)     uint32 j,y;
(0119)     for(i=0,j=1;i<len;i++)
    0072 24AA      CLR	R10
    0073 E041      LDI	R20,1
    0074 E050      LDI	R21,0
    0075 E060      LDI	R22,0
    0076 E070      LDI	R23,0
    0077 01FE      MOVW	R30,R28
    0078 8340      STD	Z+0,R20
    0079 8351      STD	Z+1,R21
    007A 8362      STD	Z+2,R22
    007B 8373      STD	Z+3,R23
    007C C046      RJMP	0x00C3
(0120)     {
(0121)         y=dat/j;
    007D 01FE      MOVW	R30,R28
    007E 8020      LDD	R2,Z+0
    007F 8031      LDD	R3,Z+1
    0080 8042      LDD	R4,Z+2
    0081 8053      LDD	R5,Z+3
    0082 01FE      MOVW	R30,R28
    0083 8860      LDD	R6,Z+16
    0084 8871      LDD	R7,Z+17
    0085 8882      LDD	R8,Z+18
    0086 8893      LDD	R9,Z+19
    0087 925A      ST	R5,-Y
    0088 924A      ST	R4,-Y
    0089 923A      ST	R3,-Y
    008A 922A      ST	R2,-Y
    008B 0183      MOVW	R16,R6
    008C 0194      MOVW	R18,R8
    008D 940E0309  CALL	div32u
    008F 01FE      MOVW	R30,R28
    0090 8304      STD	Z+4,R16
    0091 8315      STD	Z+5,R17
    0092 8326      STD	Z+6,R18
    0093 8337      STD	Z+7,R19
(0122)         dataElem[i]=y%10;
    0094 E04A      LDI	R20,0xA
    0095 E050      LDI	R21,0
    0096 E060      LDI	R22,0
    0097 E070      LDI	R23,0
    0098 01FE      MOVW	R30,R28
    0099 8024      LDD	R2,Z+4
    009A 8035      LDD	R3,Z+5
    009B 8046      LDD	R4,Z+6
    009C 8057      LDD	R5,Z+7
    009D 937A      ST	R23,-Y
    009E 936A      ST	R22,-Y
    009F 935A      ST	R21,-Y
    00A0 934A      ST	R20,-Y
    00A1 0181      MOVW	R16,R2
    00A2 0192      MOVW	R18,R4
    00A3 940E030B  CALL	mod32u
    00A5 E285      LDI	R24,0x25
    00A6 E091      LDI	R25,1
    00A7 2DEA      MOV	R30,R10
    00A8 27FF      CLR	R31
    00A9 0FE8      ADD	R30,R24
    00AA 1FF9      ADC	R31,R25
    00AB 8300      STD	Z+0,R16
(0123)         j*=10;
    00AC 01FE      MOVW	R30,R28
    00AD 8020      LDD	R2,Z+0
    00AE 8031      LDD	R3,Z+1
    00AF 8042      LDD	R4,Z+2
    00B0 8053      LDD	R5,Z+3
    00B1 E04A      LDI	R20,0xA
    00B2 E050      LDI	R21,0
    00B3 E060      LDI	R22,0
    00B4 E070      LDI	R23,0
    00B5 925A      ST	R5,-Y
    00B6 924A      ST	R4,-Y
    00B7 923A      ST	R3,-Y
    00B8 922A      ST	R2,-Y
    00B9 018A      MOVW	R16,R20
    00BA 019B      MOVW	R18,R22
    00BB 940E037A  CALL	empy32s
    00BD 01FE      MOVW	R30,R28
    00BE 8300      STD	Z+0,R16
    00BF 8311      STD	Z+1,R17
    00C0 8322      STD	Z+2,R18
    00C1 8333      STD	Z+3,R19
    00C2 94A3      INC	R10
    00C3 14AC      CP	R10,R12
    00C4 F408      BCC	0x00C6
    00C5 CFB7      RJMP	0x007D
    00C6 9628      ADIW	R28,0x8
    00C7 940E03B0  CALL	pop_gset4
    00C9 9624      ADIW	R28,4
    00CA 9508      RET
_delay50us:
  j                    --> R20
  t                    --> R16
    00CB 940E03BE  CALL	push_gset1
FILE: D:\ICC_H\Hardware.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
(0005) 					
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Hardware_H
(0041) #define Hardware_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) #include <stdio.h>
(0046) #include <macros.h>
(0047) #include <eeprom.h>
(0048) //#include <wdt.h>
(0049) 
(0050) /* TWI configs */
(0051) //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
(0052) #if NO_INCLUDE_I2C_H
(0053) ;
(0054) #else
(0055) #include "D:\ICC_H\I2C.H"	//i2c即AVR的"twi"
(0056) #endif
(0057) 
(0058) /* hard configs */
(0059) #ifndef flash
(0060) 	#define flash	const
(0061) #endif
(0062) 
(0063) #ifndef code
(0064) 	#define code	const
(0065) #endif
(0066) 
(0067) #ifndef NOP
(0068) 	#define NOP()	asm("nop")
(0069) #endif
(0070) 
(0071) /* io configs */
(0072) #define sbi(io,bit)		(  io |=  (1<<bit) )	//example: sbi(PORTA,0);sbi(DDRA,0);
(0073) #define cbi(io,bit)		(  io &= ~(1<<bit) )	//example: cbi(PORTA,0);cbi(DDRA,0);
(0074) #define gbi(pin ,bit)	( pin &   (1<<bit) )	//example: gbi(PINA,0);
(0075) 
(0076) /* interrupt configs */
(0077) #define DIS_INT  asm("sei")
(0078) #define EN_INT   asm("cli")
(0079) 
(0080) /* wdt configs */
(0081) #define WDT()    asm("wdr")
(0082) 
(0083) /* bit operation */
(0084) //#ifndef BIT
(0085) //#define BIT(x)	( 1<<(x) )
(0086) //#endif
(0087) 
(0088) /* USART configs for 4 Mhz crystal */
(0089) //#define BAUD9600			25
(0090) //#define BAUD19000			12
(0091) //#define UART_TRAN_ON()	UCR |=  0x08
(0092) //#define UART_TRAN_OFF()	UCR &= ~0x08
(0093) //#define UART_RCV_ON()		UCR |=  0x10
(0094) //#define UART_RCV_OFF()	UCR &= ~0x10
(0095) 
(0096) /*--------------------------------------------------------------------
(0097) 函数全称：50us 延时
(0098) 函数功能：当然是 50us延时 啦
(0099) 注意事项：基于7.3728M晶振，稍微有点误差
(0100) 提示说明：调用delay50us（20），得到1ms延时
(0101) 输    入：	
(0102) 返    回：无 
(0103) --------------------------------------------------------------------*/
(0104) void delay50us(sint16 t)
(0105) {
(0106)     uint8 j;		
(0107)     for(;t>0;t--)			
    00CD C007      RJMP	0x00D5
(0108)         for(j=0;j<70;j++)	
    00CE 2744      CLR	R20
    00CF C001      RJMP	0x00D1
    00D0 9543      INC	R20
    00D1 3446      CPI	R20,0x46
    00D2 F3E8      BCS	0x00D0
    00D3 5001      SUBI	R16,1
    00D4 4010      SBCI	R17,0
    00D5 2422      CLR	R2
    00D6 2433      CLR	R3
    00D7 1620      CP	R2,R16
    00D8 0631      CPC	R3,R17
    00D9 F3A4      BLT	0x00CE
    00DA 940E03C1  CALL	pop_gset1
    00DC 9508      RET
_delay50ms:
  i                    --> R20
  t                    --> R16
    00DD 940E03BE  CALL	push_gset1
(0109)             ;
(0110) }
(0111) /*--------------------------------------------------------------------
(0112) 函数全称：50ms 延时
(0113) 函数功能：当然是 50ms延时 啦
(0114) 注意事项：基于7.3728M晶振，稍微有点误差
(0115) 提示说明：调用delay50ms（20），得到1s延时 
(0116) 输    入：
(0117) 返    回：无
(0118) --------------------------------------------------------------------*/
(0119) void delay50ms(sint16 t)
(0120) {
(0121) 	uint16 i; 
(0122) 	for(;t>0;t--)
    00DF C00B      RJMP	0x00EB
(0123) 		for(i=0;i<52642;i++)
    00E0 2744      CLR	R20
    00E1 2755      CLR	R21
    00E2 C002      RJMP	0x00E5
    00E3 5F4F      SUBI	R20,0xFF
    00E4 4F5F      SBCI	R21,0xFF
    00E5 3A42      CPI	R20,0xA2
    00E6 ECED      LDI	R30,0xCD
    00E7 075E      CPC	R21,R30
    00E8 F3D0      BCS	0x00E3
    00E9 5001      SUBI	R16,1
    00EA 4010      SBCI	R17,0
    00EB 2422      CLR	R2
    00EC 2433      CLR	R3
    00ED 1620      CP	R2,R16
    00EE 0631      CPC	R3,R17
    00EF F384      BLT	0x00E0
    00F0 940E03C1  CALL	pop_gset1
    00F2 9508      RET
_delayus:
  i                    --> R20
  t                    --> R16
    00F3 940E03BE  CALL	push_gset1
(0124) 			; 
(0125) }
(0126) 
(0127) 
(0128) void delayus(uint16 t)
(0129) {
(0130) 	uint16 i;
(0131) 	for(i=0;i<t;i++)
    00F5 2744      CLR	R20
    00F6 2755      CLR	R21
    00F7 C002      RJMP	0x00FA
    00F8 5F4F      SUBI	R20,0xFF
    00F9 4F5F      SBCI	R21,0xFF
    00FA 1740      CP	R20,R16
    00FB 0751      CPC	R21,R17
    00FC F3D8      BCS	0x00F8
    00FD 940E03C1  CALL	pop_gset1
    00FF 9508      RET
FILE: D:\ICC_H\LCD12864_ST7920_M48.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 	                                                        
(0004) 目    的:   建立LCD12864_ST7920的串模式操作库
(0005) 
(0006) 目标系统:   基于AVR单片机
(0007) 	                                                                
(0008) 应用软件:   ICCAVR                                               
(0009) 	                                                                
(0010) 版    本:   Version 1.0
(0011) 	                                                                
(0012) 圆版时间:   2005-09-06
(0013) 
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权 
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) 
(0026) 
(0027) ----------------------------------------------------------------------
(0028) 入口参数说明：
(0029) 	//#define OUT_LCD_CS	sbi(DDRD,0)
(0030) 	//#define SET_LCD_CS	sbi(PORTD,0)
(0031) 	//#define CLR_LCD_CS	cbi(PORTD,0)
(0032) 
(0033) ----------------------------------------------------------------------
(0034) 待定参数说明：
(0035) 	
(0036) 
(0037) ----------------------------------------------------------------------	
(0038) 对外变量说明：
(0039) 
(0040) ----------------------------------------------------------------------
(0041) 对外函数说明：
(0042) 
(0043) ----------------------------------------------------------------------
(0044) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0045) 
(0046) 
(0047) /*--------------------------------------------------------------------
(0048) 接口定义：
(0049) 
(0050) LCD12864_ST7920			ATmega16
(0051) 1.GND		--------	GND
(0052) 2.VCC		--------	VCC
(0053) 3.V0		--------	V0
(0054) 4.RS(CS)	--------	VCC
(0055) 5.R/W(SID)	--------	MOSI/PB5
(0056) 6.E(SCLK)	--------	SCK/PB7
(0057) 7.D0		--------	NC
(0058) 8.D1		--------	NC
(0059) 9.D2		--------	NC
(0060) 10.D3		--------	NC
(0061) 11.D4		--------	NC
(0062) 12.D5		--------	NC
(0063) 13.D6		--------	NC
(0064) 14.D7		--------	NC
(0065) 15.PSB		--------	GND
(0066) 16.NC		--------	NC
(0067) 17.RST		--------	NC
(0068) 18.NC		--------	NC
(0069) 19.LED+		--------	VCC
(0070) 20.LED-		--------	GND
(0071) 
(0072) 说明：
(0073) （1）使用ATmega16的硬件SPI操作LCD12864_ST7920
(0074) （2）PIN4/CS接VCC，其实也可接到特定的IO口，但外部程序需要指定
(0075) --------------------------------------------------------------------*/
(0076) 
(0077) #ifndef LCD12864_ST7920_H
(0078) #define LCD12864_ST7920_H
(0079) 
(0080) #include "D:\ICC_H\CmmIcc.h"
(0081) 
(0082) void SPI_init()
(0083) {
(0084) 	DDRB =0xFF;
_SPI_init:
    0100 EF8F      LDI	R24,0xFF
    0101 BB87      OUT	0x17,R24
(0085) 	SPCR = 0x50;	//setup SPI
    0102 E580      LDI	R24,0x50
    0103 B98D      OUT	0x0D,R24
(0086) 	SPSR = 0x01;	//setup SPI
    0104 E081      LDI	R24,1
    0105 B98E      OUT	0x0E,R24
(0087) 	SEI();			
    0106 9478      BSET	7
    0107 9508      RET
(0088) }
(0089) 
(0090) void lcd_wrByte(uint8 data)
(0091) {  
(0092) 	SPDR = data;        
_lcd_wrByte:
  data                 --> R16
    0108 B90F      OUT	0x0F,R16
(0093) 	while ((SPSR & 0x80) == 0);  
    0109 9B77      SBIS	0x0E,7
    010A CFFE      RJMP	0x0109
    010B 9508      RET
_lcd_wrCmd:
  LC                   --> R20
  HC                   --> R22
    010C 940E03BC  CALL	push_gset2
    010E 2F42      MOV	R20,R18
    010F 2F60      MOV	R22,R16
(0094) }
(0095) 
(0096) void lcd_wrCmd(uint8 HC,uint8 LC)
(0097) {
(0098) 	lcd_wrByte(0xF8);
    0110 EF08      LDI	R16,0xF8
    0111 DFF6      RCALL	_lcd_wrByte
(0099) 	lcd_wrByte(HC);		//传输高四位
    0112 2F06      MOV	R16,R22
    0113 DFF4      RCALL	_lcd_wrByte
(0100) 	lcd_wrByte(LC);		//传输低四位
    0114 2F04      MOV	R16,R20
    0115 DFF2      RCALL	_lcd_wrByte
    0116 940E03AA  CALL	pop_gset2
    0118 9508      RET
_lcd_wrDat:
  LD                   --> R20
  HD                   --> R22
    0119 940E03BC  CALL	push_gset2
    011B 2F42      MOV	R20,R18
    011C 2F60      MOV	R22,R16
(0101) }
(0102) 
(0103) void lcd_wrDat(uint8 HD,uint8 LD)
(0104) {
(0105) 	lcd_wrByte(0xFA);
    011D EF0A      LDI	R16,0xFA
    011E DFE9      RCALL	_lcd_wrByte
(0106) 	lcd_wrByte(HD);		//传输高四位
    011F 2F06      MOV	R16,R22
    0120 DFE7      RCALL	_lcd_wrByte
(0107) 	lcd_wrByte(LD);		//传输低四位
    0121 2F04      MOV	R16,R20
    0122 DFE5      RCALL	_lcd_wrByte
    0123 940E03AA  CALL	pop_gset2
    0125 9508      RET
_lcd_set_xy:
  adr                  --> R20
  y                    --> R22
  x                    --> R20
    0126 940E03BC  CALL	push_gset2
    0128 2F62      MOV	R22,R18
    0129 2F40      MOV	R20,R16
(0108) } 
(0109) 
(0110) /*
(0111) x表示在第几行显示，y表示在第几列显示
(0112) */
(0113) void lcd_set_xy(uint8 x,uint8 y) 
(0114) {
(0115) 	uint8 adr;
(0116) 
(0117) 	switch(x)
    012A 2755      CLR	R21
    012B 3041      CPI	R20,1
    012C E0E0      LDI	R30,0
    012D 075E      CPC	R21,R30
    012E F069      BEQ	0x013C
    012F 3042      CPI	R20,2
    0130 E0E0      LDI	R30,0
    0131 075E      CPC	R21,R30
    0132 F061      BEQ	0x013F
    0133 3043      CPI	R20,3
    0134 E0E0      LDI	R30,0
    0135 075E      CPC	R21,R30
    0136 F059      BEQ	0x0142
    0137 3044      CPI	R20,4
    0138 E0E0      LDI	R30,0
    0139 075E      CPC	R21,R30
    013A F051      BEQ	0x0145
    013B C00B      RJMP	0x0147
(0118) 	{
(0119) 	case 1: adr = 0x7F + y;
    013C 2F46      MOV	R20,R22
    013D 5841      SUBI	R20,0x81
(0120) 		break;		//在第1行y列显示
    013E C008      RJMP	0x0147
(0121) 	case 2: adr = 0x8F + y;
    013F 2F46      MOV	R20,R22
    0140 5741      SUBI	R20,0x71
(0122) 		break;		//在第2行y列显示
    0141 C005      RJMP	0x0147
(0123) 	case 3: adr = 0x87 + y;
    0142 2F46      MOV	R20,R22
    0143 5749      SUBI	R20,0x79
(0124) 		break;		//在第3行y列显示
    0144 C002      RJMP	0x0147
(0125) 	case 4: adr = 0x97 + y;
    0145 2F46      MOV	R20,R22
    0146 5649      SUBI	R20,0x69
(0126) 		break;		//在第4行y列显示
(0127) 	default:	;
(0128) 	}
(0129) 	lcd_wrCmd(adr&0xF0,(adr&0x0F)<<4);
    0147 2F24      MOV	R18,R20
    0148 702F      ANDI	R18,0xF
    0149 702F      ANDI	R18,0xF
    014A 9522      SWAP	R18
    014B 2F04      MOV	R16,R20
    014C 7F00      ANDI	R16,0xF0
    014D DFBE      RCALL	_lcd_wrCmd
    014E 940E03AA  CALL	pop_gset2
    0150 9508      RET
_lcd_putc:
  ch                   --> Y+4
  y                    --> R22
  x                    --> R20
    0151 940E03BC  CALL	push_gset2
    0153 2F62      MOV	R22,R18
    0154 2F40      MOV	R20,R16
(0130) }
(0131) 
(0132) void lcd_putc(uint8 x,uint8 y,uint8 ch)
(0133) {
(0134) 	lcd_set_xy(x,y);
    0155 2F26      MOV	R18,R22
    0156 2F04      MOV	R16,R20
    0157 DFCE      RCALL	_lcd_set_xy
(0135) 	delay50us(20); 
    0158 E104      LDI	R16,0x14
    0159 E010      LDI	R17,0
    015A DF70      RCALL	_delay50us
(0136) 	lcd_wrDat(ch&0xF0,(ch&0x0F)<<4);
    015B 812C      LDD	R18,Y+4
    015C 702F      ANDI	R18,0xF
    015D 702F      ANDI	R18,0xF
    015E 9522      SWAP	R18
    015F 810C      LDD	R16,Y+4
    0160 7F00      ANDI	R16,0xF0
    0161 DFB7      RCALL	_lcd_wrDat
    0162 940E03AA  CALL	pop_gset2
    0164 9508      RET
_lcd_putd0:
  i                    --> R20
  length               --> Y+9
  dat                  --> Y+5
  y                    --> R22
  x                    --> R20
    0165 940E03BC  CALL	push_gset2
    0167 2F62      MOV	R22,R18
    0168 2F40      MOV	R20,R16
    0169 9721      SBIW	R28,1
(0137) }
(0138) 
(0139) void lcd_putd0(uint8 x,uint8 y,uint32 dat,uint8 length)
(0140) {
(0141) 	sint8 i;
(0142) 
(0143) 	speaData(dat,length);
    016A 8409      LDD	R0,Y+9
    016B 8208      STD	Y+0,R0
    016C 01FE      MOVW	R30,R28
    016D 8105      LDD	R16,Z+5
    016E 8116      LDD	R17,Z+6
    016F 8127      LDD	R18,Z+7
    0170 8530      LDD	R19,Z+8
    0171 DEFA      RCALL	_speaData
(0144) 	lcd_set_xy(x,y);
    0172 2F26      MOV	R18,R22
    0173 2F04      MOV	R16,R20
    0174 DFB1      RCALL	_lcd_set_xy
(0145) 	delay50us(40);
    0175 E208      LDI	R16,0x28
    0176 E010      LDI	R17,0
    0177 DF53      RCALL	_delay50us
(0146) 	for(i=length-1;i>=0;i--)
    0178 8549      LDD	R20,Y+9
    0179 5041      SUBI	R20,1
    017A C01E      RJMP	0x0199
(0147) 	{
(0148) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    017B E285      LDI	R24,0x25
    017C E091      LDI	R25,1
    017D 2FE4      MOV	R30,R20
    017E 27FF      CLR	R31
    017F FDE7      SBRC	R30,7
    0180 95F0      COM	R31
    0181 0FE8      ADD	R30,R24
    0182 1FF9      ADC	R31,R25
    0183 8180      LDD	R24,Z+0
    0184 2799      CLR	R25
    0185 96C0      ADIW	R24,0x30
    0186 2F28      MOV	R18,R24
    0187 702F      ANDI	R18,0xF
    0188 7030      ANDI	R19,0
    0189 0F22      LSL	R18
    018A 1F33      ROL	R19
    018B 0F22      LSL	R18
    018C 1F33      ROL	R19
    018D 0F22      LSL	R18
    018E 1F33      ROL	R19
    018F 0F22      LSL	R18
    0190 1F33      ROL	R19
    0191 2F08      MOV	R16,R24
    0192 7F00      ANDI	R16,0xF0
    0193 7010      ANDI	R17,0
    0194 DF84      RCALL	_lcd_wrDat
(0149) 		delay50us(40); 
    0195 E208      LDI	R16,0x28
    0196 E010      LDI	R17,0
    0197 DF33      RCALL	_delay50us
    0198 954A      DEC	R20
    0199 3040      CPI	R20,0
    019A F704      BGE	0x017B
    019B 9621      ADIW	R28,1
    019C 940E03AA  CALL	pop_gset2
    019E 9508      RET
_lcd_putd:
  effectLen            --> R12
  i                    --> R10
  length               --> Y+15
  dat                  --> Y+11
  y                    --> R14
  x                    --> R10
    019F 940E03B6  CALL	push_gset5
    01A1 2EE2      MOV	R14,R18
    01A2 2EA0      MOV	R10,R16
    01A3 9721      SBIW	R28,1
(0150) 	}
(0151) }
(0152) 
(0153) void lcd_putd(uint8 x,uint8 y,uint32 dat,uint8 length)
(0154) {
(0155) 	sint8 i;
(0156) 	sint8 effectLen;
(0157) 
(0158) 	if(dat>999999)
    01A4 E34F      LDI	R20,0x3F
    01A5 E452      LDI	R21,0x42
    01A6 E06F      LDI	R22,0xF
    01A7 E070      LDI	R23,0
    01A8 01FE      MOVW	R30,R28
    01A9 8423      LDD	R2,Z+11
    01AA 8434      LDD	R3,Z+12
    01AB 8445      LDD	R4,Z+13
    01AC 8456      LDD	R5,Z+14
    01AD 1542      CP	R20,R2
    01AE 0553      CPC	R21,R3
    01AF 0564      CPC	R22,R4
    01B0 0575      CPC	R23,R5
    01B1 F418      BCC	0x01B5
(0159) 		effectLen=7;
    01B2 E087      LDI	R24,7
    01B3 2EC8      MOV	R12,R24
    01B4 C057      RJMP	0x020C
(0160) 	else if(dat>99999)
    01B5 E94F      LDI	R20,0x9F
    01B6 E856      LDI	R21,0x86
    01B7 E061      LDI	R22,1
    01B8 E070      LDI	R23,0
    01B9 01FE      MOVW	R30,R28
    01BA 8423      LDD	R2,Z+11
    01BB 8434      LDD	R3,Z+12
    01BC 8445      LDD	R4,Z+13
    01BD 8456      LDD	R5,Z+14
    01BE 1542      CP	R20,R2
    01BF 0553      CPC	R21,R3
    01C0 0564      CPC	R22,R4
    01C1 0575      CPC	R23,R5
    01C2 F418      BCC	0x01C6
(0161) 		effectLen=6;
    01C3 E086      LDI	R24,6
    01C4 2EC8      MOV	R12,R24
    01C5 C046      RJMP	0x020C
(0162) 	else if(dat>9999)
    01C6 E04F      LDI	R20,0xF
    01C7 E257      LDI	R21,0x27
    01C8 E060      LDI	R22,0
    01C9 E070      LDI	R23,0
    01CA 01FE      MOVW	R30,R28
    01CB 8423      LDD	R2,Z+11
    01CC 8434      LDD	R3,Z+12
    01CD 8445      LDD	R4,Z+13
    01CE 8456      LDD	R5,Z+14
    01CF 1542      CP	R20,R2
    01D0 0553      CPC	R21,R3
    01D1 0564      CPC	R22,R4
    01D2 0575      CPC	R23,R5
    01D3 F418      BCC	0x01D7
(0163) 		effectLen=5;
    01D4 E085      LDI	R24,5
    01D5 2EC8      MOV	R12,R24
    01D6 C035      RJMP	0x020C
(0164) 	else if(dat>999)
    01D7 EE47      LDI	R20,0xE7
    01D8 E053      LDI	R21,3
    01D9 E060      LDI	R22,0
    01DA E070      LDI	R23,0
    01DB 01FE      MOVW	R30,R28
    01DC 8423      LDD	R2,Z+11
    01DD 8434      LDD	R3,Z+12
    01DE 8445      LDD	R4,Z+13
    01DF 8456      LDD	R5,Z+14
    01E0 1542      CP	R20,R2
    01E1 0553      CPC	R21,R3
    01E2 0564      CPC	R22,R4
    01E3 0575      CPC	R23,R5
    01E4 F418      BCC	0x01E8
(0165) 		effectLen=4;
    01E5 E084      LDI	R24,4
    01E6 2EC8      MOV	R12,R24
    01E7 C024      RJMP	0x020C
(0166) 	else if(dat>99)
    01E8 E643      LDI	R20,0x63
    01E9 E050      LDI	R21,0
    01EA E060      LDI	R22,0
    01EB E070      LDI	R23,0
    01EC 01FE      MOVW	R30,R28
    01ED 8423      LDD	R2,Z+11
    01EE 8434      LDD	R3,Z+12
    01EF 8445      LDD	R4,Z+13
    01F0 8456      LDD	R5,Z+14
    01F1 1542      CP	R20,R2
    01F2 0553      CPC	R21,R3
    01F3 0564      CPC	R22,R4
    01F4 0575      CPC	R23,R5
    01F5 F418      BCC	0x01F9
(0167) 		effectLen=3;
    01F6 E083      LDI	R24,3
    01F7 2EC8      MOV	R12,R24
    01F8 C013      RJMP	0x020C
(0168) 	else if(dat>9)
    01F9 E049      LDI	R20,0x9
    01FA E050      LDI	R21,0
    01FB E060      LDI	R22,0
    01FC E070      LDI	R23,0
    01FD 01FE      MOVW	R30,R28
    01FE 8423      LDD	R2,Z+11
    01FF 8434      LDD	R3,Z+12
    0200 8445      LDD	R4,Z+13
    0201 8456      LDD	R5,Z+14
    0202 1542      CP	R20,R2
    0203 0553      CPC	R21,R3
    0204 0564      CPC	R22,R4
    0205 0575      CPC	R23,R5
    0206 F418      BCC	0x020A
(0169) 		effectLen=2;
    0207 E082      LDI	R24,2
    0208 2EC8      MOV	R12,R24
    0209 C002      RJMP	0x020C
(0170) 	else
(0171) 		effectLen=1;
    020A 24CC      CLR	R12
    020B 94C3      INC	R12
(0172) 	speaData(dat,effectLen);
    020C 82C8      STD	Y+0,R12
    020D 01FE      MOVW	R30,R28
    020E 8503      LDD	R16,Z+11
    020F 8514      LDD	R17,Z+12
    0210 8525      LDD	R18,Z+13
    0211 8536      LDD	R19,Z+14
    0212 DE59      RCALL	_speaData
(0173) 
(0174) 	lcd_set_xy(x,y);
    0213 2D2E      MOV	R18,R14
    0214 2D0A      MOV	R16,R10
    0215 DF10      RCALL	_lcd_set_xy
(0175) 	delay50us(40); 
    0216 E208      LDI	R16,0x28
    0217 E010      LDI	R17,0
    0218 DEB2      RCALL	_delay50us
(0176) 	if(length>effectLen)
    0219 840F      LDD	R0,Y+15
    021A 14C0      CP	R12,R0
    021B F478      BCC	0x022B
(0177) 	{
(0178) 		for(i=length-effectLen-1;i>=0;i--)
    021C 2D80      MOV	R24,R0
    021D 198C      SUB	R24,R12
    021E 5081      SUBI	R24,1
    021F 2EA8      MOV	R10,R24
    0220 C007      RJMP	0x0228
(0179) 		{
(0180) 			lcd_wrDat(' '&0xF0,(' '&0x0F)<<4);
    0221 2722      CLR	R18
    0222 E200      LDI	R16,0x20
    0223 DEF5      RCALL	_lcd_wrDat
(0181) 			delay50us(40); 
    0224 E208      LDI	R16,0x28
    0225 E010      LDI	R17,0
    0226 DEA4      RCALL	_delay50us
    0227 94AA      DEC	R10
    0228 2D8A      MOV	R24,R10
    0229 3080      CPI	R24,0
    022A F7B4      BGE	0x0221
(0182) 		}
(0183) 	}
(0184) 	for(i=effectLen-1;i>=0;i--)
    022B 2D8C      MOV	R24,R12
    022C 5081      SUBI	R24,1
    022D 2EA8      MOV	R10,R24
    022E C01E      RJMP	0x024D
(0185) 	{
(0186) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    022F E285      LDI	R24,0x25
    0230 E091      LDI	R25,1
    0231 2DEA      MOV	R30,R10
    0232 27FF      CLR	R31
    0233 FDE7      SBRC	R30,7
    0234 95F0      COM	R31
    0235 0FE8      ADD	R30,R24
    0236 1FF9      ADC	R31,R25
    0237 8180      LDD	R24,Z+0
    0238 2799      CLR	R25
    0239 96C0      ADIW	R24,0x30
    023A 2F28      MOV	R18,R24
    023B 702F      ANDI	R18,0xF
    023C 7030      ANDI	R19,0
    023D 0F22      LSL	R18
    023E 1F33      ROL	R19
    023F 0F22      LSL	R18
    0240 1F33      ROL	R19
    0241 0F22      LSL	R18
    0242 1F33      ROL	R19
    0243 0F22      LSL	R18
    0244 1F33      ROL	R19
    0245 2F08      MOV	R16,R24
    0246 7F00      ANDI	R16,0xF0
    0247 7010      ANDI	R17,0
    0248 DED0      RCALL	_lcd_wrDat
(0187) 		delay50us(40);
    0249 E208      LDI	R16,0x28
    024A E010      LDI	R17,0
    024B DE7F      RCALL	_delay50us
    024C 94AA      DEC	R10
    024D 2D8A      MOV	R24,R10
    024E 3080      CPI	R24,0
    024F F6FC      BGE	0x022F
    0250 9621      ADIW	R28,1
    0251 940E03B3  CALL	pop_gset5
    0253 9508      RET
_lcd_puts:
  str                  --> R20
  y                    --> R10
  x                    --> R22
    0254 940E03BA  CALL	push_gset3
    0256 2EA2      MOV	R10,R18
    0257 2F60      MOV	R22,R16
    0258 814E      LDD	R20,Y+6
    0259 815F      LDD	R21,Y+7
(0188) 	}
(0189) }
(0190) 
(0191) void lcd_puts(uint8 x,uint8 y,uint8 *str)
(0192) { 
(0193) 	lcd_set_xy(x,y);
    025A 2D2A      MOV	R18,R10
    025B 2F06      MOV	R16,R22
    025C DEC9      RCALL	_lcd_set_xy
(0194) 	delay50us(20);   
    025D E104      LDI	R16,0x14
    025E E010      LDI	R17,0
    025F DE6B      RCALL	_delay50us
    0260 C00F      RJMP	0x0270
(0195) 	while(*str)
(0196) 	{
(0197) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    0261 01FA      MOVW	R30,R20
    0262 8020      LDD	R2,Z+0
    0263 2433      CLR	R3
    0264 2D22      MOV	R18,R2
    0265 702F      ANDI	R18,0xF
    0266 702F      ANDI	R18,0xF
    0267 9522      SWAP	R18
    0268 2D02      MOV	R16,R2
    0269 7F00      ANDI	R16,0xF0
    026A DEAE      RCALL	_lcd_wrDat
(0198) 		str++;
    026B 5F4F      SUBI	R20,0xFF
    026C 4F5F      SBCI	R21,0xFF
(0199) 		delay50us(20);
    026D E104      LDI	R16,0x14
    026E E010      LDI	R17,0
    026F DE5B      RCALL	_delay50us
    0270 01FA      MOVW	R30,R20
    0271 8020      LDD	R2,Z+0
    0272 2022      TST	R2
    0273 F769      BNE	0x0261
    0274 940E03AD  CALL	pop_gset3
    0276 9508      RET
_lcd_puts_:
  dlyMs                --> R20
  str                  --> R22
  y                    --> R12
  x                    --> R10
    0277 940E03B8  CALL	push_gset4
    0279 2EC2      MOV	R12,R18
    027A 2EA0      MOV	R10,R16
    027B 8568      LDD	R22,Y+8
    027C 8579      LDD	R23,Y+9
    027D 854A      LDD	R20,Y+10
(0200) 	} 
(0201) }
(0202) 
(0203) void lcd_puts_(uint8 x,uint8 y,uint8 *str,uint8 dlyMs)
(0204) { 
(0205) 	lcd_set_xy(x,y);
    027E 2D2C      MOV	R18,R12
    027F 2D0A      MOV	R16,R10
    0280 DEA5      RCALL	_lcd_set_xy
(0206) 	delay50us(20);   
    0281 E104      LDI	R16,0x14
    0282 E010      LDI	R17,0
    0283 DE47      RCALL	_delay50us
    0284 C00F      RJMP	0x0294
(0207) 	while(*str)
(0208) 	{
(0209) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    0285 01FB      MOVW	R30,R22
    0286 8020      LDD	R2,Z+0
    0287 2433      CLR	R3
    0288 2D22      MOV	R18,R2
    0289 702F      ANDI	R18,0xF
    028A 702F      ANDI	R18,0xF
    028B 9522      SWAP	R18
    028C 2D02      MOV	R16,R2
    028D 7F00      ANDI	R16,0xF0
    028E DE8A      RCALL	_lcd_wrDat
(0210) 		str++;
    028F 5F6F      SUBI	R22,0xFF
    0290 4F7F      SBCI	R23,0xFF
(0211) 		delay50ms(dlyMs);
    0291 2F04      MOV	R16,R20
    0292 2711      CLR	R17
    0293 DE49      RCALL	_delay50ms
    0294 01FB      MOVW	R30,R22
    0295 8020      LDD	R2,Z+0
    0296 2022      TST	R2
    0297 F769      BNE	0x0285
    0298 940E03B0  CALL	pop_gset4
    029A 9508      RET
(0212) 	} 
(0213) }
(0214) 
(0215) void lcd_clr()
(0216) {
(0217) 	lcd_wrCmd(0x00,0x10);
_lcd_clr:
    029B E120      LDI	R18,0x10
    029C 2700      CLR	R16
    029D DE6E      RCALL	_lcd_wrCmd
(0218) 	delay50us(200);
    029E EC08      LDI	R16,0xC8
    029F E010      LDI	R17,0
    02A0 DE2A      RCALL	_delay50us
    02A1 9508      RET
(0219) }
(0220) 
(0221) void lcd_init(void)
(0222) {
(0223) 	SPI_init();	
_lcd_init:
    02A2 DE5D      RCALL	_SPI_init
(0224) 	//OUT_LCD_CS;		//若LCD_CS
(0225) 	//SET_LCD_CS;		
(0226) 	delay50ms(1);
    02A3 E001      LDI	R16,1
    02A4 E010      LDI	R17,0
    02A5 DE37      RCALL	_delay50ms
(0227) 	lcd_wrCmd(0x30,0x30);	//使用8位控制界面,使用基本指令集
    02A6 E320      LDI	R18,0x30
    02A7 E300      LDI	R16,0x30
    02A8 DE63      RCALL	_lcd_wrCmd
(0228) 	//lcd_wrCmd(0x00,0xF0);	//整体显示ON
(0229) 	lcd_wrCmd(0x00,0xC0);	//整体显示ON
    02A9 EC20      LDI	R18,0xC0
    02AA 2700      CLR	R16
    02AB DE60      RCALL	_lcd_wrCmd
(0230) 	lcd_wrCmd(0x00,0x10);	//清屏
    02AC E120      LDI	R18,0x10
    02AD 2700      CLR	R16
    02AE DE5D      RCALL	_lcd_wrCmd
(0231) 	//lcd_wrCmd(0x10,0x00);	//光标
(0232) 	lcd_wrCmd(0x00,0x60);
    02AF E620      LDI	R18,0x60
    02B0 2700      CLR	R16
    02B1 DE5A      RCALL	_lcd_wrCmd
(0233) 	//lcd_wrCmd(0x00,0x70);	//显示右移
(0234) 	delay50ms(1);		//不可省去！！！
    02B2 E001      LDI	R16,1
    02B3 E010      LDI	R17,0
    02B4 DE28      RCALL	_delay50ms
    02B5 9508      RET
FILE: E:\DVK500光盘内容\STK162~1.0\MAX232~1\MAX232_LCD12864\test.c
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立使用PCF8574的示例程序
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2009-03-31
(0013) 	
(0014) 开发人员:   zz
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 实验内容：
(0027) 先把写数据并显示在MAX232自发自收试验
(0028) ----------------------------------------------------------------------
(0029) 硬件连接：
(0030) 
(0031) 	
(0032) 			  STK128+     			STK128+
(0033) 			   PA	---------  		 LED0~7
(0034) 			   
(0035) 			   DVK500				  STK128+
(0036) 				VCC		---------	  VCC
(0037) 				GND		---------	  GND
(0038) 				RXD1   ---------	  PE1(TXD0)
(0039) 				TXD1	---------	  PE0(RXD0)
(0040) 				
(0041) 				并将DB9接口的2脚和3脚短接
(0042) 				
(0043) ----------------------------------------------------------------------
(0044) 注意事项： 
(0045) （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
(0046) （2）请详细阅读“使用必读”及相关资料。
(0047) ----------------------------------------------------------------------
(0048) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0049) 
(0050) #include <iom162v.h>
(0051) #define NO_INCLUDE_I2C_H 1
(0052) #include "D:\ICC_H\CmmICC.H"
(0053) #include "D:\ICC_H\LCD12864_ST7920_M48.H"
(0054) 
(0055) void UART_init(void)
(0056) {
(0057) // USART0 initialization
(0058) // Communication Parameters: 8 Data, 1 Stop, No Parity
(0059) // USART0 Receiver: On
(0060) // USART0 Transmitter: On
(0061) // USART0 Mode: Asynchronous
(0062) // USART0 Baud Rate: 9600
(0063) UCSR0A=0x00;
_UART_init:
    02B6 2422      CLR	R2
    02B7 B82B      OUT	0x0B,R2
(0064) UCSR0B=0x18;
    02B8 E188      LDI	R24,0x18
    02B9 B98A      OUT	0x0A,R24
(0065) UCSR0C=0x06;
    02BA E086      LDI	R24,6
    02BB BD80      OUT	0x20,R24
(0066) UBRR0H=0x00;
    02BC BC20      OUT	0x20,R2
(0067) UBRR0L=0x2F;
    02BD E28F      LDI	R24,0x2F
    02BE B989      OUT	0x09,R24
    02BF 9508      RET
(0068) }
(0069) 
(0070) 
(0071) //从RS232发送一个字节 
(0072) void uart_putchar0(char c) 
(0073) { 
(0074)     while(!(UCSR0A & 0x20));
_uart_putchar0:
  c                    --> R16
    02C0 9B5D      SBIS	0x0B,5
    02C1 CFFE      RJMP	_uart_putchar0
(0075)     UDR0 = c; 
    02C2 B90C      OUT	0x0C,R16
    02C3 9508      RET
(0076) } 
(0077) //从RS232接收一个字节 
(0078) int uart_getchar0(void) 
(0079) { 
(0080)     char status,res; 
(0081)     if(!(UCSR0A & 0x80)) return -1;        //no data to be received 
_uart_getchar0:
  res                  --> R16
  status               --> R18
    02C4 995F      SBIC	0x0B,7
    02C5 C003      RJMP	0x02C9
    02C6 EF0F      LDI	R16,0xFF
    02C7 EF1F      LDI	R17,0xFF
    02C8 C009      RJMP	0x02D2
(0082)     status = UCSR0A; 
    02C9 B12B      IN	R18,0x0B
(0083)     res = UDR0; 
    02CA B10C      IN	R16,0x0C
(0084)     if (status & 0x1c) return -1;        // If error, return -1 
    02CB 2F82      MOV	R24,R18
    02CC 718C      ANDI	R24,0x1C
    02CD F019      BEQ	0x02D1
    02CE EF0F      LDI	R16,0xFF
    02CF EF1F      LDI	R17,0xFF
    02D0 C001      RJMP	0x02D2
(0085)     return res; 
    02D1 2711      CLR	R17
    02D2 9508      RET
_uart_waitchar0:
  c                    --> R20
    02D3 940E03BE  CALL	push_gset1
(0086) } 
(0087) //等待从RS232接收一个有效的字节 
(0088) char uart_waitchar0(void) 
(0089) { 
(0090)     int c; 
(0091)     while((c=uart_getchar0())==-1); 
    02D5 DFEE      RCALL	_uart_getchar0
    02D6 01A8      MOVW	R20,R16
    02D7 3F4F      CPI	R20,0xFF
    02D8 EFEF      LDI	R30,0xFF
    02D9 075E      CPC	R21,R30
    02DA F3D1      BEQ	0x02D5
(0092)     return c; 
    02DB 940E03C1  CALL	pop_gset1
    02DD 9508      RET
_main:
  tmp                  --> R20
    02DE 9722      SBIW	R28,2
(0093) } 
(0094) 
(0095) void main(void)
(0096) {
(0097)  	char tmp;
(0098)  	DDRA=0xFF;
    02DF EF8F      LDI	R24,0xFF
    02E0 BB8A      OUT	0x1A,R24
(0099) 
(0100) 	lcd_init();
    02E1 DFC0      RCALL	_lcd_init
(0101) 	lcd_clr();
    02E2 DFB8      RCALL	_lcd_clr
(0102) 	lcd_puts(1,1,"MAX232-LCD12864");
    02E3 E185      LDI	R24,0x15
    02E4 E091      LDI	R25,1
    02E5 8399      STD	Y+1,R25
    02E6 8388      STD	Y+0,R24
    02E7 E021      LDI	R18,1
    02E8 E001      LDI	R16,1
    02E9 DF6A      RCALL	_lcd_puts
(0103) 	lcd_puts(2,1,"串口  液晶显示");
    02EA E086      LDI	R24,6
    02EB E091      LDI	R25,1
    02EC 8399      STD	Y+1,R25
    02ED 8388      STD	Y+0,R24
    02EE E021      LDI	R18,1
    02EF E002      LDI	R16,2
    02F0 DF63      RCALL	_lcd_puts
(0104) 	lcd_puts(3,1,"内容:");
    02F1 E080      LDI	R24,0
    02F2 E091      LDI	R25,1
    02F3 8399      STD	Y+1,R25
    02F4 8388      STD	Y+0,R24
    02F5 E021      LDI	R18,1
    02F6 E003      LDI	R16,3
    02F7 DF5C      RCALL	_lcd_puts
(0105) 	
(0106)  	UART_init();
    02F8 DFBD      RCALL	_UART_init
(0107) 	uart_putchar0('c');
    02F9 E603      LDI	R16,0x63
    02FA DFC5      RCALL	_uart_putchar0
(0108) 	
(0109) 	tmp=uart_waitchar0();
    02FB DFD7      RCALL	_uart_waitchar0
    02FC 2F40      MOV	R20,R16
(0110) 	
(0111) 	lcd_putc(3,4,tmp);
    02FD 8348      STD	Y+0,R20
    02FE E024      LDI	R18,4
    02FF E003      LDI	R16,3
    0300 DE50      RCALL	_lcd_putc
(0112) 	while(1);
FILE: <library>
    0301 CFFF      RJMP	0x0301
    0302 9622      ADIW	R28,2
    0303 9508      RET
push_arg4:
    0304 933A      ST	R19,-Y
    0305 932A      ST	R18,-Y
push_arg2:
    0306 931A      ST	R17,-Y
    0307 930A      ST	R16,-Y
    0308 9508      RET
div32u:
    0309 94E8      BCLR	6
    030A C001      RJMP	0x030C
mod32u:
    030B 9468      BSET	6
    030C D02F      RCALL	long_div_prolog
    030D 24CC      CLR	R12
    030E C008      RJMP	0x0317
div32s:
    030F 94E8      BCLR	6
    0310 C001      RJMP	0x0312
mod32s:
    0311 9468      BSET	6
    0312 D029      RCALL	long_div_prolog
    0313 FD37      SBRC	R19,7
    0314 D053      RCALL	neg_R16_R19
    0315 FDB7      SBRC	R27,7
    0316 D05A      RCALL	neg_R24_R27
    0317 2477      CLR	R7
    0318 2488      CLR	R8
    0319 2499      CLR	R9
    031A 24AA      CLR	R10
    031B 24BB      CLR	R11
    031C D041      RCALL	tst_R16_R19
    031D F0C1      BEQ	0x0336
    031E D044      RCALL	tst_R24_R27
    031F F0B1      BEQ	0x0336
    0320 E2E8      LDI	R30,0x28
    0321 0F00      LSL	R16
    0322 1F11      ROL	R17
    0323 1F22      ROL	R18
    0324 1F33      ROL	R19
    0325 1C77      ROL	R7
    0326 1C88      ROL	R8
    0327 1C99      ROL	R9
    0328 1CAA      ROL	R10
    0329 1CBB      ROL	R11
    032A 1688      CP	R8,R24
    032B 0699      CPC	R9,R25
    032C 06AA      CPC	R10,R26
    032D 06BB      CPC	R11,R27
    032E F028      BCS	0x0334
    032F 1A88      SUB	R8,R24
    0330 0A99      SBC	R9,R25
    0331 0AAA      SBC	R10,R26
    0332 0ABB      SBC	R11,R27
    0333 9503      INC	R16
    0334 95EA      DEC	R30
    0335 F759      BNE	0x0321
    0336 F426      BRTC	0x033B
    0337 2D08      MOV	R16,R8
    0338 2D19      MOV	R17,R9
    0339 2D2A      MOV	R18,R10
    033A 2D3B      MOV	R19,R11
    033B C013      RJMP	long_div_epilog
long_div_prolog:
    033C 927A      ST	R7,-Y
    033D 928A      ST	R8,-Y
    033E 929A      ST	R9,-Y
    033F 92AA      ST	R10,-Y
    0340 92BA      ST	R11,-Y
    0341 92CA      ST	R12,-Y
    0342 93EA      ST	R30,-Y
    0343 938A      ST	R24,-Y
    0344 939A      ST	R25,-Y
    0345 93AA      ST	R26,-Y
    0346 93BA      ST	R27,-Y
    0347 858B      LDD	R24,Y+11
    0348 859C      LDD	R25,Y+12
    0349 85AD      LDD	R26,Y+13
    034A 85BE      LDD	R27,Y+14
    034B 2EC3      MOV	R12,R19
    034C F00E      BRTS	0x034E
    034D 26CB      EOR	R12,R27
    034E 9508      RET
long_div_epilog:
    034F FCC7      SBRC	R12,7
    0350 D017      RCALL	neg_R16_R19
    0351 91B9      LD	R27,Y+
    0352 91A9      LD	R26,Y+
    0353 9199      LD	R25,Y+
    0354 9189      LD	R24,Y+
    0355 91E9      LD	R30,Y+
    0356 90C9      LD	R12,Y+
    0357 90B9      LD	R11,Y+
    0358 90A9      LD	R10,Y+
    0359 9099      LD	R9,Y+
    035A 9089      LD	R8,Y+
    035B 9079      LD	R7,Y+
    035C 9624      ADIW	R28,4
    035D 9508      RET
tst_R16_R19:
    035E 2FE0      MOV	R30,R16
    035F 2BE1      OR	R30,R17
    0360 2BE2      OR	R30,R18
    0361 2BE3      OR	R30,R19
    0362 9508      RET
tst_R24_R27:
    0363 2FE8      MOV	R30,R24
    0364 2BE9      OR	R30,R25
    0365 2BEA      OR	R30,R26
    0366 2BEB      OR	R30,R27
    0367 9508      RET
neg_R16_R19:
    0368 9500      COM	R16
    0369 9510      COM	R17
    036A 9520      COM	R18
    036B 9530      COM	R19
    036C 5F0F      SUBI	R16,0xFF
    036D 4F1F      SBCI	R17,0xFF
    036E 4F2F      SBCI	R18,0xFF
    036F 4F3F      SBCI	R19,0xFF
    0370 9508      RET
neg_R24_R27:
    0371 9580      COM	R24
    0372 9590      COM	R25
    0373 95A0      COM	R26
    0374 95B0      COM	R27
    0375 5F8F      SUBI	R24,0xFF
    0376 4F9F      SBCI	R25,0xFF
    0377 4FAF      SBCI	R26,0xFF
    0378 4FBF      SBCI	R27,0xFF
    0379 9508      RET
empy32s:
empy32u:
    037A 940E03D5  CALL	long_prolog
    037C 927F      PUSH	R7
    037D 940E03EE  CALL	tstzero1
    037F F139      BEQ	0x03A7
    0380 2477      CLR	R7
    0381 940E03F4  CALL	tstzero2
    0383 F419      BNE	0x0387
    0384 018C      MOVW	R16,R24
    0385 019D      MOVW	R18,R26
    0386 C020      RJMP	0x03A7
    0387 9F08      MUL	R16,R24
    0388 2CB0      MOV	R11,R0
    0389 2CA1      MOV	R10,R1
    038A 9F28      MUL	R18,R24
    038B 2C90      MOV	R9,R0
    038C 2C81      MOV	R8,R1
    038D 9F18      MUL	R17,R24
    038E 0CA0      ADD	R10,R0
    038F 1C91      ADC	R9,R1
    0390 1C87      ADC	R8,R7
    0391 9F09      MUL	R16,R25
    0392 0CA0      ADD	R10,R0
    0393 1C91      ADC	R9,R1
    0394 1C87      ADC	R8,R7
    0395 9F19      MUL	R17,R25
    0396 0C90      ADD	R9,R0
    0397 1C81      ADC	R8,R1
    0398 9F0A      MUL	R16,R26
    0399 0C90      ADD	R9,R0
    039A 1C81      ADC	R8,R1
    039B 9F38      MUL	R19,R24
    039C 0C80      ADD	R8,R0
    039D 9F29      MUL	R18,R25
    039E 0C80      ADD	R8,R0
    039F 9F1A      MUL	R17,R26
    03A0 0C80      ADD	R8,R0
    03A1 9F0B      MUL	R16,R27
    03A2 0C80      ADD	R8,R0
    03A3 2D0B      MOV	R16,R11
    03A4 2D1A      MOV	R17,R10
    03A5 2D29      MOV	R18,R9
    03A6 2D38      MOV	R19,R8
    03A7 907F      POP	R7
    03A8 940C03E3  JMP	long_epilog
pop_gset2:
    03AA E0E2      LDI	R30,2
    03AB 940C03C2  JMP	pop
pop_gset3:
    03AD E0E4      LDI	R30,4
    03AE 940C03C2  JMP	pop
pop_gset4:
    03B0 E0E8      LDI	R30,0x8
    03B1 940C03C2  JMP	pop
pop_gset5:
    03B3 27EE      CLR	R30
    03B4 940C03C2  JMP	pop
push_gset5:
    03B6 92FA      ST	R15,-Y
    03B7 92EA      ST	R14,-Y
push_gset4:
    03B8 92DA      ST	R13,-Y
    03B9 92CA      ST	R12,-Y
push_gset3:
    03BA 92BA      ST	R11,-Y
    03BB 92AA      ST	R10,-Y
push_gset2:
    03BC 937A      ST	R23,-Y
    03BD 936A      ST	R22,-Y
push_gset1:
    03BE 935A      ST	R21,-Y
    03BF 934A      ST	R20,-Y
    03C0 9508      RET
pop_gset1:
    03C1 E0E1      LDI	R30,1
pop:
    03C2 9149      LD	R20,Y+
    03C3 9159      LD	R21,Y+
    03C4 FDE0      SBRC	R30,0
    03C5 9508      RET
    03C6 9169      LD	R22,Y+
    03C7 9179      LD	R23,Y+
    03C8 FDE1      SBRC	R30,1
    03C9 9508      RET
    03CA 90A9      LD	R10,Y+
    03CB 90B9      LD	R11,Y+
    03CC FDE2      SBRC	R30,2
    03CD 9508      RET
    03CE 90C9      LD	R12,Y+
    03CF 90D9      LD	R13,Y+
    03D0 FDE3      SBRC	R30,3
    03D1 9508      RET
    03D2 90E9      LD	R14,Y+
    03D3 90F9      LD	R15,Y+
    03D4 9508      RET
long_prolog:
    03D5 928A      ST	R8,-Y
    03D6 929A      ST	R9,-Y
    03D7 92AA      ST	R10,-Y
    03D8 92BA      ST	R11,-Y
    03D9 93EA      ST	R30,-Y
    03DA 938A      ST	R24,-Y
    03DB 939A      ST	R25,-Y
    03DC 93AA      ST	R26,-Y
    03DD 93BA      ST	R27,-Y
    03DE 8589      LDD	R24,Y+9
    03DF 859A      LDD	R25,Y+10
    03E0 85AB      LDD	R26,Y+11
    03E1 85BC      LDD	R27,Y+12
    03E2 9508      RET
long_epilog:
    03E3 91B9      LD	R27,Y+
    03E4 91A9      LD	R26,Y+
    03E5 9199      LD	R25,Y+
    03E6 9189      LD	R24,Y+
    03E7 91E9      LD	R30,Y+
    03E8 90B9      LD	R11,Y+
    03E9 90A9      LD	R10,Y+
    03EA 9099      LD	R9,Y+
    03EB 9089      LD	R8,Y+
    03EC 9624      ADIW	R28,4
    03ED 9508      RET
tstzero1:
    03EE 27EE      CLR	R30
    03EF 2BE0      OR	R30,R16
    03F0 2BE1      OR	R30,R17
    03F1 2BE2      OR	R30,R18
    03F2 2BE3      OR	R30,R19
    03F3 9508      RET
tstzero2:
    03F4 27EE      CLR	R30
    03F5 2BE8      OR	R30,R24
    03F6 2BE9      OR	R30,R25
    03F7 2BEA      OR	R30,R26
    03F8 2BEB      OR	R30,R27
    03F9 9508      RET
