__start:
__text_start:
    0047 EFCF      LDI	R28,0xFF
    0048 E0D4      LDI	R29,4
    0049 BFCD      OUT	0x3D,R28
    004A BFDE      OUT	0x3E,R29
    004B 51C0      SUBI	R28,0x10
    004C 40D0      SBCI	R29,0
    004D EA0A      LDI	R16,0xAA
    004E 8308      STD	Y+0,R16
    004F 2400      CLR	R0
    0050 E1ED      LDI	R30,0x1D
    0051 E0F1      LDI	R31,1
    0052 E011      LDI	R17,1
    0053 32E3      CPI	R30,0x23
    0054 07F1      CPC	R31,R17
    0055 F011      BEQ	0x0058
    0056 9201      ST	R0,Z+
    0057 CFFB      RJMP	0x0053
    0058 8300      STD	Z+0,R16
    0059 E7E0      LDI	R30,0x70
    005A E0F0      LDI	R31,0
    005B E0A0      LDI	R26,0
    005C E0B1      LDI	R27,1
    005D E010      LDI	R17,0
    005E 38ED      CPI	R30,0x8D
    005F 07F1      CPC	R31,R17
    0060 F021      BEQ	0x0065
    0061 95C8      LPM
    0062 9631      ADIW	R30,1
    0063 920D      ST	R0,X+
    0064 CFF9      RJMP	0x005E
    0065 940E03DC  CALL	_main
_exit:
    0067 CFFF      RJMP	_exit
_speaData:
  y                    --> Y+4
  j                    --> Y+0
  i                    --> R10
  len                  --> R12
  dat                  --> Y+16
    0068 940E03F0  CALL	push_arg4
    006A 940E04A4  CALL	push_gset4
    006C 9728      SBIW	R28,0x8
    006D 88CC      LDD	R12,Y+20
FILE: D:\ICC_H\Software.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                       
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Software_H
(0041) #define Software_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) 
(0046) /* 兼容一般程序员的常用写法 */
(0047) typedef unsigned char	uchar;
(0048) typedef unsigned int	uint;
(0049) typedef unsigned long	ulong;
(0050) typedef signed char		schar;
(0051) typedef signed int		sint;
(0052) typedef signed long		slong;
(0053) 
(0054) /* 为方便移植，建议使用下面写法 */
(0055) typedef unsigned char	bool;
(0056) typedef unsigned char	uint8;
(0057) typedef unsigned int	uint16;
(0058) typedef unsigned long   uint32;
(0059) typedef signed  char	sint8;
(0060) typedef signed	int		sint16;
(0061) typedef signed	long	sint32;
(0062) typedef signed  char	int8;
(0063) typedef signed  int		int16;
(0064) typedef signed  long	int32;
(0065) 
(0066) /* 下面写法一般不推荐 */
(0067) //typedef unsigned char ubyte;
(0068) //typedef unsigned int	uword;
(0069) //typedef unsigned long udword;
(0070) //typedef signed   char	sbyte;
(0071) //typedef signed   int	sword;
(0072) //typedef signed   long	sdword;
(0073) 
(0074) /* 一般程序定义的默认值 */
(0075) //#define NULL			0
(0076) //#define EOF			-1
(0077) //#define TRUE   		1
(0078) //#define FALSE  		0
(0079) //#define YES   		1
(0080) //#define NO  			0
(0081) //#define ON			1
(0082) //#define OFF			0
(0083) //#define ENABLE   		1
(0084) //#define DISABLE		0
(0085) //#define CRR			1
(0086) //#define ERR			0
(0087) //#define RIGHT			1
(0088) //#define WRONG			0
(0089) //#define SUCCESS		1
(0090) //#define FAILURE		0
(0091) //#define PI			3.1415926	//3.1415926535897932
(0092) 
(0093) /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
(0094) //#define _CALLOC(a)		( (a *)calloc(n,sizeof(a)) )
(0095) //#define _MALLOC(a)		( (a *)malloc(sizeof(a)) )
(0096) //#define _MIN(a,b)			( (a) < (b) ? (a) : (b) )
(0097) //#define _MAX(a,b)			( (a) > (b) ? (a) : (b) )
(0098) //#define _EXCHANGE(a,b)	{ int t; t=a; a=b; b=t; }
(0099) //#define _TOLOWER(c)		( (c)+32 )
(0100) //#define _TOUPPER(c)		( (c)-32 )
(0101) 
(0102) //#ifndef BIT
(0103) //#define BIT(x)	( 1<<(x) )
(0104) //#endif
(0105) 
(0106) /*--------------------------------------------------------------------
(0107) 函数全称：数据拆字
(0108) 函数功能：
(0109) 注意事项：D<=999999,C<=6
(0110) 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
(0111) 输    入：
(0112) 返    回：无
(0113) --------------------------------------------------------------------*/
(0114) uint8 dataElem[6];
(0115) void speaData(uint32 dat,sint8 len)
(0116) {
(0117)     uint8 i;
(0118)     uint32 j,y;
(0119)     for(i=0,j=1;i<len;i++)
    006E 24AA      CLR	R10
    006F E041      LDI	R20,1
    0070 E050      LDI	R21,0
    0071 E060      LDI	R22,0
    0072 E070      LDI	R23,0
    0073 01FE      MOVW	R30,R28
    0074 8340      STD	Z+0,R20
    0075 8351      STD	Z+1,R21
    0076 8362      STD	Z+2,R22
    0077 8373      STD	Z+3,R23
    0078 C046      RJMP	0x00BF
(0120)     {
(0121)         y=dat/j;
    0079 01FE      MOVW	R30,R28
    007A 8020      LDD	R2,Z+0
    007B 8031      LDD	R3,Z+1
    007C 8042      LDD	R4,Z+2
    007D 8053      LDD	R5,Z+3
    007E 01FE      MOVW	R30,R28
    007F 8860      LDD	R6,Z+16
    0080 8871      LDD	R7,Z+17
    0081 8882      LDD	R8,Z+18
    0082 8893      LDD	R9,Z+19
    0083 925A      ST	R5,-Y
    0084 924A      ST	R4,-Y
    0085 923A      ST	R3,-Y
    0086 922A      ST	R2,-Y
    0087 0183      MOVW	R16,R6
    0088 0194      MOVW	R18,R8
    0089 940E03F5  CALL	div32u
    008B 01FE      MOVW	R30,R28
    008C 8304      STD	Z+4,R16
    008D 8315      STD	Z+5,R17
    008E 8326      STD	Z+6,R18
    008F 8337      STD	Z+7,R19
(0122)         dataElem[i]=y%10;
    0090 E04A      LDI	R20,0xA
    0091 E050      LDI	R21,0
    0092 E060      LDI	R22,0
    0093 E070      LDI	R23,0
    0094 01FE      MOVW	R30,R28
    0095 8024      LDD	R2,Z+4
    0096 8035      LDD	R3,Z+5
    0097 8046      LDD	R4,Z+6
    0098 8057      LDD	R5,Z+7
    0099 937A      ST	R23,-Y
    009A 936A      ST	R22,-Y
    009B 935A      ST	R21,-Y
    009C 934A      ST	R20,-Y
    009D 0181      MOVW	R16,R2
    009E 0192      MOVW	R18,R4
    009F 940E03F7  CALL	mod32u
    00A1 E18D      LDI	R24,0x1D
    00A2 E091      LDI	R25,1
    00A3 2DEA      MOV	R30,R10
    00A4 27FF      CLR	R31
    00A5 0FE8      ADD	R30,R24
    00A6 1FF9      ADC	R31,R25
    00A7 8300      STD	Z+0,R16
(0123)         j*=10;
    00A8 01FE      MOVW	R30,R28
    00A9 8020      LDD	R2,Z+0
    00AA 8031      LDD	R3,Z+1
    00AB 8042      LDD	R4,Z+2
    00AC 8053      LDD	R5,Z+3
    00AD E04A      LDI	R20,0xA
    00AE E050      LDI	R21,0
    00AF E060      LDI	R22,0
    00B0 E070      LDI	R23,0
    00B1 925A      ST	R5,-Y
    00B2 924A      ST	R4,-Y
    00B3 923A      ST	R3,-Y
    00B4 922A      ST	R2,-Y
    00B5 018A      MOVW	R16,R20
    00B6 019B      MOVW	R18,R22
    00B7 940E0466  CALL	empy32s
    00B9 01FE      MOVW	R30,R28
    00BA 8300      STD	Z+0,R16
    00BB 8311      STD	Z+1,R17
    00BC 8322      STD	Z+2,R18
    00BD 8333      STD	Z+3,R19
    00BE 94A3      INC	R10
    00BF 14AC      CP	R10,R12
    00C0 F408      BCC	0x00C2
    00C1 CFB7      RJMP	0x0079
    00C2 9628      ADIW	R28,0x8
    00C3 940E049C  CALL	pop_gset4
    00C5 9624      ADIW	R28,4
    00C6 9508      RET
FILE: D:\ICC_H\I2C.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立I2C操作库
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033) 
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036) 
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef I2C_H
(0041) #define I2C_H
(0042) 
(0043) /* TWSR values (not bits) */
(0044) /* Master */
(0045) #define I2C_START			0x08
(0046) #define I2C_RESTART			0x10
(0047) 
(0048) /* Master Transmitter */
(0049) #define I2C_MT_SLA_ACK		0x18
(0050) #define I2C_MT_SLA_NACK		0x20
(0051) #define I2C_MT_DATA_ACK		0x28
(0052) #define I2C_MT_DATA_NACK	0x30
(0053) #define I2C_MT_ARB_LOST		0x38
(0054) 
(0055) /* Master Receiver */
(0056) #define I2C_MR_ARB_LOST		0x38
(0057) #define I2C_MR_SLA_ACK		0x40
(0058) #define I2C_MR_SLA_NACK		0x48
(0059) #define I2C_MR_DATA_ACK		0x50
(0060) #define I2C_MR_DATA_NACK	0x58
(0061) 
(0062) /* Slave Transmitter */
(0063) #define I2C_ST_SLA_ACK			0xA8
(0064) #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
(0065) #define I2C_ST_DATA_ACK			0xB8
(0066) #define I2C_ST_DATA_NACK		0xC0
(0067) #define I2C_ST_LAST_DATA		0xC8
(0068) 
(0069) /* Slave Receiver */
(0070) #define I2C_SR_SLA_ACK				0x60
(0071) #define I2C_SR_ARB_LOST_SLA_ACK		0x68
(0072) #define I2C_SR_GCALL_ACK			0x70
(0073) #define I2C_SR_ARB_LOST_GCALL_ACK	0x78
(0074) #define I2C_SR_DATA_ACK				0x80
(0075) #define I2C_SR_DATA_NACK			0x88
(0076) #define I2C_SR_GCALL_DATA_ACK		0x90
(0077) #define I2C_SR_GCALL_DATA_NACK		0x98
(0078) #define I2C_SR_STOP					0xA0
(0079) 
(0080) /* Misc */
(0081) #define I2C_NO_INFO			0xF8
(0082) #define I2C_BUS_ERROR		0x00
(0083) 
(0084) /*
(0085)  * The lower 3 bits of TWSR are reserved on the ATmega163.
(0086)  * The 2 LSB carry the prescaler bits on the newer ATmegas.
(0087)  */
(0088) #define I2C_STATUS_MASK	(_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
(0089) #define I2C_STATUS		(TWSR & I2C_STATUS_MASK)
(0090) 
(0091) /*
(0092)  * R/~W bit in SLA+R/W address field.
(0093)  */
(0094) #define I2C_READ		1
(0095) #define I2C_WRITE		0
(0096) 
(0097) #define I2CStart()    	(TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
(0098) #define I2CStop()     	(TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
(0099) #define I2CWaitAck()	{while(!(TWCR&(1<<TWINT)));}
(0100) #define I2CChkAck() 	(TWSR&0xf8)					//check ack
(0101) #define I2CSendAck()	(TWCR|=(1<<TWEA))
(0102) #define I2CSendNoAck()	(TWCR&=~(1<<TWEA))
(0103) #define I2CSendByte(x)	{TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
(0104) #define I2CRcvNckByte()	(TWCR=(1<<TWINT)|(1<<TWEN))
(0105) #define I2CRcvAckByte()	(TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
(0106) 
(0107) /* For Program */
(0108) #define I2C_Stop()		I2CStop()
(0109) #define I2C_SendAck()	I2CSendAck()
(0110) #define I2C_SendNoAck() I2CSendNoAck()
(0111) #define I2C_WaitAck()	I2CWaitAck()
(0112) 
(0113) /* I2C Config */
(0114) #define I2C_ERR			0
(0115) #define I2C_CRR			1
(0116) 
(0117) /*--------------------------------------------------------------------
(0118) 函数名称：I2C Start
(0119) 函数功能：
(0120) 注意事项：
(0121) 提示说明：
(0122) 输    入：
(0123) 返    回：
(0124) --------------------------------------------------------------------*/
(0125) bool I2C_Start()					
(0126) {
(0127) 	I2CStart();						
_I2C_Start:
    00C7 EA84      LDI	R24,0xA4
    00C8 BF86      OUT	0x36,R24
(0128) 	I2CWaitAck();
    00C9 B626      IN	R2,0x36
    00CA FE27      SBRS	R2,7
    00CB CFFD      RJMP	0x00C9
(0129) 	if( I2CChkAck()!=I2C_START ) 
    00CC B181      IN	R24,0x01
    00CD 7F88      ANDI	R24,0xF8
    00CE 3088      CPI	R24,0x8
    00CF F011      BEQ	0x00D2
(0130) 		return I2C_ERR;
    00D0 2700      CLR	R16
    00D1 C001      RJMP	0x00D3
(0131) 	return I2C_CRR;
    00D2 E001      LDI	R16,1
    00D3 9508      RET
(0132) }
(0133) /*--------------------------------------------------------------------
(0134) 函数名称：I2C ReStart
(0135) 函数功能：
(0136) 注意事项：
(0137) 提示说明：
(0138) 输    入：
(0139) 返    回：
(0140) --------------------------------------------------------------------*/
(0141) bool I2C_Restart()					
(0142) {
(0143) 	I2CStart();						
_I2C_Restart:
    00D4 EA84      LDI	R24,0xA4
    00D5 BF86      OUT	0x36,R24
(0144) 	I2CWaitAck();
    00D6 B626      IN	R2,0x36
    00D7 FE27      SBRS	R2,7
    00D8 CFFD      RJMP	0x00D6
(0145) 	if( I2CChkAck()!=I2C_RESTART ) 
    00D9 B181      IN	R24,0x01
    00DA 7F88      ANDI	R24,0xF8
    00DB 3180      CPI	R24,0x10
    00DC F011      BEQ	0x00DF
(0146) 		return I2C_ERR;
    00DD 2700      CLR	R16
    00DE C001      RJMP	0x00E0
(0147) 	return I2C_CRR;
    00DF E001      LDI	R16,1
    00E0 9508      RET
(0148) }
(0149) /*--------------------------------------------------------------------
(0150) 函数名称：发送 7位 器件写地址: XXXX XXX0
(0151) 函数功能：
(0152) 注意事项：
(0153) 提示说明：
(0154) 输    入：
(0155) 返    回：
(0156) --------------------------------------------------------------------*/
(0157) bool I2C_SendWrDAdr(uint8 wrDAdr)	
(0158) {
(0159) 	I2CSendByte(wrDAdr);			//设置 器件写地址
_I2C_SendWrDAdr:
  wrDAdr               --> R16
    00E1 B903      OUT	0x03,R16
    00E2 E884      LDI	R24,0x84
    00E3 BF86      OUT	0x36,R24
(0160) 	I2CWaitAck();
    00E4 B626      IN	R2,0x36
    00E5 FE27      SBRS	R2,7
    00E6 CFFD      RJMP	0x00E4
(0161) 	if( I2CChkAck()!=I2C_MT_SLA_ACK )  
    00E7 B181      IN	R24,0x01
    00E8 7F88      ANDI	R24,0xF8
    00E9 3188      CPI	R24,0x18
    00EA F011      BEQ	0x00ED
(0162) 		return I2C_ERR;
    00EB 2700      CLR	R16
    00EC C001      RJMP	0x00EE
(0163) 	return I2C_CRR;		
    00ED E001      LDI	R16,1
    00EE 9508      RET
_I2C_SendWrDAdr_:
  wrDAdr               --> R20
    00EF 940E04AA  CALL	push_gset1
    00F1 01A8      MOVW	R20,R16
(0164) }
(0165) /*--------------------------------------------------------------------
(0166) 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
(0167) 函数功能：
(0168) 注意事项：
(0169) 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
(0170) 输    入：
(0171) 返    回：
(0172) --------------------------------------------------------------------*/
(0173) bool I2C_SendWrDAdr_(uint16 wrDAdr)	
(0174) {
(0175) 	if( wrDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    00F2 FF40      SBRS	R20,0
    00F3 C00B      RJMP	0x00FF
(0176) 		if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )	//设置 （高位）器件写地址
    00F4 2F04      MOV	R16,R20
    00F5 2711      CLR	R17
    00F6 2F01      MOV	R16,R17
    00F7 2711      CLR	R17
    00F8 FD07      SBRC	R16,7
    00F9 9510      COM	R17
    00FA DFE6      RCALL	_I2C_SendWrDAdr
    00FB 2300      TST	R16
    00FC F411      BNE	0x00FF
(0177) 			return I2C_ERR;
    00FD 2700      CLR	R16
    00FE C007      RJMP	0x0106
(0178) 	if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )	//设置 （低位）器件写地址
    00FF 2F04      MOV	R16,R20
    0100 DFE0      RCALL	_I2C_SendWrDAdr
    0101 2300      TST	R16
    0102 F411      BNE	0x0105
(0179) 		return I2C_ERR;
    0103 2700      CLR	R16
    0104 C001      RJMP	0x0106
(0180) 	return I2C_CRR;
    0105 E001      LDI	R16,1
    0106 940E04AD  CALL	pop_gset1
    0108 9508      RET
(0181) }
(0182) /*--------------------------------------------------------------------
(0183) 函数名称：发送 7位 器件读地址: XXXX XXX1
(0184) 函数功能：
(0185) 注意事项：
(0186) 提示说明：
(0187) 输    入：
(0188) 返    回：
(0189) --------------------------------------------------------------------*/
(0190) bool I2C_SendRdDAdr(uint8 rdDAdr)	
(0191) {
(0192) 	I2CSendByte(rdDAdr);			//设置 器件读地址
_I2C_SendRdDAdr:
  rdDAdr               --> R16
    0109 B903      OUT	0x03,R16
    010A E884      LDI	R24,0x84
    010B BF86      OUT	0x36,R24
(0193) 	I2CWaitAck();
    010C B626      IN	R2,0x36
    010D FE27      SBRS	R2,7
    010E CFFD      RJMP	0x010C
(0194) 	if( I2CChkAck()!=I2C_MR_SLA_ACK )  
    010F B181      IN	R24,0x01
    0110 7F88      ANDI	R24,0xF8
    0111 3480      CPI	R24,0x40
    0112 F011      BEQ	0x0115
(0195) 		return I2C_ERR;
    0113 2700      CLR	R16
    0114 C001      RJMP	0x0116
(0196) 	return I2C_CRR;	
    0115 E001      LDI	R16,1
    0116 9508      RET
_I2C_SendRdDAdr_:
  rdDAdr               --> R20
    0117 940E04AA  CALL	push_gset1
    0119 2F40      MOV	R20,R16
(0197) }
(0198) /*--------------------------------------------------------------------
(0199) 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
(0200) 函数功能：
(0201) 注意事项：
(0202) 提示说明：
(0203) 输    入：
(0204) 返    回：
(0205) --------------------------------------------------------------------*/
(0206) bool I2C_SendRdDAdr_(uint8 rdDAdr)	
(0207) {
(0208) 	if( rdDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    011A FF40      SBRS	R20,0
    011B C00B      RJMP	0x0127
(0209) 		if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )	//设置 （高位）器件读地址
    011C 2F04      MOV	R16,R20
    011D 2711      CLR	R17
    011E 2F01      MOV	R16,R17
    011F 2711      CLR	R17
    0120 FD07      SBRC	R16,7
    0121 9510      COM	R17
    0122 DFBE      RCALL	_I2C_SendWrDAdr
    0123 2300      TST	R16
    0124 F411      BNE	0x0127
(0210) 			return I2C_ERR;
    0125 2700      CLR	R16
    0126 C007      RJMP	0x012E
(0211) 	if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )	//设置 （低位）器件读地址
    0127 2F04      MOV	R16,R20
    0128 DFB8      RCALL	_I2C_SendWrDAdr
    0129 2300      TST	R16
    012A F411      BNE	0x012D
(0212) 		return I2C_ERR;
    012B 2700      CLR	R16
    012C C001      RJMP	0x012E
(0213) 	return I2C_CRR;
    012D E001      LDI	R16,1
    012E 940E04AD  CALL	pop_gset1
    0130 9508      RET
(0214) }
(0215) /*--------------------------------------------------------------------
(0216) 函数名称：I2C发送数据
(0217) 函数功能：
(0218) 注意事项：
(0219) 提示说明：
(0220) 输    入：
(0221) 返    回：
(0222) --------------------------------------------------------------------*/
(0223) bool I2C_SendDat(uint8 configDat)	
(0224) {
(0225) 	I2CSendByte(configDat);			
_I2C_SendDat:
  configDat            --> R16
    0131 B903      OUT	0x03,R16
    0132 E884      LDI	R24,0x84
    0133 BF86      OUT	0x36,R24
(0226) 	I2CWaitAck();
    0134 B626      IN	R2,0x36
    0135 FE27      SBRS	R2,7
    0136 CFFD      RJMP	0x0134
(0227) 	if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
    0137 B181      IN	R24,0x01
    0138 7F88      ANDI	R24,0xF8
    0139 3288      CPI	R24,0x28
    013A F011      BEQ	0x013D
(0228) 		return I2C_ERR;
    013B 2700      CLR	R16
    013C C001      RJMP	0x013E
(0229) 	return I2C_CRR;	
    013D E001      LDI	R16,1
    013E 9508      RET
(0230) }
(0231) /*--------------------------------------------------------------------
(0232) 函数名称：I2C接收数据且不产生应答
(0233) 函数功能：
(0234) 注意事项：
(0235) 提示说明：
(0236) 输    入：
(0237) 返    回：
(0238) --------------------------------------------------------------------*/
(0239) bool I2C_RcvNAckDat(uint8 *pRdDat)	
(0240) {
(0241) 	I2CRcvNckByte();
_I2C_RcvNAckDat:
  pRdDat               --> R16
    013F E884      LDI	R24,0x84
    0140 BF86      OUT	0x36,R24
(0242) 	I2CWaitAck();
    0141 B626      IN	R2,0x36
    0142 FE27      SBRS	R2,7
    0143 CFFD      RJMP	0x0141
(0243) 	if( I2CChkAck()!=I2C_MR_DATA_NACK )
    0144 B181      IN	R24,0x01
    0145 7F88      ANDI	R24,0xF8
    0146 3588      CPI	R24,0x58
    0147 F011      BEQ	0x014A
(0244) 		return I2C_ERR;
    0148 2700      CLR	R16
    0149 C004      RJMP	0x014E
(0245) 	*pRdDat=TWDR;
    014A B023      IN	R2,0x03
    014B 01F8      MOVW	R30,R16
    014C 8220      STD	Z+0,R2
(0246) 	return I2C_CRR;
    014D E001      LDI	R16,1
    014E 9508      RET
(0247) }
(0248) /*--------------------------------------------------------------------
(0249) 函数名称：I2C接收数据且产生应答
(0250) 函数功能：
(0251) 注意事项：
(0252) 提示说明：
(0253) 输    入：
(0254) 返    回：
(0255) --------------------------------------------------------------------*/
(0256) bool I2C_RcvAckDat(uint8 *pRdDat)	
(0257) {
(0258) 	I2CRcvAckByte();					
_I2C_RcvAckDat:
  pRdDat               --> R16
    014F EC84      LDI	R24,0xC4
    0150 BF86      OUT	0x36,R24
(0259) 	I2CWaitAck();
    0151 B626      IN	R2,0x36
    0152 FE27      SBRS	R2,7
    0153 CFFD      RJMP	0x0151
(0260) 	if( I2CChkAck()!=I2C_MR_DATA_ACK )
    0154 B181      IN	R24,0x01
    0155 7F88      ANDI	R24,0xF8
    0156 3580      CPI	R24,0x50
    0157 F011      BEQ	0x015A
(0261) 		return I2C_ERR;
    0158 2700      CLR	R16
    0159 C004      RJMP	0x015E
(0262) 	*pRdDat=TWDR;
    015A B023      IN	R2,0x03
    015B 01F8      MOVW	R30,R16
    015C 8220      STD	Z+0,R2
(0263) 	return I2C_CRR;
    015D E001      LDI	R16,1
    015E 9508      RET
_I2C_Write:
  dat                  --> Y+4
  wordAdr              --> R20
  wrDAdr               --> R22
    015F 940E04A8  CALL	push_gset2
    0161 2F42      MOV	R20,R18
    0162 01B8      MOVW	R22,R16
(0264) }
(0265) /*--------------------------------------------------------------------
(0266) 函数名称：I2C写器件，写一个数据
(0267) 函数功能：
(0268) 注意事项：
(0269) 提示说明：
(0270) 输    入：wrDAdr: write device-address 写器件地址
(0271) 		 wordAdr: word address 字地址
(0272) 		 dat: data 数据
(0273) 返    回：
(0274) --------------------------------------------------------------------*/
(0275) bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
(0276) {
(0277) 	if( I2C_Start()==I2C_ERR )
    0163 DF63      RCALL	_I2C_Start
    0164 2300      TST	R16
    0165 F411      BNE	0x0168
(0278) 		return I2C_ERR;
    0166 2700      CLR	R16
    0167 C015      RJMP	0x017D
(0279) 
(0280) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    0168 018B      MOVW	R16,R22
    0169 DF85      RCALL	_I2C_SendWrDAdr_
    016A 2300      TST	R16
    016B F411      BNE	0x016E
(0281) 		return I2C_ERR;
    016C 2700      CLR	R16
    016D C00F      RJMP	0x017D
(0282) 
(0283) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    016E 2F04      MOV	R16,R20
    016F DFC1      RCALL	_I2C_SendDat
    0170 2300      TST	R16
    0171 F411      BNE	0x0174
(0284) 		return I2C_ERR;
    0172 2700      CLR	R16
    0173 C009      RJMP	0x017D
(0285) 
(0286) 	if( I2C_SendDat(dat)==I2C_ERR )
    0174 810C      LDD	R16,Y+4
    0175 DFBB      RCALL	_I2C_SendDat
    0176 2300      TST	R16
    0177 F411      BNE	0x017A
(0287) 		return I2C_ERR;
    0178 2700      CLR	R16
    0179 C003      RJMP	0x017D
(0288) 
(0289) 	I2C_Stop();
    017A E984      LDI	R24,0x94
    017B BF86      OUT	0x36,R24
(0290) 
(0291) 	return I2C_CRR;
    017C E001      LDI	R16,1
    017D 940E0496  CALL	pop_gset2
    017F 9508      RET
_I2C_Read:
  pRdDat               --> Y+6
  rdDAdr               --> Y+4
  wordAdr              --> R20
  wrDAdr               --> R22
    0180 940E04A8  CALL	push_gset2
    0182 2F42      MOV	R20,R18
    0183 01B8      MOVW	R22,R16
(0292) }
(0293) /*--------------------------------------------------------------------
(0294) 函数名称：I2C写器件，写N个数据
(0295) 函数功能：
(0296) 注意事项：
(0297) 提示说明：
(0298) 输    入：wrDAdr: write device-address 写器件地址
(0299) 		 wordAdr: word address 字地址
(0300) 		 *pWrDat: p->write data 写入数据指针
(0301) 		 num: number 写入数据个数
(0302) 返    回：
(0303) --------------------------------------------------------------------*/
(0304) //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
(0305) //				  uint8 *pWrDat,uint8 num)
(0306) //{
(0307) //
(0308) //} 
(0309) /*--------------------------------------------------------------------
(0310) 函数名称：I2C读器件，读一个数据
(0311) 函数功能：
(0312) 注意事项：
(0313) 提示说明：
(0314) 输    入：wrDAdr: write device-address 写器件地址
(0315) 		 wordAdr: word address 字地址
(0316) 		 rdDAdr: read device-address 读器件地址
(0317) 		 *pRdDat: p->read data 读取数据指针
(0318) 返    回：
(0319) --------------------------------------------------------------------*/
(0320) bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
(0321) 			  uint8 rdDAdr,uint8 *pRdDat)
(0322) {
(0323) 	if( I2C_Start()==I2C_ERR )
    0184 DF42      RCALL	_I2C_Start
    0185 2300      TST	R16
    0186 F411      BNE	0x0189
(0324) 		return I2C_ERR;
    0187 2700      CLR	R16
    0188 C021      RJMP	0x01AA
(0325) 
(0326) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    0189 018B      MOVW	R16,R22
    018A DF64      RCALL	_I2C_SendWrDAdr_
    018B 2300      TST	R16
    018C F411      BNE	0x018F
(0327) 		return I2C_ERR;
    018D 2700      CLR	R16
    018E C01B      RJMP	0x01AA
(0328) 
(0329) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    018F 2F04      MOV	R16,R20
    0190 DFA0      RCALL	_I2C_SendDat
    0191 2300      TST	R16
    0192 F411      BNE	0x0195
(0330) 		return I2C_ERR;
    0193 2700      CLR	R16
    0194 C015      RJMP	0x01AA
(0331) 
(0332) 	if( I2C_Restart()==I2C_ERR )
    0195 DF3E      RCALL	_I2C_Restart
    0196 2300      TST	R16
    0197 F411      BNE	0x019A
(0333) 		return I2C_ERR;
    0198 2700      CLR	R16
    0199 C010      RJMP	0x01AA
(0334) 
(0335) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    019A 810C      LDD	R16,Y+4
    019B DF6D      RCALL	_I2C_SendRdDAdr
    019C 2300      TST	R16
    019D F411      BNE	0x01A0
(0336) 		return I2C_ERR;
    019E 2700      CLR	R16
    019F C00A      RJMP	0x01AA
(0337) 
(0338) 	if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
    01A0 810E      LDD	R16,Y+6
    01A1 811F      LDD	R17,Y+7
    01A2 DF9C      RCALL	_I2C_RcvNAckDat
    01A3 2300      TST	R16
    01A4 F411      BNE	0x01A7
(0339) 		return I2C_ERR;
    01A5 2700      CLR	R16
    01A6 C003      RJMP	0x01AA
(0340) 
(0341) 	I2C_Stop();
    01A7 E984      LDI	R24,0x94
    01A8 BF86      OUT	0x36,R24
(0342) 
(0343) 	return I2C_CRR;
    01A9 E001      LDI	R16,1
    01AA 940E0496  CALL	pop_gset2
    01AC 9508      RET
_I2C_Read_:
  i                    --> R20
  num                  --> R22
  pRdDat               --> R10
  rdDAdr               --> Y+8
  wordAdr              --> R20
  wrDAdr               --> R12
    01AD 940E04A4  CALL	push_gset4
    01AF 2F42      MOV	R20,R18
    01B0 0168      MOVW	R12,R16
    01B1 84AA      LDD	R10,Y+10
    01B2 84BB      LDD	R11,Y+11
    01B3 856C      LDD	R22,Y+12
(0344) }
(0345) /*--------------------------------------------------------------------
(0346) 函数名称：I2C读器件，读N个数据
(0347) 函数功能：
(0348) 注意事项：
(0349) 提示说明：
(0350) 输    入：wrDAdr: write device-address 写器件地址
(0351) 		 wordAdr: word address 字地址
(0352) 		 rdDAdr: read device-address 读器件地址
(0353) 		 *pRdDat: p->read data 读取数据指针
(0354) 		 num: number 读取数据个数
(0355) 返    回：
(0356) --------------------------------------------------------------------*/
(0357) bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
(0358) 			   uint8 rdDAdr,uint8 *pRdDat,uint8 num)
(0359) {
(0360)  	uint8 i;
(0361) 	
(0362) 	if( I2C_Start()==I2C_ERR )
    01B4 DF12      RCALL	_I2C_Start
    01B5 2300      TST	R16
    01B6 F411      BNE	0x01B9
(0363) 		return I2C_ERR;
    01B7 2700      CLR	R16
    01B8 C033      RJMP	0x01EC
(0364) 
(0365) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    01B9 0186      MOVW	R16,R12
    01BA DF34      RCALL	_I2C_SendWrDAdr_
    01BB 2300      TST	R16
    01BC F411      BNE	0x01BF
(0366) 		return I2C_ERR;
    01BD 2700      CLR	R16
    01BE C02D      RJMP	0x01EC
(0367) 
(0368) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    01BF 2F04      MOV	R16,R20
    01C0 DF70      RCALL	_I2C_SendDat
    01C1 2300      TST	R16
    01C2 F411      BNE	0x01C5
(0369) 		return I2C_ERR;
    01C3 2700      CLR	R16
    01C4 C027      RJMP	0x01EC
(0370) 
(0371) 	if( I2C_Restart()==I2C_ERR )
    01C5 DF0E      RCALL	_I2C_Restart
    01C6 2300      TST	R16
    01C7 F411      BNE	0x01CA
(0372) 		return I2C_ERR;
    01C8 2700      CLR	R16
    01C9 C022      RJMP	0x01EC
(0373) 
(0374) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    01CA 8508      LDD	R16,Y+8
    01CB DF3D      RCALL	_I2C_SendRdDAdr
    01CC 2300      TST	R16
    01CD F411      BNE	0x01D0
(0375) 		return I2C_ERR;
    01CE 2700      CLR	R16
    01CF C01C      RJMP	0x01EC
(0376) 
(0377) 	for(i=0;i<num-1;i++)
    01D0 2744      CLR	R20
    01D1 C00A      RJMP	0x01DC
(0378) 		if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
    01D2 2F04      MOV	R16,R20
    01D3 2711      CLR	R17
    01D4 0D0A      ADD	R16,R10
    01D5 1D1B      ADC	R17,R11
    01D6 DF78      RCALL	_I2C_RcvAckDat
    01D7 2300      TST	R16
    01D8 F411      BNE	0x01DB
(0379) 			return I2C_ERR;
    01D9 2700      CLR	R16
    01DA C011      RJMP	0x01EC
    01DB 9543      INC	R20
    01DC 2F86      MOV	R24,R22
    01DD 5081      SUBI	R24,1
    01DE 1748      CP	R20,R24
    01DF F390      BCS	0x01D2
(0380) 	
(0381) 	if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
    01E0 2F04      MOV	R16,R20
    01E1 2711      CLR	R17
    01E2 0D0A      ADD	R16,R10
    01E3 1D1B      ADC	R17,R11
    01E4 DF5A      RCALL	_I2C_RcvNAckDat
    01E5 2300      TST	R16
    01E6 F411      BNE	0x01E9
(0382) 			return I2C_ERR;
    01E7 2700      CLR	R16
    01E8 C003      RJMP	0x01EC
(0383) 
(0384) 	I2C_Stop();
    01E9 E984      LDI	R24,0x94
    01EA BF86      OUT	0x36,R24
(0385) 	
(0386) 	return I2C_CRR;
    01EB E001      LDI	R16,1
    01EC 940E049C  CALL	pop_gset4
    01EE 9508      RET
_delay50us:
  j                    --> R20
  t                    --> R16
    01EF 940E04AA  CALL	push_gset1
FILE: D:\ICC_H\Hardware.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
(0005) 					
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Hardware_H
(0041) #define Hardware_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) #include <stdio.h>
(0046) #include <macros.h>
(0047) #include <eeprom.h>
(0048) //#include <wdt.h>
(0049) 
(0050) /* TWI configs */
(0051) //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
(0052) #if NO_INCLUDE_I2C_H
(0053) ;
(0054) #else
(0055) #include "D:\ICC_H\I2C.H"	//i2c即AVR的"twi"
(0056) #endif
(0057) 
(0058) /* hard configs */
(0059) #ifndef flash
(0060) 	#define flash	const
(0061) #endif
(0062) 
(0063) #ifndef code
(0064) 	#define code	const
(0065) #endif
(0066) 
(0067) #ifndef NOP
(0068) 	#define NOP()	asm("nop")
(0069) #endif
(0070) 
(0071) /* io configs */
(0072) #define sbi(io,bit)		(  io |=  (1<<bit) )	//example: sbi(PORTA,0);sbi(DDRA,0);
(0073) #define cbi(io,bit)		(  io &= ~(1<<bit) )	//example: cbi(PORTA,0);cbi(DDRA,0);
(0074) #define gbi(pin ,bit)	( pin &   (1<<bit) )	//example: gbi(PINA,0);
(0075) 
(0076) /* interrupt configs */
(0077) #define DIS_INT  asm("sei")
(0078) #define EN_INT   asm("cli")
(0079) 
(0080) /* wdt configs */
(0081) #define WDT()    asm("wdr")
(0082) 
(0083) /* bit operation */
(0084) //#ifndef BIT
(0085) //#define BIT(x)	( 1<<(x) )
(0086) //#endif
(0087) 
(0088) /* USART configs for 4 Mhz crystal */
(0089) //#define BAUD9600			25
(0090) //#define BAUD19000			12
(0091) //#define UART_TRAN_ON()	UCR |=  0x08
(0092) //#define UART_TRAN_OFF()	UCR &= ~0x08
(0093) //#define UART_RCV_ON()		UCR |=  0x10
(0094) //#define UART_RCV_OFF()	UCR &= ~0x10
(0095) 
(0096) /*--------------------------------------------------------------------
(0097) 函数全称：50us 延时
(0098) 函数功能：当然是 50us延时 啦
(0099) 注意事项：基于7.3728M晶振，稍微有点误差
(0100) 提示说明：调用delay50us（20），得到1ms延时
(0101) 输    入：	
(0102) 返    回：无 
(0103) --------------------------------------------------------------------*/
(0104) void delay50us(sint16 t)
(0105) {
(0106)     uint8 j;		
(0107)     for(;t>0;t--)			
    01F1 C007      RJMP	0x01F9
(0108)         for(j=0;j<70;j++)	
    01F2 2744      CLR	R20
    01F3 C001      RJMP	0x01F5
    01F4 9543      INC	R20
    01F5 3446      CPI	R20,0x46
    01F6 F3E8      BCS	0x01F4
    01F7 5001      SUBI	R16,1
    01F8 4010      SBCI	R17,0
    01F9 2422      CLR	R2
    01FA 2433      CLR	R3
    01FB 1620      CP	R2,R16
    01FC 0631      CPC	R3,R17
    01FD F3A4      BLT	0x01F2
    01FE 940E04AD  CALL	pop_gset1
    0200 9508      RET
_delay50ms:
  i                    --> R20
  t                    --> R16
    0201 940E04AA  CALL	push_gset1
(0109)             ;
(0110) }
(0111) /*--------------------------------------------------------------------
(0112) 函数全称：50ms 延时
(0113) 函数功能：当然是 50ms延时 啦
(0114) 注意事项：基于7.3728M晶振，稍微有点误差
(0115) 提示说明：调用delay50ms（20），得到1s延时 
(0116) 输    入：
(0117) 返    回：无
(0118) --------------------------------------------------------------------*/
(0119) void delay50ms(sint16 t)
(0120) {
(0121) 	uint16 i; 
(0122) 	for(;t>0;t--)
    0203 C00B      RJMP	0x020F
(0123) 		for(i=0;i<52642;i++)
    0204 2744      CLR	R20
    0205 2755      CLR	R21
    0206 C002      RJMP	0x0209
    0207 5F4F      SUBI	R20,0xFF
    0208 4F5F      SBCI	R21,0xFF
    0209 3A42      CPI	R20,0xA2
    020A ECED      LDI	R30,0xCD
    020B 075E      CPC	R21,R30
    020C F3D0      BCS	0x0207
    020D 5001      SUBI	R16,1
    020E 4010      SBCI	R17,0
    020F 2422      CLR	R2
    0210 2433      CLR	R3
    0211 1620      CP	R2,R16
    0212 0631      CPC	R3,R17
    0213 F384      BLT	0x0204
    0214 940E04AD  CALL	pop_gset1
    0216 9508      RET
_delayus:
  i                    --> R20
  t                    --> R16
    0217 940E04AA  CALL	push_gset1
(0124) 			; 
(0125) }
(0126) 
(0127) 
(0128) void delayus(uint16 t)
(0129) {
(0130) 	uint16 i;
(0131) 	for(i=0;i<=t;i++){asm("NOP\n");}
    0219 2744      CLR	R20
    021A 2755      CLR	R21
    021B C003      RJMP	0x021F
    021C 0000      NOP
    021D 5F4F      SUBI	R20,0xFF
    021E 4F5F      SBCI	R21,0xFF
    021F 1704      CP	R16,R20
    0220 0715      CPC	R17,R21
    0221 F7D0      BCC	0x021C
    0222 940E04AD  CALL	pop_gset1
    0224 9508      RET
FILE: D:\ICC_H\LCD12864_ST7920.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 	                                                        
(0004) 目    的:   建立LCD12864_ST7920的串模式操作库
(0005) 
(0006) 目标系统:   基于AVR单片机
(0007) 	                                                                
(0008) 应用软件:   ICCAVR                                               
(0009) 	                                                                
(0010) 版    本:   Version 1.0
(0011) 	                                                                
(0012) 圆版时间:   2005-09-06
(0013) 
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权 
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) 
(0026) 
(0027) ----------------------------------------------------------------------
(0028) 入口参数说明：
(0029) 	//#define OUT_LCD_CS	sbi(DDRD,0)
(0030) 	//#define SET_LCD_CS	sbi(PORTD,0)
(0031) 	//#define CLR_LCD_CS	cbi(PORTD,0)
(0032) 
(0033) ----------------------------------------------------------------------
(0034) 待定参数说明：
(0035) 	
(0036) 
(0037) ----------------------------------------------------------------------	
(0038) 对外变量说明：
(0039) 
(0040) ----------------------------------------------------------------------
(0041) 对外函数说明：
(0042) 
(0043) ----------------------------------------------------------------------
(0044) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0045) 
(0046) 
(0047) /*--------------------------------------------------------------------
(0048) 接口定义：
(0049) 
(0050) LCD12864_ST7920			ATmega16
(0051) 1.GND		--------	GND
(0052) 2.VCC		--------	VCC
(0053) 3.V0		--------	V0
(0054) 4.RS(CS)	--------	VCC
(0055) 5.R/W(SID)	--------	MOSI/PB5
(0056) 6.E(SCLK)	--------	SCK/PB7
(0057) 7.D0		--------	NC
(0058) 8.D1		--------	NC
(0059) 9.D2		--------	NC
(0060) 10.D3		--------	NC
(0061) 11.D4		--------	NC
(0062) 12.D5		--------	NC
(0063) 13.D6		--------	NC
(0064) 14.D7		--------	NC
(0065) 15.PSB		--------	GND
(0066) 16.NC		--------	NC
(0067) 17.RST		--------	NC
(0068) 18.NC		--------	NC
(0069) 19.LED+		--------	VCC
(0070) 20.LED-		--------	GND
(0071) 
(0072) 说明：
(0073) （1）使用ATmega16的硬件SPI操作LCD12864_ST7920
(0074) （2）PIN4/CS接VCC，其实也可接到特定的IO口，但外部程序需要指定
(0075) --------------------------------------------------------------------*/
(0076) 
(0077) #ifndef LCD12864_ST7920_H
(0078) #define LCD12864_ST7920_H
(0079) 
(0080) #include "D:\ICC_H\CmmIcc.h"
(0081) 
(0082) void SPI_init()
(0083) {
(0084) 	DDRB |= 0xB0;
_SPI_init:
    0225 B387      IN	R24,0x17
    0226 6B80      ORI	R24,0xB0
    0227 BB87      OUT	0x17,R24
(0085) 	SPCR = 0x50;	//setup SPI
    0228 E580      LDI	R24,0x50
    0229 B98D      OUT	0x0D,R24
(0086) 	SPSR = 0x01;	//setup SPI
    022A E081      LDI	R24,1
    022B B98E      OUT	0x0E,R24
(0087) 	SEI();			
    022C 9478      BSET	7
    022D 9508      RET
(0088) }
(0089) 
(0090) void lcd_wrByte(uint8 data)
(0091) {  
(0092) 	SPDR = data;        
_lcd_wrByte:
  data                 --> R16
    022E B90F      OUT	0x0F,R16
(0093) 	while ((SPSR & 0x80) == 0);  
    022F 9B77      SBIS	0x0E,7
    0230 CFFE      RJMP	0x022F
    0231 9508      RET
_lcd_wrCmd:
  LC                   --> R20
  HC                   --> R22
    0232 940E04A8  CALL	push_gset2
    0234 2F42      MOV	R20,R18
    0235 2F60      MOV	R22,R16
(0094) }
(0095) 
(0096) void lcd_wrCmd(uint8 HC,uint8 LC)
(0097) {
(0098) 	lcd_wrByte(0xF8);
    0236 EF08      LDI	R16,0xF8
    0237 DFF6      RCALL	_lcd_wrByte
(0099) 	lcd_wrByte(HC);		//传输高四位
    0238 2F06      MOV	R16,R22
    0239 DFF4      RCALL	_lcd_wrByte
(0100) 	lcd_wrByte(LC);		//传输低四位
    023A 2F04      MOV	R16,R20
    023B DFF2      RCALL	_lcd_wrByte
    023C 940E0496  CALL	pop_gset2
    023E 9508      RET
_lcd_wrDat:
  LD                   --> R20
  HD                   --> R22
    023F 940E04A8  CALL	push_gset2
    0241 2F42      MOV	R20,R18
    0242 2F60      MOV	R22,R16
(0101) }
(0102) 
(0103) void lcd_wrDat(uint8 HD,uint8 LD)
(0104) {
(0105) 	lcd_wrByte(0xFA);
    0243 EF0A      LDI	R16,0xFA
    0244 DFE9      RCALL	_lcd_wrByte
(0106) 	lcd_wrByte(HD);		//传输高四位
    0245 2F06      MOV	R16,R22
    0246 DFE7      RCALL	_lcd_wrByte
(0107) 	lcd_wrByte(LD);		//传输低四位
    0247 2F04      MOV	R16,R20
    0248 DFE5      RCALL	_lcd_wrByte
    0249 940E0496  CALL	pop_gset2
    024B 9508      RET
_lcd_set_xy:
  adr                  --> R20
  y                    --> R22
  x                    --> R20
    024C 940E04A8  CALL	push_gset2
    024E 2F62      MOV	R22,R18
    024F 2F40      MOV	R20,R16
(0108) } 
(0109) 
(0110) /*
(0111) x表示在第几行显示，y表示在第几列显示
(0112) */
(0113) void lcd_set_xy(uint8 x,uint8 y) 
(0114) {
(0115) 	uint8 adr;
(0116) 
(0117) 	switch(x)
    0250 2755      CLR	R21
    0251 3041      CPI	R20,1
    0252 E0E0      LDI	R30,0
    0253 075E      CPC	R21,R30
    0254 F069      BEQ	0x0262
    0255 3042      CPI	R20,2
    0256 E0E0      LDI	R30,0
    0257 075E      CPC	R21,R30
    0258 F061      BEQ	0x0265
    0259 3043      CPI	R20,3
    025A E0E0      LDI	R30,0
    025B 075E      CPC	R21,R30
    025C F059      BEQ	0x0268
    025D 3044      CPI	R20,4
    025E E0E0      LDI	R30,0
    025F 075E      CPC	R21,R30
    0260 F051      BEQ	0x026B
    0261 C00B      RJMP	0x026D
(0118) 	{
(0119) 	case 1: adr = 0x7F + y;
    0262 2F46      MOV	R20,R22
    0263 5841      SUBI	R20,0x81
(0120) 		break;		//在第1行y列显示
    0264 C008      RJMP	0x026D
(0121) 	case 2: adr = 0x8F + y;
    0265 2F46      MOV	R20,R22
    0266 5741      SUBI	R20,0x71
(0122) 		break;		//在第2行y列显示
    0267 C005      RJMP	0x026D
(0123) 	case 3: adr = 0x87 + y;
    0268 2F46      MOV	R20,R22
    0269 5749      SUBI	R20,0x79
(0124) 		break;		//在第3行y列显示
    026A C002      RJMP	0x026D
(0125) 	case 4: adr = 0x97 + y;
    026B 2F46      MOV	R20,R22
    026C 5649      SUBI	R20,0x69
(0126) 		break;		//在第4行y列显示
(0127) 	default:	;
(0128) 	}
(0129) 	lcd_wrCmd(adr&0xF0,(adr&0x0F)<<4);
    026D 2F24      MOV	R18,R20
    026E 702F      ANDI	R18,0xF
    026F 702F      ANDI	R18,0xF
    0270 9522      SWAP	R18
    0271 2F04      MOV	R16,R20
    0272 7F00      ANDI	R16,0xF0
    0273 DFBE      RCALL	_lcd_wrCmd
    0274 940E0496  CALL	pop_gset2
    0276 9508      RET
_lcd_putc:
  ch                   --> Y+4
  y                    --> R22
  x                    --> R20
    0277 940E04A8  CALL	push_gset2
    0279 2F62      MOV	R22,R18
    027A 2F40      MOV	R20,R16
(0130) }
(0131) 
(0132) void lcd_putc(uint8 x,uint8 y,uint8 ch)
(0133) {
(0134) 	lcd_set_xy(x,y);
    027B 2F26      MOV	R18,R22
    027C 2F04      MOV	R16,R20
    027D DFCE      RCALL	_lcd_set_xy
(0135) 	delay50us(20); 
    027E E104      LDI	R16,0x14
    027F E010      LDI	R17,0
    0280 DF6E      RCALL	_delay50us
(0136) 	lcd_wrDat(ch&0xF0,(ch&0x0F)<<4);
    0281 812C      LDD	R18,Y+4
    0282 702F      ANDI	R18,0xF
    0283 702F      ANDI	R18,0xF
    0284 9522      SWAP	R18
    0285 810C      LDD	R16,Y+4
    0286 7F00      ANDI	R16,0xF0
    0287 DFB7      RCALL	_lcd_wrDat
    0288 940E0496  CALL	pop_gset2
    028A 9508      RET
_lcd_putd0:
  i                    --> R20
  length               --> Y+9
  dat                  --> Y+5
  y                    --> R22
  x                    --> R20
    028B 940E04A8  CALL	push_gset2
    028D 2F62      MOV	R22,R18
    028E 2F40      MOV	R20,R16
    028F 9721      SBIW	R28,1
(0137) }
(0138) 
(0139) void lcd_putd0(uint8 x,uint8 y,uint32 dat,uint8 length)
(0140) {
(0141) 	sint8 i;
(0142) 
(0143) 	speaData(dat,length);
    0290 8409      LDD	R0,Y+9
    0291 8208      STD	Y+0,R0
    0292 01FE      MOVW	R30,R28
    0293 8105      LDD	R16,Z+5
    0294 8116      LDD	R17,Z+6
    0295 8127      LDD	R18,Z+7
    0296 8530      LDD	R19,Z+8
    0297 DDD0      RCALL	_speaData
(0144) 	lcd_set_xy(x,y);
    0298 2F26      MOV	R18,R22
    0299 2F04      MOV	R16,R20
    029A DFB1      RCALL	_lcd_set_xy
(0145) 	delay50us(40);
    029B E208      LDI	R16,0x28
    029C E010      LDI	R17,0
    029D DF51      RCALL	_delay50us
(0146) 	for(i=length-1;i>=0;i--)
    029E 8549      LDD	R20,Y+9
    029F 5041      SUBI	R20,1
    02A0 C01E      RJMP	0x02BF
(0147) 	{
(0148) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    02A1 E18D      LDI	R24,0x1D
    02A2 E091      LDI	R25,1
    02A3 2FE4      MOV	R30,R20
    02A4 27FF      CLR	R31
    02A5 FDE7      SBRC	R30,7
    02A6 95F0      COM	R31
    02A7 0FE8      ADD	R30,R24
    02A8 1FF9      ADC	R31,R25
    02A9 8180      LDD	R24,Z+0
    02AA 2799      CLR	R25
    02AB 96C0      ADIW	R24,0x30
    02AC 2F28      MOV	R18,R24
    02AD 702F      ANDI	R18,0xF
    02AE 7030      ANDI	R19,0
    02AF 0F22      LSL	R18
    02B0 1F33      ROL	R19
    02B1 0F22      LSL	R18
    02B2 1F33      ROL	R19
    02B3 0F22      LSL	R18
    02B4 1F33      ROL	R19
    02B5 0F22      LSL	R18
    02B6 1F33      ROL	R19
    02B7 2F08      MOV	R16,R24
    02B8 7F00      ANDI	R16,0xF0
    02B9 7010      ANDI	R17,0
    02BA DF84      RCALL	_lcd_wrDat
(0149) 		delay50us(40); 
    02BB E208      LDI	R16,0x28
    02BC E010      LDI	R17,0
    02BD DF31      RCALL	_delay50us
    02BE 954A      DEC	R20
    02BF 3040      CPI	R20,0
    02C0 F704      BGE	0x02A1
    02C1 9621      ADIW	R28,1
    02C2 940E0496  CALL	pop_gset2
    02C4 9508      RET
_lcd_putd:
  effectLen            --> R12
  i                    --> R10
  length               --> Y+15
  dat                  --> Y+11
  y                    --> R14
  x                    --> R10
    02C5 940E04A2  CALL	push_gset5
    02C7 2EE2      MOV	R14,R18
    02C8 2EA0      MOV	R10,R16
    02C9 9721      SBIW	R28,1
(0150) 	}
(0151) }
(0152) 
(0153) void lcd_putd(uint8 x,uint8 y,uint32 dat,uint8 length)
(0154) {
(0155) 	sint8 i;
(0156) 	sint8 effectLen;
(0157) 
(0158) 	if(dat>999999)
    02CA E34F      LDI	R20,0x3F
    02CB E452      LDI	R21,0x42
    02CC E06F      LDI	R22,0xF
    02CD E070      LDI	R23,0
    02CE 01FE      MOVW	R30,R28
    02CF 8423      LDD	R2,Z+11
    02D0 8434      LDD	R3,Z+12
    02D1 8445      LDD	R4,Z+13
    02D2 8456      LDD	R5,Z+14
    02D3 1542      CP	R20,R2
    02D4 0553      CPC	R21,R3
    02D5 0564      CPC	R22,R4
    02D6 0575      CPC	R23,R5
    02D7 F418      BCC	0x02DB
(0159) 		effectLen=7;
    02D8 E087      LDI	R24,7
    02D9 2EC8      MOV	R12,R24
    02DA C057      RJMP	0x0332
(0160) 	else if(dat>99999)
    02DB E94F      LDI	R20,0x9F
    02DC E856      LDI	R21,0x86
    02DD E061      LDI	R22,1
    02DE E070      LDI	R23,0
    02DF 01FE      MOVW	R30,R28
    02E0 8423      LDD	R2,Z+11
    02E1 8434      LDD	R3,Z+12
    02E2 8445      LDD	R4,Z+13
    02E3 8456      LDD	R5,Z+14
    02E4 1542      CP	R20,R2
    02E5 0553      CPC	R21,R3
    02E6 0564      CPC	R22,R4
    02E7 0575      CPC	R23,R5
    02E8 F418      BCC	0x02EC
(0161) 		effectLen=6;
    02E9 E086      LDI	R24,6
    02EA 2EC8      MOV	R12,R24
    02EB C046      RJMP	0x0332
(0162) 	else if(dat>9999)
    02EC E04F      LDI	R20,0xF
    02ED E257      LDI	R21,0x27
    02EE E060      LDI	R22,0
    02EF E070      LDI	R23,0
    02F0 01FE      MOVW	R30,R28
    02F1 8423      LDD	R2,Z+11
    02F2 8434      LDD	R3,Z+12
    02F3 8445      LDD	R4,Z+13
    02F4 8456      LDD	R5,Z+14
    02F5 1542      CP	R20,R2
    02F6 0553      CPC	R21,R3
    02F7 0564      CPC	R22,R4
    02F8 0575      CPC	R23,R5
    02F9 F418      BCC	0x02FD
(0163) 		effectLen=5;
    02FA E085      LDI	R24,5
    02FB 2EC8      MOV	R12,R24
    02FC C035      RJMP	0x0332
(0164) 	else if(dat>999)
    02FD EE47      LDI	R20,0xE7
    02FE E053      LDI	R21,3
    02FF E060      LDI	R22,0
    0300 E070      LDI	R23,0
    0301 01FE      MOVW	R30,R28
    0302 8423      LDD	R2,Z+11
    0303 8434      LDD	R3,Z+12
    0304 8445      LDD	R4,Z+13
    0305 8456      LDD	R5,Z+14
    0306 1542      CP	R20,R2
    0307 0553      CPC	R21,R3
    0308 0564      CPC	R22,R4
    0309 0575      CPC	R23,R5
    030A F418      BCC	0x030E
(0165) 		effectLen=4;
    030B E084      LDI	R24,4
    030C 2EC8      MOV	R12,R24
    030D C024      RJMP	0x0332
(0166) 	else if(dat>99)
    030E E643      LDI	R20,0x63
    030F E050      LDI	R21,0
    0310 E060      LDI	R22,0
    0311 E070      LDI	R23,0
    0312 01FE      MOVW	R30,R28
    0313 8423      LDD	R2,Z+11
    0314 8434      LDD	R3,Z+12
    0315 8445      LDD	R4,Z+13
    0316 8456      LDD	R5,Z+14
    0317 1542      CP	R20,R2
    0318 0553      CPC	R21,R3
    0319 0564      CPC	R22,R4
    031A 0575      CPC	R23,R5
    031B F418      BCC	0x031F
(0167) 		effectLen=3;
    031C E083      LDI	R24,3
    031D 2EC8      MOV	R12,R24
    031E C013      RJMP	0x0332
(0168) 	else if(dat>9)
    031F E049      LDI	R20,0x9
    0320 E050      LDI	R21,0
    0321 E060      LDI	R22,0
    0322 E070      LDI	R23,0
    0323 01FE      MOVW	R30,R28
    0324 8423      LDD	R2,Z+11
    0325 8434      LDD	R3,Z+12
    0326 8445      LDD	R4,Z+13
    0327 8456      LDD	R5,Z+14
    0328 1542      CP	R20,R2
    0329 0553      CPC	R21,R3
    032A 0564      CPC	R22,R4
    032B 0575      CPC	R23,R5
    032C F418      BCC	0x0330
(0169) 		effectLen=2;
    032D E082      LDI	R24,2
    032E 2EC8      MOV	R12,R24
    032F C002      RJMP	0x0332
(0170) 	else
(0171) 		effectLen=1;
    0330 24CC      CLR	R12
    0331 94C3      INC	R12
(0172) 	speaData(dat,effectLen);
    0332 82C8      STD	Y+0,R12
    0333 01FE      MOVW	R30,R28
    0334 8503      LDD	R16,Z+11
    0335 8514      LDD	R17,Z+12
    0336 8525      LDD	R18,Z+13
    0337 8536      LDD	R19,Z+14
    0338 DD2F      RCALL	_speaData
(0173) 
(0174) 	lcd_set_xy(x,y);
    0339 2D2E      MOV	R18,R14
    033A 2D0A      MOV	R16,R10
    033B DF10      RCALL	_lcd_set_xy
(0175) 	delay50us(40); 
    033C E208      LDI	R16,0x28
    033D E010      LDI	R17,0
    033E DEB0      RCALL	_delay50us
(0176) 	if(length>effectLen)
    033F 840F      LDD	R0,Y+15
    0340 14C0      CP	R12,R0
    0341 F478      BCC	0x0351
(0177) 	{
(0178) 		for(i=length-effectLen-1;i>=0;i--)
    0342 2D80      MOV	R24,R0
    0343 198C      SUB	R24,R12
    0344 5081      SUBI	R24,1
    0345 2EA8      MOV	R10,R24
    0346 C007      RJMP	0x034E
(0179) 		{
(0180) 			lcd_wrDat(' '&0xF0,(' '&0x0F)<<4);
    0347 2722      CLR	R18
    0348 E200      LDI	R16,0x20
    0349 DEF5      RCALL	_lcd_wrDat
(0181) 			delay50us(40); 
    034A E208      LDI	R16,0x28
    034B E010      LDI	R17,0
    034C DEA2      RCALL	_delay50us
    034D 94AA      DEC	R10
    034E 2D8A      MOV	R24,R10
    034F 3080      CPI	R24,0
    0350 F7B4      BGE	0x0347
(0182) 		}
(0183) 	}
(0184) 	for(i=effectLen-1;i>=0;i--)
    0351 2D8C      MOV	R24,R12
    0352 5081      SUBI	R24,1
    0353 2EA8      MOV	R10,R24
    0354 C01E      RJMP	0x0373
(0185) 	{
(0186) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    0355 E18D      LDI	R24,0x1D
    0356 E091      LDI	R25,1
    0357 2DEA      MOV	R30,R10
    0358 27FF      CLR	R31
    0359 FDE7      SBRC	R30,7
    035A 95F0      COM	R31
    035B 0FE8      ADD	R30,R24
    035C 1FF9      ADC	R31,R25
    035D 8180      LDD	R24,Z+0
    035E 2799      CLR	R25
    035F 96C0      ADIW	R24,0x30
    0360 2F28      MOV	R18,R24
    0361 702F      ANDI	R18,0xF
    0362 7030      ANDI	R19,0
    0363 0F22      LSL	R18
    0364 1F33      ROL	R19
    0365 0F22      LSL	R18
    0366 1F33      ROL	R19
    0367 0F22      LSL	R18
    0368 1F33      ROL	R19
    0369 0F22      LSL	R18
    036A 1F33      ROL	R19
    036B 2F08      MOV	R16,R24
    036C 7F00      ANDI	R16,0xF0
    036D 7010      ANDI	R17,0
    036E DED0      RCALL	_lcd_wrDat
(0187) 		delay50us(40);
    036F E208      LDI	R16,0x28
    0370 E010      LDI	R17,0
    0371 DE7D      RCALL	_delay50us
    0372 94AA      DEC	R10
    0373 2D8A      MOV	R24,R10
    0374 3080      CPI	R24,0
    0375 F6FC      BGE	0x0355
    0376 9621      ADIW	R28,1
    0377 940E049F  CALL	pop_gset5
    0379 9508      RET
_lcd_puts:
  str                  --> R20
  y                    --> R10
  x                    --> R22
    037A 940E04A6  CALL	push_gset3
    037C 2EA2      MOV	R10,R18
    037D 2F60      MOV	R22,R16
    037E 814E      LDD	R20,Y+6
    037F 815F      LDD	R21,Y+7
(0188) 	}
(0189) }
(0190) 
(0191) void lcd_puts(uint8 x,uint8 y,uint8 *str)
(0192) { 
(0193) 	lcd_set_xy(x,y);
    0380 2D2A      MOV	R18,R10
    0381 2F06      MOV	R16,R22
    0382 DEC9      RCALL	_lcd_set_xy
(0194) 	delay50us(20);   
    0383 E104      LDI	R16,0x14
    0384 E010      LDI	R17,0
    0385 DE69      RCALL	_delay50us
    0386 C00F      RJMP	0x0396
(0195) 	while(*str)
(0196) 	{
(0197) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    0387 01FA      MOVW	R30,R20
    0388 8020      LDD	R2,Z+0
    0389 2433      CLR	R3
    038A 2D22      MOV	R18,R2
    038B 702F      ANDI	R18,0xF
    038C 702F      ANDI	R18,0xF
    038D 9522      SWAP	R18
    038E 2D02      MOV	R16,R2
    038F 7F00      ANDI	R16,0xF0
    0390 DEAE      RCALL	_lcd_wrDat
(0198) 		str++;
    0391 5F4F      SUBI	R20,0xFF
    0392 4F5F      SBCI	R21,0xFF
(0199) 		delay50us(20);
    0393 E104      LDI	R16,0x14
    0394 E010      LDI	R17,0
    0395 DE59      RCALL	_delay50us
    0396 01FA      MOVW	R30,R20
    0397 8020      LDD	R2,Z+0
    0398 2022      TST	R2
    0399 F769      BNE	0x0387
    039A 940E0499  CALL	pop_gset3
    039C 9508      RET
_lcd_puts_:
  dlyMs                --> R20
  str                  --> R22
  y                    --> R12
  x                    --> R10
    039D 940E04A4  CALL	push_gset4
    039F 2EC2      MOV	R12,R18
    03A0 2EA0      MOV	R10,R16
    03A1 8568      LDD	R22,Y+8
    03A2 8579      LDD	R23,Y+9
    03A3 854A      LDD	R20,Y+10
(0200) 	} 
(0201) }
(0202) 
(0203) void lcd_puts_(uint8 x,uint8 y,uint8 *str,uint8 dlyMs)
(0204) { 
(0205) 	lcd_set_xy(x,y);
    03A4 2D2C      MOV	R18,R12
    03A5 2D0A      MOV	R16,R10
    03A6 DEA5      RCALL	_lcd_set_xy
(0206) 	delay50us(20);   
    03A7 E104      LDI	R16,0x14
    03A8 E010      LDI	R17,0
    03A9 DE45      RCALL	_delay50us
    03AA C00F      RJMP	0x03BA
(0207) 	while(*str)
(0208) 	{
(0209) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    03AB 01FB      MOVW	R30,R22
    03AC 8020      LDD	R2,Z+0
    03AD 2433      CLR	R3
    03AE 2D22      MOV	R18,R2
    03AF 702F      ANDI	R18,0xF
    03B0 702F      ANDI	R18,0xF
    03B1 9522      SWAP	R18
    03B2 2D02      MOV	R16,R2
    03B3 7F00      ANDI	R16,0xF0
    03B4 DE8A      RCALL	_lcd_wrDat
(0210) 		str++;
    03B5 5F6F      SUBI	R22,0xFF
    03B6 4F7F      SBCI	R23,0xFF
(0211) 		delay50ms(dlyMs);
    03B7 2F04      MOV	R16,R20
    03B8 2711      CLR	R17
    03B9 DE47      RCALL	_delay50ms
    03BA 01FB      MOVW	R30,R22
    03BB 8020      LDD	R2,Z+0
    03BC 2022      TST	R2
    03BD F769      BNE	0x03AB
    03BE 940E049C  CALL	pop_gset4
    03C0 9508      RET
(0212) 	} 
(0213) }
(0214) 
(0215) void lcd_clr()
(0216) {
(0217) 	lcd_wrCmd(0x00,0x10);
_lcd_clr:
    03C1 E120      LDI	R18,0x10
    03C2 2700      CLR	R16
    03C3 DE6E      RCALL	_lcd_wrCmd
(0218) 	delay50us(200);
    03C4 EC08      LDI	R16,0xC8
    03C5 E010      LDI	R17,0
    03C6 DE28      RCALL	_delay50us
    03C7 9508      RET
(0219) }
(0220) 
(0221) void lcd_init(void)
(0222) {
(0223) 	SPI_init();	
_lcd_init:
    03C8 DE5C      RCALL	_SPI_init
(0224) 	//OUT_LCD_CS;		//若LCD_CS
(0225) 	//SET_LCD_CS;		
(0226) 	delay50ms(1);
    03C9 E001      LDI	R16,1
    03CA E010      LDI	R17,0
    03CB DE35      RCALL	_delay50ms
(0227) 	lcd_wrCmd(0x30,0x30);	//使用8位控制界面,使用基本指令集
    03CC E320      LDI	R18,0x30
    03CD E300      LDI	R16,0x30
    03CE DE63      RCALL	_lcd_wrCmd
(0228) 	//lcd_wrCmd(0x00,0xF0);	//整体显示ON
(0229) 	lcd_wrCmd(0x00,0xC0);	//整体显示ON
    03CF EC20      LDI	R18,0xC0
    03D0 2700      CLR	R16
    03D1 DE60      RCALL	_lcd_wrCmd
(0230) 	lcd_wrCmd(0x00,0x10);	//清屏
    03D2 E120      LDI	R18,0x10
    03D3 2700      CLR	R16
    03D4 DE5D      RCALL	_lcd_wrCmd
(0231) 	//lcd_wrCmd(0x10,0x00);	//光标
(0232) 	lcd_wrCmd(0x00,0x60);
    03D5 E620      LDI	R18,0x60
    03D6 2700      CLR	R16
    03D7 DE5A      RCALL	_lcd_wrCmd
(0233) 	//lcd_wrCmd(0x00,0x70);	//显示右移
(0234) 	delay50ms(1);		//不可省去！！！
    03D8 E001      LDI	R16,1
    03D9 E010      LDI	R17,0
    03DA DE26      RCALL	_delay50ms
    03DB 9508      RET
_main:
    03DC 9722      SBIW	R28,2
FILE: E:\吴泽程序备份\移植程序\STK162~1.0\LCD128~1\LCD12864_ST7920\LCD12864_ST7920.C
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                            
(0004) 目    的:   建立操作LCD12864_ST7920液晶的示例程序
(0005) 
(0006) 目标系统:   基于任何AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 实验内容：
(0027) 初始化、读写Lcd12864_ST7920。
(0028) ----------------------------------------------------------------------
(0029) 硬件连接：
(0030) LCD12864_ST7920			ATmega162
(0031) 1.GND		--------	GND
(0032) 2.VCC		--------	VCC
(0033) 3.V0		--------	V0
(0034) 4.RS(CS)	--------	VCC
(0035) 5.R/W(SID)	--------	MOSI/PB5
(0036) 6.E(SCLK)	--------	SCK/PB7
(0037) 7.D0		--------	NC
(0038) 8.D1		--------	NC
(0039) 9.D2		--------	NC
(0040) 10.D3		--------	NC
(0041) 11.D4		--------	NC
(0042) 12.D5		--------	NC
(0043) 13.D6		--------	NC
(0044) 14.D7		--------	NC
(0045) 15.PSB		--------	GND
(0046) 16.NC		--------	NC
(0047) 17.RST		--------	NC
(0048) 18.NC		--------	NC
(0049) 19.LED+		--------	VCC
(0050) 20.LED-		--------	GND
(0051) 
(0052) 操作步骤：
(0053) (1)编译烧写该程序到ATmega162，断开电源
(0054) (2)若使用ISP接口烧写程序，请断开ISP烧写器
(0055) （由于本示例程序使用的是ATmega16的SPI接口，刚好是ISP烧写器的烧写口）
(0056) (3)将LCD12864_ST7920插入主板的Lcd12864插槽
(0057) (4)使用连接线将LCD12864_ST7920的以下引针接口连接到MCU：
(0058) （由于SMK1632已经做好了大部分的硬件连接，您只需连接以下数据端口）
(0059) LCD12864_ST7920			ATmega162
(0060) 4.RS(CS)	--------	VCC
(0061) 5.R/W(SID)	--------	MOSI/PB5
(0062) 6.E(SCLK)	--------	SCK/PB7
(0063) 15.PSB		--------	GND
(0064) (5)上电，如果操作正确，这时您可以看到显示的内容了
(0065) 
(0066) ----------------------------------------------------------------------
(0067) 注意事项：
(0068) （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘 
(0069) （2）请详细阅读：光盘根目录下的“产品资料\开发板实验板\SMK系列\SMK1632\说明资料”
(0070) ----------------------------------------------------------------------
(0071) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0072) 
(0073) #include <iom16v.h>
(0074) 
(0075) #include "D:\ICC_H\LCD12864_ST7920.H"
(0076) 
(0077) /*--------------------------------------------------------------------
(0078) 函数名称：
(0079) 函数功能：
(0080) 注意事项：
(0081) 提示说明：
(0082) 输    入：
(0083) 返    回：
(0084) --------------------------------------------------------------------*/
(0085) void main()
(0086) {             
(0087) 	SEI();
    03DD 9478      BSET	7
(0088) 	lcd_init();
    03DE DFE9      RCALL	_lcd_init
(0089) 	lcd_puts(1,1,"  WaveShare.net");
    03DF E08D      LDI	R24,0xD
    03E0 E091      LDI	R25,1
    03E1 8399      STD	Y+1,R25
    03E2 8388      STD	Y+0,R24
    03E3 E021      LDI	R18,1
    03E4 E001      LDI	R16,1
    03E5 DF94      RCALL	_lcd_puts
(0090) 	lcd_puts(3,1,"    微雪电子");
    03E6 E080      LDI	R24,0
    03E7 E091      LDI	R25,1
    03E8 8399      STD	Y+1,R25
    03E9 8388      STD	Y+0,R24
    03EA E021      LDI	R18,1
    03EB E003      LDI	R16,3
    03EC DF8D      RCALL	_lcd_puts
(0091) 	while(1);
FILE: <library>
    03ED CFFF      RJMP	0x03ED
    03EE 9622      ADIW	R28,2
    03EF 9508      RET
push_arg4:
    03F0 933A      ST	R19,-Y
    03F1 932A      ST	R18,-Y
push_arg2:
    03F2 931A      ST	R17,-Y
    03F3 930A      ST	R16,-Y
    03F4 9508      RET
div32u:
    03F5 94E8      BCLR	6
    03F6 C001      RJMP	0x03F8
mod32u:
    03F7 9468      BSET	6
    03F8 D02F      RCALL	long_div_prolog
    03F9 24CC      CLR	R12
    03FA C008      RJMP	0x0403
div32s:
    03FB 94E8      BCLR	6
    03FC C001      RJMP	0x03FE
mod32s:
    03FD 9468      BSET	6
    03FE D029      RCALL	long_div_prolog
    03FF FD37      SBRC	R19,7
    0400 D053      RCALL	neg_R16_R19
    0401 FDB7      SBRC	R27,7
    0402 D05A      RCALL	neg_R24_R27
    0403 2477      CLR	R7
    0404 2488      CLR	R8
    0405 2499      CLR	R9
    0406 24AA      CLR	R10
    0407 24BB      CLR	R11
    0408 D041      RCALL	tst_R16_R19
    0409 F0C1      BEQ	0x0422
    040A D044      RCALL	tst_R24_R27
    040B F0B1      BEQ	0x0422
    040C E2E8      LDI	R30,0x28
    040D 0F00      LSL	R16
    040E 1F11      ROL	R17
    040F 1F22      ROL	R18
    0410 1F33      ROL	R19
    0411 1C77      ROL	R7
    0412 1C88      ROL	R8
    0413 1C99      ROL	R9
    0414 1CAA      ROL	R10
    0415 1CBB      ROL	R11
    0416 1688      CP	R8,R24
    0417 0699      CPC	R9,R25
    0418 06AA      CPC	R10,R26
    0419 06BB      CPC	R11,R27
    041A F028      BCS	0x0420
    041B 1A88      SUB	R8,R24
    041C 0A99      SBC	R9,R25
    041D 0AAA      SBC	R10,R26
    041E 0ABB      SBC	R11,R27
    041F 9503      INC	R16
    0420 95EA      DEC	R30
    0421 F759      BNE	0x040D
    0422 F426      BRTC	0x0427
    0423 2D08      MOV	R16,R8
    0424 2D19      MOV	R17,R9
    0425 2D2A      MOV	R18,R10
    0426 2D3B      MOV	R19,R11
    0427 C013      RJMP	long_div_epilog
long_div_prolog:
    0428 927A      ST	R7,-Y
    0429 928A      ST	R8,-Y
    042A 929A      ST	R9,-Y
    042B 92AA      ST	R10,-Y
    042C 92BA      ST	R11,-Y
    042D 92CA      ST	R12,-Y
    042E 93EA      ST	R30,-Y
    042F 938A      ST	R24,-Y
    0430 939A      ST	R25,-Y
    0431 93AA      ST	R26,-Y
    0432 93BA      ST	R27,-Y
    0433 858B      LDD	R24,Y+11
    0434 859C      LDD	R25,Y+12
    0435 85AD      LDD	R26,Y+13
    0436 85BE      LDD	R27,Y+14
    0437 2EC3      MOV	R12,R19
    0438 F00E      BRTS	0x043A
    0439 26CB      EOR	R12,R27
    043A 9508      RET
long_div_epilog:
    043B FCC7      SBRC	R12,7
    043C D017      RCALL	neg_R16_R19
    043D 91B9      LD	R27,Y+
    043E 91A9      LD	R26,Y+
    043F 9199      LD	R25,Y+
    0440 9189      LD	R24,Y+
    0441 91E9      LD	R30,Y+
    0442 90C9      LD	R12,Y+
    0443 90B9      LD	R11,Y+
    0444 90A9      LD	R10,Y+
    0445 9099      LD	R9,Y+
    0446 9089      LD	R8,Y+
    0447 9079      LD	R7,Y+
    0448 9624      ADIW	R28,4
    0449 9508      RET
tst_R16_R19:
    044A 2FE0      MOV	R30,R16
    044B 2BE1      OR	R30,R17
    044C 2BE2      OR	R30,R18
    044D 2BE3      OR	R30,R19
    044E 9508      RET
tst_R24_R27:
    044F 2FE8      MOV	R30,R24
    0450 2BE9      OR	R30,R25
    0451 2BEA      OR	R30,R26
    0452 2BEB      OR	R30,R27
    0453 9508      RET
neg_R16_R19:
    0454 9500      COM	R16
    0455 9510      COM	R17
    0456 9520      COM	R18
    0457 9530      COM	R19
    0458 5F0F      SUBI	R16,0xFF
    0459 4F1F      SBCI	R17,0xFF
    045A 4F2F      SBCI	R18,0xFF
    045B 4F3F      SBCI	R19,0xFF
    045C 9508      RET
neg_R24_R27:
    045D 9580      COM	R24
    045E 9590      COM	R25
    045F 95A0      COM	R26
    0460 95B0      COM	R27
    0461 5F8F      SUBI	R24,0xFF
    0462 4F9F      SBCI	R25,0xFF
    0463 4FAF      SBCI	R26,0xFF
    0464 4FBF      SBCI	R27,0xFF
    0465 9508      RET
empy32s:
empy32u:
    0466 940E04C1  CALL	long_prolog
    0468 927F      PUSH	R7
    0469 940E04DA  CALL	tstzero1
    046B F139      BEQ	0x0493
    046C 2477      CLR	R7
    046D 940E04E0  CALL	tstzero2
    046F F419      BNE	0x0473
    0470 018C      MOVW	R16,R24
    0471 019D      MOVW	R18,R26
    0472 C020      RJMP	0x0493
    0473 9F08      MUL	R16,R24
    0474 2CB0      MOV	R11,R0
    0475 2CA1      MOV	R10,R1
    0476 9F28      MUL	R18,R24
    0477 2C90      MOV	R9,R0
    0478 2C81      MOV	R8,R1
    0479 9F18      MUL	R17,R24
    047A 0CA0      ADD	R10,R0
    047B 1C91      ADC	R9,R1
    047C 1C87      ADC	R8,R7
    047D 9F09      MUL	R16,R25
    047E 0CA0      ADD	R10,R0
    047F 1C91      ADC	R9,R1
    0480 1C87      ADC	R8,R7
    0481 9F19      MUL	R17,R25
    0482 0C90      ADD	R9,R0
    0483 1C81      ADC	R8,R1
    0484 9F0A      MUL	R16,R26
    0485 0C90      ADD	R9,R0
    0486 1C81      ADC	R8,R1
    0487 9F38      MUL	R19,R24
    0488 0C80      ADD	R8,R0
    0489 9F29      MUL	R18,R25
    048A 0C80      ADD	R8,R0
    048B 9F1A      MUL	R17,R26
    048C 0C80      ADD	R8,R0
    048D 9F0B      MUL	R16,R27
    048E 0C80      ADD	R8,R0
    048F 2D0B      MOV	R16,R11
    0490 2D1A      MOV	R17,R10
    0491 2D29      MOV	R18,R9
    0492 2D38      MOV	R19,R8
    0493 907F      POP	R7
    0494 940C04CF  JMP	long_epilog
pop_gset2:
    0496 E0E2      LDI	R30,2
    0497 940C04AE  JMP	pop
pop_gset3:
    0499 E0E4      LDI	R30,4
    049A 940C04AE  JMP	pop
pop_gset4:
    049C E0E8      LDI	R30,0x8
    049D 940C04AE  JMP	pop
pop_gset5:
    049F 27EE      CLR	R30
    04A0 940C04AE  JMP	pop
push_gset5:
    04A2 92FA      ST	R15,-Y
    04A3 92EA      ST	R14,-Y
push_gset4:
    04A4 92DA      ST	R13,-Y
    04A5 92CA      ST	R12,-Y
push_gset3:
    04A6 92BA      ST	R11,-Y
    04A7 92AA      ST	R10,-Y
push_gset2:
    04A8 937A      ST	R23,-Y
    04A9 936A      ST	R22,-Y
push_gset1:
    04AA 935A      ST	R21,-Y
    04AB 934A      ST	R20,-Y
    04AC 9508      RET
pop_gset1:
    04AD E0E1      LDI	R30,1
pop:
    04AE 9149      LD	R20,Y+
    04AF 9159      LD	R21,Y+
    04B0 FDE0      SBRC	R30,0
    04B1 9508      RET
    04B2 9169      LD	R22,Y+
    04B3 9179      LD	R23,Y+
    04B4 FDE1      SBRC	R30,1
    04B5 9508      RET
    04B6 90A9      LD	R10,Y+
    04B7 90B9      LD	R11,Y+
    04B8 FDE2      SBRC	R30,2
    04B9 9508      RET
    04BA 90C9      LD	R12,Y+
    04BB 90D9      LD	R13,Y+
    04BC FDE3      SBRC	R30,3
    04BD 9508      RET
    04BE 90E9      LD	R14,Y+
    04BF 90F9      LD	R15,Y+
    04C0 9508      RET
long_prolog:
    04C1 928A      ST	R8,-Y
    04C2 929A      ST	R9,-Y
    04C3 92AA      ST	R10,-Y
    04C4 92BA      ST	R11,-Y
    04C5 93EA      ST	R30,-Y
    04C6 938A      ST	R24,-Y
    04C7 939A      ST	R25,-Y
    04C8 93AA      ST	R26,-Y
    04C9 93BA      ST	R27,-Y
    04CA 8589      LDD	R24,Y+9
    04CB 859A      LDD	R25,Y+10
    04CC 85AB      LDD	R26,Y+11
    04CD 85BC      LDD	R27,Y+12
    04CE 9508      RET
long_epilog:
    04CF 91B9      LD	R27,Y+
    04D0 91A9      LD	R26,Y+
    04D1 9199      LD	R25,Y+
    04D2 9189      LD	R24,Y+
    04D3 91E9      LD	R30,Y+
    04D4 90B9      LD	R11,Y+
    04D5 90A9      LD	R10,Y+
    04D6 9099      LD	R9,Y+
    04D7 9089      LD	R8,Y+
    04D8 9624      ADIW	R28,4
    04D9 9508      RET
tstzero1:
    04DA 27EE      CLR	R30
    04DB 2BE0      OR	R30,R16
    04DC 2BE1      OR	R30,R17
    04DD 2BE2      OR	R30,R18
    04DE 2BE3      OR	R30,R19
    04DF 9508      RET
tstzero2:
    04E0 27EE      CLR	R30
    04E1 2BE8      OR	R30,R24
    04E2 2BE9      OR	R30,R25
    04E3 2BEA      OR	R30,R26
    04E4 2BEB      OR	R30,R27
    04E5 9508      RET
