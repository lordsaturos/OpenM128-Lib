                        .module WDT.C
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\..\..\KERNEL~1\ATmega128\内核－WDT\WDT\WDT.C
 0000                   .dbfile D:\ICC_H\Software.H
 0000                   .dbfunc e speaData _speaData fV
 0000           ;              y -> y+4
 0000           ;              j -> y+0
 0000           ;              i -> R10
 0000           ;            len -> R12
 0000           ;            dat -> y+16
                        .even
 0000           _speaData::
 0000 0E940000          xcall push_arg4
 0004 0E940000          xcall push_xgsetF03C
 0008 2897              sbiw R28,8
 000A CC88              ldd R12,y+20
 000C                   .dbline -1
 000C                   .dbline 116
 000C           ; /*********************************************************************
 000C           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 000C           ;                                                                       
 000C           ; 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
 000C           ;       
 000C           ; 目标系统:   基于AVR单片机
 000C           ;                                                                               
 000C           ; 应用软件:   ICCAVR
 000C           ;                                                                               
 000C           ; 版    本:   Version 1.0                                                       
 000C           ;                                                                               
 000C           ; 圆版时间:   2005-06-25
 000C           ;       
 000C           ; 开发人员:   SEE
 000C           ; 
 000C           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 000C           ;       
 000C           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 000C           ; *********************************************************************/
 000C           ; 
 000C           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 000C           ; ----------------------------------------------------------------------
 000C           ; 版本更新记录：
 000C           ; 
 000C           ; ----------------------------------------------------------------------
 000C           ; 入口参数说明：
 000C           ; 
 000C           ; ----------------------------------------------------------------------
 000C           ; 待定参数说明：
 000C           ; 
 000C           ; ----------------------------------------------------------------------        
 000C           ; 对外变量说明：
 000C           ;     
 000C           ; ----------------------------------------------------------------------
 000C           ; 对外函数说明：
 000C           ;    
 000C           ; ----------------------------------------------------------------------
 000C           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 000C           ; 
 000C           ; #ifndef Software_H
 000C           ; #define Software_H
 000C           ; 
 000C           ; #include <math.h>
 000C           ; #include <string.h>
 000C           ; 
 000C           ; /* 兼容一般程序员的常用写法 */
 000C           ; typedef unsigned char uchar;
 000C           ; typedef unsigned int  uint;
 000C           ; typedef unsigned long ulong;
 000C           ; typedef signed char           schar;
 000C           ; typedef signed int            sint;
 000C           ; typedef signed long           slong;
 000C           ; 
 000C           ; /* 为方便移植，建议使用下面写法 */
 000C           ; typedef unsigned char bool;
 000C           ; typedef unsigned char uint8;
 000C           ; typedef unsigned int  uint16;
 000C           ; typedef unsigned long   uint32;
 000C           ; typedef signed  char  sint8;
 000C           ; typedef signed        int             sint16;
 000C           ; typedef signed        long    sint32;
 000C           ; typedef signed  char  int8;
 000C           ; typedef signed  int           int16;
 000C           ; typedef signed  long  int32;
 000C           ; 
 000C           ; /* 下面写法一般不推荐 */
 000C           ; //typedef unsigned char ubyte;
 000C           ; //typedef unsigned int        uword;
 000C           ; //typedef unsigned long udword;
 000C           ; //typedef signed   char       sbyte;
 000C           ; //typedef signed   int        sword;
 000C           ; //typedef signed   long       sdword;
 000C           ; 
 000C           ; /* 一般程序定义的默认值 */
 000C           ; //#define NULL                        0
 000C           ; //#define EOF                 -1
 000C           ; //#define TRUE                1
 000C           ; //#define FALSE               0
 000C           ; //#define YES                 1
 000C           ; //#define NO                          0
 000C           ; //#define ON                  1
 000C           ; //#define OFF                 0
 000C           ; //#define ENABLE              1
 000C           ; //#define DISABLE             0
 000C           ; //#define CRR                 1
 000C           ; //#define ERR                 0
 000C           ; //#define RIGHT                       1
 000C           ; //#define WRONG                       0
 000C           ; //#define SUCCESS             1
 000C           ; //#define FAILURE             0
 000C           ; //#define PI                  3.1415926       //3.1415926535897932
 000C           ; 
 000C           ; /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
 000C           ; //#define _CALLOC(a)          ( (a *)calloc(n,sizeof(a)) )
 000C           ; //#define _MALLOC(a)          ( (a *)malloc(sizeof(a)) )
 000C           ; //#define _MIN(a,b)                   ( (a) < (b) ? (a) : (b) )
 000C           ; //#define _MAX(a,b)                   ( (a) > (b) ? (a) : (b) )
 000C           ; //#define _EXCHANGE(a,b)      { int t; t=a; a=b; b=t; }
 000C           ; //#define _TOLOWER(c)         ( (c)+32 )
 000C           ; //#define _TOUPPER(c)         ( (c)-32 )
 000C           ; 
 000C           ; //#ifndef BIT
 000C           ; //#define BIT(x)      ( 1<<(x) )
 000C           ; //#endif
 000C           ; 
 000C           ; /*--------------------------------------------------------------------
 000C           ; 函数全称：数据拆字
 000C           ; 函数功能：
 000C           ; 注意事项：D<=999999,C<=6
 000C           ; 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
 000C           ; 输    入：
 000C           ; 返    回：无
 000C           ; --------------------------------------------------------------------*/
 000C           ; uint8 dataElem[6];
 000C           ; void speaData(uint32 dat,sint8 len)
 000C           ; {
 000C                   .dbline 119
 000C           ;     uint8 i;
 000C           ;     uint32 j,y;
 000C           ;     for(i=0,j=1;i<len;i++)
 000C AA24              clr R10
 000E 81E0              ldi R24,1
 0010 8883              std y+0,R24
 0012 80E0              ldi R24,0
 0014 8983              std y+1,R24
 0016 8A83              std y+2,R24
 0018 8B83              std y+3,R24
 001A 3CC0              xjmp L5
 001C           L2:
 001C                   .dbline 120
 001C           ;     {
 001C                   .dbline 121
 001C           ;         y=dat/j;
 001C 2880              ldd R2,y+0
 001E 3980              ldd R3,y+1
 0020 4A80              ldd R4,y+2
 0022 5B80              ldd R5,y+3
 0024 0889              ldd R16,y+16
 0026 1989              ldd R17,y+17
 0028 2A89              ldd R18,y+18
 002A 3B89              ldd R19,y+19
 002C 5A92              st -y,R5
 002E 4A92              st -y,R4
 0030 3A92              st -y,R3
 0032 2A92              st -y,R2
 0034 0E940000          xcall div32u
 0038 0C83              std y+4,R16
 003A 1D83              std y+5,R17
 003C 2E83              std y+6,R18
 003E 3F83              std y+7,R19
 0040                   .dbline 122
 0040           ;         dataElem[i]=y%10;
 0040 4AE0              ldi R20,10
 0042 50E0              ldi R21,0
 0044 60E0              ldi R22,0
 0046 70E0              ldi R23,0
 0048 0C81              ldd R16,y+4
 004A 1D81              ldd R17,y+5
 004C 2E81              ldd R18,y+6
 004E 3F81              ldd R19,y+7
 0050 7A93              st -y,R23
 0052 6A93              st -y,R22
 0054 5A93              st -y,R21
 0056 4A93              st -y,R20
 0058 0E940000          xcall mod32u
 005C 80E0              ldi R24,<_dataElem
 005E 90E0              ldi R25,>_dataElem
 0060 EA2D              mov R30,R10
 0062 FF27              clr R31
 0064 E80F              add R30,R24
 0066 F91F              adc R31,R25
 0068 0083              std z+0,R16
 006A                   .dbline 123
 006A           ;         j*=10;
 006A 2880              ldd R2,y+0
 006C 3980              ldd R3,y+1
 006E 4A80              ldd R4,y+2
 0070 5B80              ldd R5,y+3
 0072 4AE0              ldi R20,10
 0074 50E0              ldi R21,0
 0076 60E0              ldi R22,0
 0078 70E0              ldi R23,0
 007A 5A92              st -y,R5
 007C 4A92              st -y,R4
 007E 3A92              st -y,R3
 0080 2A92              st -y,R2
 0082 8A01              movw R16,R20
 0084 9B01              movw R18,R22
 0086 0E940000          xcall empy32u
 008A 0883              std y+0,R16
 008C 1983              std y+1,R17
 008E 2A83              std y+2,R18
 0090 3B83              std y+3,R19
 0092                   .dbline 124
 0092           ;     }
 0092           L3:
 0092                   .dbline 119
 0092 A394              inc R10
 0094           L5:
 0094                   .dbline 119
 0094 2C2C              mov R2,R12
 0096 3324              clr R3
 0098 27FC              sbrc R2,7
 009A 3094              com R3
 009C 4A2C              mov R4,R10
 009E 5524              clr R5
 00A0 4214              cp R4,R2
 00A2 5304              cpc R5,R3
 00A4 0CF4              brge X1
 00A6 BACF              xjmp L2
 00A8           X1:
 00A8           X0:
 00A8                   .dbline -2
 00A8           L1:
 00A8                   .dbline 0 ; func end
 00A8 2896              adiw R28,8
 00AA 0E940000          xcall pop_xgsetF03C
 00AE 2496              adiw R28,4
 00B0 0895              ret
 00B2                   .dbsym l y 4 l
 00B2                   .dbsym l j 0 l
 00B2                   .dbsym r i 10 c
 00B2                   .dbsym r len 12 C
 00B2                   .dbsym l dat 16 l
 00B2                   .dbend
 00B2                   .dbfile D:\ICC_H\I2C.H
 00B2                   .dbfunc e I2C_Start _I2C_Start fc
                        .even
 00B2           _I2C_Start::
 00B2                   .dbline -1
 00B2                   .dbline 126
 00B2           ; /*********************************************************************
 00B2           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 00B2           ;                                                                       
 00B2           ; 目    的:   建立I2C操作库
 00B2           ;       
 00B2           ; 目标系统:   基于AVR单片机
 00B2           ;                                                                               
 00B2           ; 应用软件:   ICCAVR
 00B2           ;                                                                               
 00B2           ; 版    本:   Version 1.0                                                          
 00B2           ;                                                                               
 00B2           ; 圆版时间:   2005-06-25
 00B2           ;       
 00B2           ; 开发人员:   SEE
 00B2           ; 
 00B2           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 00B2           ;       
 00B2           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 00B2           ; *********************************************************************/
 00B2           ; 
 00B2           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 版本更新记录：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 入口参数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 待定参数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------        
 00B2           ; 对外变量说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 对外函数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 00B2           ; 
 00B2           ; #ifndef I2C_H
 00B2           ; #define I2C_H
 00B2           ; 
 00B2           ; /* TWSR values (not bits) */
 00B2           ; /* Master */
 00B2           ; #define I2C_START                     0x08
 00B2           ; #define I2C_RESTART                   0x10
 00B2           ; 
 00B2           ; /* Master Transmitter */
 00B2           ; #define I2C_MT_SLA_ACK                0x18
 00B2           ; #define I2C_MT_SLA_NACK               0x20
 00B2           ; #define I2C_MT_DATA_ACK               0x28
 00B2           ; #define I2C_MT_DATA_NACK      0x30
 00B2           ; #define I2C_MT_ARB_LOST               0x38
 00B2           ; 
 00B2           ; /* Master Receiver */
 00B2           ; #define I2C_MR_ARB_LOST               0x38
 00B2           ; #define I2C_MR_SLA_ACK                0x40
 00B2           ; #define I2C_MR_SLA_NACK               0x48
 00B2           ; #define I2C_MR_DATA_ACK               0x50
 00B2           ; #define I2C_MR_DATA_NACK      0x58
 00B2           ; 
 00B2           ; /* Slave Transmitter */
 00B2           ; #define I2C_ST_SLA_ACK                        0xA8
 00B2           ; #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
 00B2           ; #define I2C_ST_DATA_ACK                       0xB8
 00B2           ; #define I2C_ST_DATA_NACK              0xC0
 00B2           ; #define I2C_ST_LAST_DATA              0xC8
 00B2           ; 
 00B2           ; /* Slave Receiver */
 00B2           ; #define I2C_SR_SLA_ACK                                0x60
 00B2           ; #define I2C_SR_ARB_LOST_SLA_ACK               0x68
 00B2           ; #define I2C_SR_GCALL_ACK                      0x70
 00B2           ; #define I2C_SR_ARB_LOST_GCALL_ACK     0x78
 00B2           ; #define I2C_SR_DATA_ACK                               0x80
 00B2           ; #define I2C_SR_DATA_NACK                      0x88
 00B2           ; #define I2C_SR_GCALL_DATA_ACK         0x90
 00B2           ; #define I2C_SR_GCALL_DATA_NACK                0x98
 00B2           ; #define I2C_SR_STOP                                   0xA0
 00B2           ; 
 00B2           ; /* Misc */
 00B2           ; #define I2C_NO_INFO                   0xF8
 00B2           ; #define I2C_BUS_ERROR         0x00
 00B2           ; 
 00B2           ; /*
 00B2           ;  * The lower 3 bits of TWSR are reserved on the ATmega163.
 00B2           ;  * The 2 LSB carry the prescaler bits on the newer ATmegas.
 00B2           ;  */
 00B2           ; #define I2C_STATUS_MASK       (_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
 00B2           ; #define I2C_STATUS            (TWSR & I2C_STATUS_MASK)
 00B2           ; 
 00B2           ; /*
 00B2           ;  * R/~W bit in SLA+R/W address field.
 00B2           ;  */
 00B2           ; #define I2C_READ              1
 00B2           ; #define I2C_WRITE             0
 00B2           ; 
 00B2           ; #define I2CStart()            (TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
 00B2           ; #define I2CStop()             (TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
 00B2           ; #define I2CWaitAck()  {while(!(TWCR&(1<<TWINT)));}
 00B2           ; #define I2CChkAck()   (TWSR&0xf8)                                     //check ack
 00B2           ; #define I2CSendAck()  (TWCR|=(1<<TWEA))
 00B2           ; #define I2CSendNoAck()        (TWCR&=~(1<<TWEA))
 00B2           ; #define I2CSendByte(x)        {TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
 00B2           ; #define I2CRcvNckByte()       (TWCR=(1<<TWINT)|(1<<TWEN))
 00B2           ; #define I2CRcvAckByte()       (TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
 00B2           ; 
 00B2           ; /* For Program */
 00B2           ; #define I2C_Stop()            I2CStop()
 00B2           ; #define I2C_SendAck() I2CSendAck()
 00B2           ; #define I2C_SendNoAck() I2CSendNoAck()
 00B2           ; #define I2C_WaitAck() I2CWaitAck()
 00B2           ; 
 00B2           ; /* I2C Config */
 00B2           ; #define I2C_ERR                       0
 00B2           ; #define I2C_CRR                       1
 00B2           ; 
 00B2           ; /*--------------------------------------------------------------------
 00B2           ; 函数名称：I2C Start
 00B2           ; 函数功能：
 00B2           ; 注意事项：
 00B2           ; 提示说明：
 00B2           ; 输    入：
 00B2           ; 返    回：
 00B2           ; --------------------------------------------------------------------*/
 00B2           ; bool I2C_Start()                                      
 00B2           ; {
 00B2                   .dbline 127
 00B2           ;       I2CStart();                                             
 00B2 84EA              ldi R24,164
 00B4 80937400          sts 116,R24
 00B8                   .dbline 128
 00B8           ;       I2CWaitAck();
 00B8           L7:
 00B8                   .dbline 128
 00B8           L8:
 00B8                   .dbline 128
 00B8 20907400          lds R2,116
 00BC 27FE              sbrs R2,7
 00BE FCCF              rjmp L7
 00C0           X2:
 00C0                   .dbline 128
 00C0                   .dbline 128
 00C0                   .dbline 129
 00C0           ;       if( I2CChkAck()!=I2C_START ) 
 00C0 80917100          lds R24,113
 00C4 887F              andi R24,248
 00C6 8830              cpi R24,8
 00C8 11F0              breq L10
 00CA           X3:
 00CA                   .dbline 130
 00CA           ;               return I2C_ERR;
 00CA 0027              clr R16
 00CC 01C0              xjmp L6
 00CE           L10:
 00CE                   .dbline 131
 00CE           ;       return I2C_CRR;
 00CE 01E0              ldi R16,1
 00D0                   .dbline -2
 00D0           L6:
 00D0                   .dbline 0 ; func end
 00D0 0895              ret
 00D2                   .dbend
 00D2                   .dbfunc e I2C_Restart _I2C_Restart fc
                        .even
 00D2           _I2C_Restart::
 00D2                   .dbline -1
 00D2                   .dbline 142
 00D2           ; }
 00D2           ; /*--------------------------------------------------------------------
 00D2           ; 函数名称：I2C ReStart
 00D2           ; 函数功能：
 00D2           ; 注意事项：
 00D2           ; 提示说明：
 00D2           ; 输    入：
 00D2           ; 返    回：
 00D2           ; --------------------------------------------------------------------*/
 00D2           ; bool I2C_Restart()                                    
 00D2           ; {
 00D2                   .dbline 143
 00D2           ;       I2CStart();                                             
 00D2 84EA              ldi R24,164
 00D4 80937400          sts 116,R24
 00D8                   .dbline 144
 00D8           ;       I2CWaitAck();
 00D8           L13:
 00D8                   .dbline 144
 00D8           L14:
 00D8                   .dbline 144
 00D8 20907400          lds R2,116
 00DC 27FE              sbrs R2,7
 00DE FCCF              rjmp L13
 00E0           X4:
 00E0                   .dbline 144
 00E0                   .dbline 144
 00E0                   .dbline 145
 00E0           ;       if( I2CChkAck()!=I2C_RESTART ) 
 00E0 80917100          lds R24,113
 00E4 887F              andi R24,248
 00E6 8031              cpi R24,16
 00E8 11F0              breq L16
 00EA           X5:
 00EA                   .dbline 146
 00EA           ;               return I2C_ERR;
 00EA 0027              clr R16
 00EC 01C0              xjmp L12
 00EE           L16:
 00EE                   .dbline 147
 00EE           ;       return I2C_CRR;
 00EE 01E0              ldi R16,1
 00F0                   .dbline -2
 00F0           L12:
 00F0                   .dbline 0 ; func end
 00F0 0895              ret
 00F2                   .dbend
 00F2                   .dbfunc e I2C_SendWrDAdr _I2C_SendWrDAdr fc
 00F2           ;         wrDAdr -> R16
                        .even
 00F2           _I2C_SendWrDAdr::
 00F2                   .dbline -1
 00F2                   .dbline 158
 00F2           ; }
 00F2           ; /*--------------------------------------------------------------------
 00F2           ; 函数名称：发送 7位 器件写地址: XXXX XXX0
 00F2           ; 函数功能：
 00F2           ; 注意事项：
 00F2           ; 提示说明：
 00F2           ; 输    入：
 00F2           ; 返    回：
 00F2           ; --------------------------------------------------------------------*/
 00F2           ; bool I2C_SendWrDAdr(uint8 wrDAdr)     
 00F2           ; {
 00F2                   .dbline 159
 00F2           ;       I2CSendByte(wrDAdr);                    //设置 器件写地址
 00F2                   .dbline 159
 00F2 00937300          sts 115,R16
 00F6                   .dbline 159
 00F6 84E8              ldi R24,132
 00F8 80937400          sts 116,R24
 00FC                   .dbline 159
 00FC                   .dbline 159
 00FC                   .dbline 160
 00FC           ;       I2CWaitAck();
 00FC           L19:
 00FC                   .dbline 160
 00FC           L20:
 00FC                   .dbline 160
 00FC 20907400          lds R2,116
 0100 27FE              sbrs R2,7
 0102 FCCF              rjmp L19
 0104           X6:
 0104                   .dbline 160
 0104                   .dbline 160
 0104                   .dbline 161
 0104           ;       if( I2CChkAck()!=I2C_MT_SLA_ACK )  
 0104 80917100          lds R24,113
 0108 887F              andi R24,248
 010A 8831              cpi R24,24
 010C 11F0              breq L22
 010E           X7:
 010E                   .dbline 162
 010E           ;               return I2C_ERR;
 010E 0027              clr R16
 0110 01C0              xjmp L18
 0112           L22:
 0112                   .dbline 163
 0112           ;       return I2C_CRR;         
 0112 01E0              ldi R16,1
 0114                   .dbline -2
 0114           L18:
 0114                   .dbline 0 ; func end
 0114 0895              ret
 0116                   .dbsym r wrDAdr 16 c
 0116                   .dbend
 0116                   .dbfunc e I2C_SendWrDAdr_ _I2C_SendWrDAdr_ fc
 0116           ;         wrDAdr -> R10,R11
                        .even
 0116           _I2C_SendWrDAdr_::
 0116 AA92              st -y,R10
 0118 BA92              st -y,R11
 011A 5801              movw R10,R16
 011C                   .dbline -1
 011C                   .dbline 174
 011C           ; }
 011C           ; /*--------------------------------------------------------------------
 011C           ; 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
 011C           ; 函数功能：
 011C           ; 注意事项：
 011C           ; 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
 011C           ; 输    入：
 011C           ; 返    回：
 011C           ; --------------------------------------------------------------------*/
 011C           ; bool I2C_SendWrDAdr_(uint16 wrDAdr)   
 011C           ; {
 011C                   .dbline 175
 011C           ;       if( wrDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 011C A0FE              sbrs R10,0
 011E 0EC0              rjmp L25
 0120           X8:
 0120                   .dbline 176
 0120           ;               if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )       //设置 （高位）器件写地址
 0120 0A2D              mov R16,R10
 0122 0695              lsr R16
 0124 0695              lsr R16
 0126 0695              lsr R16
 0128 0695              lsr R16
 012A 0695              lsr R16
 012C 0695              lsr R16
 012E 0695              lsr R16
 0130 0695              lsr R16
 0132 DFDF              xcall _I2C_SendWrDAdr
 0134 0023              tst R16
 0136 11F4              brne L27
 0138           X9:
 0138                   .dbline 177
 0138           ;                       return I2C_ERR;
 0138 0027              clr R16
 013A 07C0              xjmp L24
 013C           L27:
 013C           L25:
 013C                   .dbline 178
 013C           ;       if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )  //设置 （低位）器件写地址
 013C 0A2D              mov R16,R10
 013E D9DF              xcall _I2C_SendWrDAdr
 0140 0023              tst R16
 0142 11F4              brne L29
 0144           X10:
 0144                   .dbline 179
 0144           ;               return I2C_ERR;
 0144 0027              clr R16
 0146 01C0              xjmp L24
 0148           L29:
 0148                   .dbline 180
 0148           ;       return I2C_CRR;
 0148 01E0              ldi R16,1
 014A                   .dbline -2
 014A           L24:
 014A                   .dbline 0 ; func end
 014A B990              ld R11,y+
 014C A990              ld R10,y+
 014E 0895              ret
 0150                   .dbsym r wrDAdr 10 i
 0150                   .dbend
 0150                   .dbfunc e I2C_SendRdDAdr _I2C_SendRdDAdr fc
 0150           ;         rdDAdr -> R16
                        .even
 0150           _I2C_SendRdDAdr::
 0150                   .dbline -1
 0150                   .dbline 191
 0150           ; }
 0150           ; /*--------------------------------------------------------------------
 0150           ; 函数名称：发送 7位 器件读地址: XXXX XXX1
 0150           ; 函数功能：
 0150           ; 注意事项：
 0150           ; 提示说明：
 0150           ; 输    入：
 0150           ; 返    回：
 0150           ; --------------------------------------------------------------------*/
 0150           ; bool I2C_SendRdDAdr(uint8 rdDAdr)     
 0150           ; {
 0150                   .dbline 192
 0150           ;       I2CSendByte(rdDAdr);                    //设置 器件读地址
 0150                   .dbline 192
 0150 00937300          sts 115,R16
 0154                   .dbline 192
 0154 84E8              ldi R24,132
 0156 80937400          sts 116,R24
 015A                   .dbline 192
 015A                   .dbline 192
 015A                   .dbline 193
 015A           ;       I2CWaitAck();
 015A           L32:
 015A                   .dbline 193
 015A           L33:
 015A                   .dbline 193
 015A 20907400          lds R2,116
 015E 27FE              sbrs R2,7
 0160 FCCF              rjmp L32
 0162           X11:
 0162                   .dbline 193
 0162                   .dbline 193
 0162                   .dbline 194
 0162           ;       if( I2CChkAck()!=I2C_MR_SLA_ACK )  
 0162 80917100          lds R24,113
 0166 887F              andi R24,248
 0168 8034              cpi R24,64
 016A 11F0              breq L35
 016C           X12:
 016C                   .dbline 195
 016C           ;               return I2C_ERR;
 016C 0027              clr R16
 016E 01C0              xjmp L31
 0170           L35:
 0170                   .dbline 196
 0170           ;       return I2C_CRR; 
 0170 01E0              ldi R16,1
 0172                   .dbline -2
 0172           L31:
 0172                   .dbline 0 ; func end
 0172 0895              ret
 0174                   .dbsym r rdDAdr 16 c
 0174                   .dbend
 0174                   .dbfunc e I2C_SendRdDAdr_ _I2C_SendRdDAdr_ fc
 0174           ;         rdDAdr -> R10
                        .even
 0174           _I2C_SendRdDAdr_::
 0174 AA92              st -y,R10
 0176 A02E              mov R10,R16
 0178                   .dbline -1
 0178                   .dbline 207
 0178           ; }
 0178           ; /*--------------------------------------------------------------------
 0178           ; 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
 0178           ; 函数功能：
 0178           ; 注意事项：
 0178           ; 提示说明：
 0178           ; 输    入：
 0178           ; 返    回：
 0178           ; --------------------------------------------------------------------*/
 0178           ; bool I2C_SendRdDAdr_(uint8 rdDAdr)    
 0178           ; {
 0178                   .dbline 208
 0178           ;       if( rdDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 0178 A0FE              sbrs R10,0
 017A 0EC0              rjmp L38
 017C           X13:
 017C                   .dbline 209
 017C           ;               if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )       //设置 （高位）器件读地址
 017C 0A2D              mov R16,R10
 017E 0695              lsr R16
 0180 0695              lsr R16
 0182 0695              lsr R16
 0184 0695              lsr R16
 0186 0695              lsr R16
 0188 0695              lsr R16
 018A 0695              lsr R16
 018C 0695              lsr R16
 018E B1DF              xcall _I2C_SendWrDAdr
 0190 0023              tst R16
 0192 11F4              brne L40
 0194           X14:
 0194                   .dbline 210
 0194           ;                       return I2C_ERR;
 0194 0027              clr R16
 0196 07C0              xjmp L37
 0198           L40:
 0198           L38:
 0198                   .dbline 211
 0198           ;       if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )  //设置 （低位）器件读地址
 0198 0A2D              mov R16,R10
 019A ABDF              xcall _I2C_SendWrDAdr
 019C 0023              tst R16
 019E 11F4              brne L42
 01A0           X15:
 01A0                   .dbline 212
 01A0           ;               return I2C_ERR;
 01A0 0027              clr R16
 01A2 01C0              xjmp L37
 01A4           L42:
 01A4                   .dbline 213
 01A4           ;       return I2C_CRR;
 01A4 01E0              ldi R16,1
 01A6                   .dbline -2
 01A6           L37:
 01A6                   .dbline 0 ; func end
 01A6 A990              ld R10,y+
 01A8 0895              ret
 01AA                   .dbsym r rdDAdr 10 c
 01AA                   .dbend
 01AA                   .dbfunc e I2C_SendDat _I2C_SendDat fc
 01AA           ;      configDat -> R16
                        .even
 01AA           _I2C_SendDat::
 01AA                   .dbline -1
 01AA                   .dbline 224
 01AA           ; }
 01AA           ; /*--------------------------------------------------------------------
 01AA           ; 函数名称：I2C发送数据
 01AA           ; 函数功能：
 01AA           ; 注意事项：
 01AA           ; 提示说明：
 01AA           ; 输    入：
 01AA           ; 返    回：
 01AA           ; --------------------------------------------------------------------*/
 01AA           ; bool I2C_SendDat(uint8 configDat)     
 01AA           ; {
 01AA                   .dbline 225
 01AA           ;       I2CSendByte(configDat);                 
 01AA                   .dbline 225
 01AA 00937300          sts 115,R16
 01AE                   .dbline 225
 01AE 84E8              ldi R24,132
 01B0 80937400          sts 116,R24
 01B4                   .dbline 225
 01B4                   .dbline 225
 01B4                   .dbline 226
 01B4           ;       I2CWaitAck();
 01B4           L45:
 01B4                   .dbline 226
 01B4           L46:
 01B4                   .dbline 226
 01B4 20907400          lds R2,116
 01B8 27FE              sbrs R2,7
 01BA FCCF              rjmp L45
 01BC           X16:
 01BC                   .dbline 226
 01BC                   .dbline 226
 01BC                   .dbline 227
 01BC           ;       if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
 01BC 80917100          lds R24,113
 01C0 887F              andi R24,248
 01C2 8832              cpi R24,40
 01C4 11F0              breq L48
 01C6           X17:
 01C6                   .dbline 228
 01C6           ;               return I2C_ERR;
 01C6 0027              clr R16
 01C8 01C0              xjmp L44
 01CA           L48:
 01CA                   .dbline 229
 01CA           ;       return I2C_CRR; 
 01CA 01E0              ldi R16,1
 01CC                   .dbline -2
 01CC           L44:
 01CC                   .dbline 0 ; func end
 01CC 0895              ret
 01CE                   .dbsym r configDat 16 c
 01CE                   .dbend
 01CE                   .dbfunc e I2C_RcvNAckDat _I2C_RcvNAckDat fc
 01CE           ;         pRdDat -> R16,R17
                        .even
 01CE           _I2C_RcvNAckDat::
 01CE                   .dbline -1
 01CE                   .dbline 240
 01CE           ; }
 01CE           ; /*--------------------------------------------------------------------
 01CE           ; 函数名称：I2C接收数据且不产生应答
 01CE           ; 函数功能：
 01CE           ; 注意事项：
 01CE           ; 提示说明：
 01CE           ; 输    入：
 01CE           ; 返    回：
 01CE           ; --------------------------------------------------------------------*/
 01CE           ; bool I2C_RcvNAckDat(uint8 *pRdDat)    
 01CE           ; {
 01CE                   .dbline 241
 01CE           ;       I2CRcvNckByte();
 01CE 84E8              ldi R24,132
 01D0 80937400          sts 116,R24
 01D4                   .dbline 242
 01D4           ;       I2CWaitAck();
 01D4           L51:
 01D4                   .dbline 242
 01D4           L52:
 01D4                   .dbline 242
 01D4 20907400          lds R2,116
 01D8 27FE              sbrs R2,7
 01DA FCCF              rjmp L51
 01DC           X18:
 01DC                   .dbline 242
 01DC                   .dbline 242
 01DC                   .dbline 243
 01DC           ;       if( I2CChkAck()!=I2C_MR_DATA_NACK )
 01DC 80917100          lds R24,113
 01E0 887F              andi R24,248
 01E2 8835              cpi R24,88
 01E4 11F0              breq L54
 01E6           X19:
 01E6                   .dbline 244
 01E6           ;               return I2C_ERR;
 01E6 0027              clr R16
 01E8 05C0              xjmp L50
 01EA           L54:
 01EA                   .dbline 245
 01EA           ;       *pRdDat=TWDR;
 01EA 20907300          lds R2,115
 01EE F801              movw R30,R16
 01F0 2082              std z+0,R2
 01F2                   .dbline 246
 01F2           ;       return I2C_CRR;
 01F2 01E0              ldi R16,1
 01F4                   .dbline -2
 01F4           L50:
 01F4                   .dbline 0 ; func end
 01F4 0895              ret
 01F6                   .dbsym r pRdDat 16 pc
 01F6                   .dbend
 01F6                   .dbfunc e I2C_RcvAckDat _I2C_RcvAckDat fc
 01F6           ;         pRdDat -> R16,R17
                        .even
 01F6           _I2C_RcvAckDat::
 01F6                   .dbline -1
 01F6                   .dbline 257
 01F6           ; }
 01F6           ; /*--------------------------------------------------------------------
 01F6           ; 函数名称：I2C接收数据且产生应答
 01F6           ; 函数功能：
 01F6           ; 注意事项：
 01F6           ; 提示说明：
 01F6           ; 输    入：
 01F6           ; 返    回：
 01F6           ; --------------------------------------------------------------------*/
 01F6           ; bool I2C_RcvAckDat(uint8 *pRdDat)     
 01F6           ; {
 01F6                   .dbline 258
 01F6           ;       I2CRcvAckByte();                                        
 01F6 84EC              ldi R24,196
 01F8 80937400          sts 116,R24
 01FC                   .dbline 259
 01FC           ;       I2CWaitAck();
 01FC           L57:
 01FC                   .dbline 259
 01FC           L58:
 01FC                   .dbline 259
 01FC 20907400          lds R2,116
 0200 27FE              sbrs R2,7
 0202 FCCF              rjmp L57
 0204           X20:
 0204                   .dbline 259
 0204                   .dbline 259
 0204                   .dbline 260
 0204           ;       if( I2CChkAck()!=I2C_MR_DATA_ACK )
 0204 80917100          lds R24,113
 0208 887F              andi R24,248
 020A 8035              cpi R24,80
 020C 11F0              breq L60
 020E           X21:
 020E                   .dbline 261
 020E           ;               return I2C_ERR;
 020E 0027              clr R16
 0210 05C0              xjmp L56
 0212           L60:
 0212                   .dbline 262
 0212           ;       *pRdDat=TWDR;
 0212 20907300          lds R2,115
 0216 F801              movw R30,R16
 0218 2082              std z+0,R2
 021A                   .dbline 263
 021A           ;       return I2C_CRR;
 021A 01E0              ldi R16,1
 021C                   .dbline -2
 021C           L56:
 021C                   .dbline 0 ; func end
 021C 0895              ret
 021E                   .dbsym r pRdDat 16 pc
 021E                   .dbend
 021E                   .dbfunc e I2C_Write _I2C_Write fc
 021E           ;            dat -> R10
 021E           ;        wordAdr -> R12
 021E           ;         wrDAdr -> R14,R15
                        .even
 021E           _I2C_Write::
 021E 0E940000          xcall push_xgset00FC
 0222 C22E              mov R12,R18
 0224 7801              movw R14,R16
 0226 AE80              ldd R10,y+6
 0228                   .dbline -1
 0228                   .dbline 276
 0228           ; }
 0228           ; /*--------------------------------------------------------------------
 0228           ; 函数名称：I2C写器件，写一个数据
 0228           ; 函数功能：
 0228           ; 注意事项：
 0228           ; 提示说明：
 0228           ; 输    入：wrDAdr: write device-address 写器件地址
 0228           ;                wordAdr: word address 字地址
 0228           ;                dat: data 数据
 0228           ; 返    回：
 0228           ; --------------------------------------------------------------------*/
 0228           ; bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
 0228           ; {
 0228                   .dbline 277
 0228           ;       if( I2C_Start()==I2C_ERR )
 0228 44DF              xcall _I2C_Start
 022A 0023              tst R16
 022C 11F4              brne L63
 022E           X22:
 022E                   .dbline 278
 022E           ;               return I2C_ERR;
 022E 0027              clr R16
 0230 18C0              xjmp L62
 0232           L63:
 0232                   .dbline 280
 0232           ; 
 0232           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 0232 8701              movw R16,R14
 0234 70DF              xcall _I2C_SendWrDAdr_
 0236 0023              tst R16
 0238 11F4              brne L65
 023A           X23:
 023A                   .dbline 281
 023A           ;               return I2C_ERR;
 023A 0027              clr R16
 023C 12C0              xjmp L62
 023E           L65:
 023E                   .dbline 283
 023E           ; 
 023E           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 023E 0C2D              mov R16,R12
 0240 B4DF              xcall _I2C_SendDat
 0242 C02E              mov R12,R16
 0244 0023              tst R16
 0246 11F4              brne L67
 0248           X24:
 0248                   .dbline 284
 0248           ;               return I2C_ERR;
 0248 0027              clr R16
 024A 0BC0              xjmp L62
 024C           L67:
 024C                   .dbline 286
 024C           ; 
 024C           ;       if( I2C_SendDat(dat)==I2C_ERR )
 024C 0A2D              mov R16,R10
 024E ADDF              xcall _I2C_SendDat
 0250 A02E              mov R10,R16
 0252 0023              tst R16
 0254 11F4              brne L69
 0256           X25:
 0256                   .dbline 287
 0256           ;               return I2C_ERR;
 0256 0027              clr R16
 0258 04C0              xjmp L62
 025A           L69:
 025A                   .dbline 289
 025A           ; 
 025A           ;       I2C_Stop();
 025A 84E9              ldi R24,148
 025C 80937400          sts 116,R24
 0260                   .dbline 291
 0260           ; 
 0260           ;       return I2C_CRR;
 0260 01E0              ldi R16,1
 0262                   .dbline -2
 0262           L62:
 0262                   .dbline 0 ; func end
 0262 0C940000          xjmp pop_xgset00FC
 0266                   .dbsym r dat 10 c
 0266                   .dbsym r wordAdr 12 c
 0266                   .dbsym r wrDAdr 14 i
 0266                   .dbend
 0266                   .dbfunc e I2C_Read _I2C_Read fc
 0266           ;         pRdDat -> R10,R11
 0266           ;         rdDAdr -> R12
 0266           ;        wordAdr -> R14
 0266           ;         wrDAdr -> R20,R21
                        .even
 0266           _I2C_Read::
 0266 0E940000          xcall push_xgset30FC
 026A E22E              mov R14,R18
 026C A801              movw R20,R16
 026E C884              ldd R12,y+8
 0270 AA84              ldd R10,y+10
 0272 BB84              ldd R11,y+11
 0274                   .dbline -1
 0274                   .dbline 322
 0274           ; }
 0274           ; /*--------------------------------------------------------------------
 0274           ; 函数名称：I2C写器件，写N个数据
 0274           ; 函数功能：
 0274           ; 注意事项：
 0274           ; 提示说明：
 0274           ; 输    入：wrDAdr: write device-address 写器件地址
 0274           ;                wordAdr: word address 字地址
 0274           ;                *pWrDat: p->write data 写入数据指针
 0274           ;                num: number 写入数据个数
 0274           ; 返    回：
 0274           ; --------------------------------------------------------------------*/
 0274           ; //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
 0274           ; //                              uint8 *pWrDat,uint8 num)
 0274           ; //{
 0274           ; //
 0274           ; //} 
 0274           ; /*--------------------------------------------------------------------
 0274           ; 函数名称：I2C读器件，读一个数据
 0274           ; 函数功能：
 0274           ; 注意事项：
 0274           ; 提示说明：
 0274           ; 输    入：wrDAdr: write device-address 写器件地址
 0274           ;                wordAdr: word address 字地址
 0274           ;                rdDAdr: read device-address 读器件地址
 0274           ;                *pRdDat: p->read data 读取数据指针
 0274           ; 返    回：
 0274           ; --------------------------------------------------------------------*/
 0274           ; bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
 0274           ;                         uint8 rdDAdr,uint8 *pRdDat)
 0274           ; {
 0274                   .dbline 323
 0274           ;       if( I2C_Start()==I2C_ERR )
 0274 1EDF              xcall _I2C_Start
 0276 0023              tst R16
 0278 11F4              brne L72
 027A           X26:
 027A                   .dbline 324
 027A           ;               return I2C_ERR;
 027A 0027              clr R16
 027C 25C0              xjmp L71
 027E           L72:
 027E                   .dbline 326
 027E           ; 
 027E           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 027E 8A01              movw R16,R20
 0280 4ADF              xcall _I2C_SendWrDAdr_
 0282 0023              tst R16
 0284 11F4              brne L74
 0286           X27:
 0286                   .dbline 327
 0286           ;               return I2C_ERR;
 0286 0027              clr R16
 0288 1FC0              xjmp L71
 028A           L74:
 028A                   .dbline 329
 028A           ; 
 028A           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 028A 0E2D              mov R16,R14
 028C 8EDF              xcall _I2C_SendDat
 028E E02E              mov R14,R16
 0290 0023              tst R16
 0292 11F4              brne L76
 0294           X28:
 0294                   .dbline 330
 0294           ;               return I2C_ERR;
 0294 0027              clr R16
 0296 18C0              xjmp L71
 0298           L76:
 0298                   .dbline 332
 0298           ; 
 0298           ;       if( I2C_Restart()==I2C_ERR )
 0298 1CDF              xcall _I2C_Restart
 029A E02E              mov R14,R16
 029C 0023              tst R16
 029E 11F4              brne L78
 02A0           X29:
 02A0                   .dbline 333
 02A0           ;               return I2C_ERR;
 02A0 0027              clr R16
 02A2 12C0              xjmp L71
 02A4           L78:
 02A4                   .dbline 335
 02A4           ; 
 02A4           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 02A4 0C2D              mov R16,R12
 02A6 54DF              xcall _I2C_SendRdDAdr
 02A8 C02E              mov R12,R16
 02AA 0023              tst R16
 02AC 11F4              brne L80
 02AE           X30:
 02AE                   .dbline 336
 02AE           ;               return I2C_ERR;
 02AE 0027              clr R16
 02B0 0BC0              xjmp L71
 02B2           L80:
 02B2                   .dbline 338
 02B2           ; 
 02B2           ;       if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
 02B2 8501              movw R16,R10
 02B4 8CDF              xcall _I2C_RcvNAckDat
 02B6 A02E              mov R10,R16
 02B8 0023              tst R16
 02BA 11F4              brne L82
 02BC           X31:
 02BC                   .dbline 339
 02BC           ;               return I2C_ERR;
 02BC 0027              clr R16
 02BE 04C0              xjmp L71
 02C0           L82:
 02C0                   .dbline 341
 02C0           ; 
 02C0           ;       I2C_Stop();
 02C0 84E9              ldi R24,148
 02C2 80937400          sts 116,R24
 02C6                   .dbline 343
 02C6           ; 
 02C6           ;       return I2C_CRR;
 02C6 01E0              ldi R16,1
 02C8                   .dbline -2
 02C8           L71:
 02C8                   .dbline 0 ; func end
 02C8 0C940000          xjmp pop_xgset30FC
 02CC                   .dbsym r pRdDat 10 pc
 02CC                   .dbsym r rdDAdr 12 c
 02CC                   .dbsym r wordAdr 14 c
 02CC                   .dbsym r wrDAdr 20 i
 02CC                   .dbend
 02CC                   .dbfunc e I2C_Read_ _I2C_Read_ fc
 02CC           ;              i -> R12
 02CC           ;            num -> R20
 02CC           ;         pRdDat -> R10,R11
 02CC           ;         rdDAdr -> R12
 02CC           ;        wordAdr -> R14
 02CC           ;         wrDAdr -> R22,R23
                        .even
 02CC           _I2C_Read_::
 02CC 0E940000          xcall push_xgsetF0FC
 02D0 E22E              mov R14,R18
 02D2 B801              movw R22,R16
 02D4 CA84              ldd R12,y+10
 02D6 AC84              ldd R10,y+12
 02D8 BD84              ldd R11,y+13
 02DA 4E85              ldd R20,y+14
 02DC                   .dbline -1
 02DC                   .dbline 359
 02DC           ; }
 02DC           ; /*--------------------------------------------------------------------
 02DC           ; 函数名称：I2C读器件，读N个数据
 02DC           ; 函数功能：
 02DC           ; 注意事项：
 02DC           ; 提示说明：
 02DC           ; 输    入：wrDAdr: write device-address 写器件地址
 02DC           ;                wordAdr: word address 字地址
 02DC           ;                rdDAdr: read device-address 读器件地址
 02DC           ;                *pRdDat: p->read data 读取数据指针
 02DC           ;                num: number 读取数据个数
 02DC           ; 返    回：
 02DC           ; --------------------------------------------------------------------*/
 02DC           ; bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
 02DC           ;                          uint8 rdDAdr,uint8 *pRdDat,uint8 num)
 02DC           ; {
 02DC                   .dbline 362
 02DC           ;       uint8 i;
 02DC           ;       
 02DC           ;       if( I2C_Start()==I2C_ERR )
 02DC EADE              xcall _I2C_Start
 02DE 0023              tst R16
 02E0 11F4              brne L85
 02E2           X32:
 02E2                   .dbline 363
 02E2           ;               return I2C_ERR;
 02E2 0027              clr R16
 02E4 39C0              xjmp L84
 02E6           L85:
 02E6                   .dbline 365
 02E6           ; 
 02E6           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 02E6 8B01              movw R16,R22
 02E8 16DF              xcall _I2C_SendWrDAdr_
 02EA 0023              tst R16
 02EC 11F4              brne L87
 02EE           X33:
 02EE                   .dbline 366
 02EE           ;               return I2C_ERR;
 02EE 0027              clr R16
 02F0 33C0              xjmp L84
 02F2           L87:
 02F2                   .dbline 368
 02F2           ; 
 02F2           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 02F2 0E2D              mov R16,R14
 02F4 5ADF              xcall _I2C_SendDat
 02F6 E02E              mov R14,R16
 02F8 0023              tst R16
 02FA 11F4              brne L89
 02FC           X34:
 02FC                   .dbline 369
 02FC           ;               return I2C_ERR;
 02FC 0027              clr R16
 02FE 2CC0              xjmp L84
 0300           L89:
 0300                   .dbline 371
 0300           ; 
 0300           ;       if( I2C_Restart()==I2C_ERR )
 0300 E8DE              xcall _I2C_Restart
 0302 E02E              mov R14,R16
 0304 0023              tst R16
 0306 11F4              brne L91
 0308           X35:
 0308                   .dbline 372
 0308           ;               return I2C_ERR;
 0308 0027              clr R16
 030A 26C0              xjmp L84
 030C           L91:
 030C                   .dbline 374
 030C           ; 
 030C           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 030C 0C2D              mov R16,R12
 030E 20DF              xcall _I2C_SendRdDAdr
 0310 C02E              mov R12,R16
 0312 0023              tst R16
 0314 11F4              brne L93
 0316           X36:
 0316                   .dbline 375
 0316           ;               return I2C_ERR;
 0316 0027              clr R16
 0318 1FC0              xjmp L84
 031A           L93:
 031A                   .dbline 377
 031A           ; 
 031A           ;       for(i=0;i<num-1;i++)
 031A CC24              clr R12
 031C 0BC0              xjmp L98
 031E           L95:
 031E                   .dbline 378
 031E           ;               if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
 031E 0C2D              mov R16,R12
 0320 1127              clr R17
 0322 0A0D              add R16,R10
 0324 1B1D              adc R17,R11
 0326 67DF              xcall _I2C_RcvAckDat
 0328 E02E              mov R14,R16
 032A 0023              tst R16
 032C 11F4              brne L99
 032E           X37:
 032E                   .dbline 379
 032E           ;                       return I2C_ERR;
 032E 0027              clr R16
 0330 13C0              xjmp L84
 0332           L99:
 0332           L96:
 0332                   .dbline 377
 0332 C394              inc R12
 0334           L98:
 0334                   .dbline 377
 0334 842F              mov R24,R20
 0336 8150              subi R24,1
 0338 C816              cp R12,R24
 033A 88F3              brlo L95
 033C           X38:
 033C                   .dbline 381
 033C           ;       
 033C           ;       if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
 033C 0C2D              mov R16,R12
 033E 1127              clr R17
 0340 0A0D              add R16,R10
 0342 1B1D              adc R17,R11
 0344 44DF              xcall _I2C_RcvNAckDat
 0346 A02E              mov R10,R16
 0348 0023              tst R16
 034A 11F4              brne L101
 034C           X39:
 034C                   .dbline 382
 034C           ;                       return I2C_ERR;
 034C 0027              clr R16
 034E 04C0              xjmp L84
 0350           L101:
 0350                   .dbline 384
 0350           ; 
 0350           ;       I2C_Stop();
 0350 84E9              ldi R24,148
 0352 80937400          sts 116,R24
 0356                   .dbline 386
 0356           ;       
 0356           ;       return I2C_CRR;
 0356 01E0              ldi R16,1
 0358                   .dbline -2
 0358           L84:
 0358                   .dbline 0 ; func end
 0358 0C940000          xjmp pop_xgsetF0FC
 035C                   .dbsym r i 12 c
 035C                   .dbsym r num 20 c
 035C                   .dbsym r pRdDat 10 pc
 035C                   .dbsym r rdDAdr 12 c
 035C                   .dbsym r wordAdr 14 c
 035C                   .dbsym r wrDAdr 22 i
 035C                   .dbend
 035C                   .dbfile D:\ICC_H\Hardware.H
 035C                   .dbfunc e delay50us _delay50us fV
 035C           ;              j -> R20
 035C           ;              t -> R16,R17
                        .even
 035C           _delay50us::
 035C 4A93              st -y,R20
 035E                   .dbline -1
 035E                   .dbline 105
 035E           ; /*********************************************************************
 035E           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 035E           ;                                                                       
 035E           ; 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
 035E           ;                                       
 035E           ; 目标系统:   基于AVR单片机
 035E           ;                                                                               
 035E           ; 应用软件:   ICCAVR
 035E           ;                                                                               
 035E           ; 版    本:   Version 1.0                                                          
 035E           ;                                                                               
 035E           ; 圆版时间:   2005-06-25
 035E           ;       
 035E           ; 开发人员:   SEE
 035E           ; 
 035E           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 035E           ;       
 035E           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 035E           ; *********************************************************************/
 035E           ; 
 035E           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 035E           ; ----------------------------------------------------------------------
 035E           ; 版本更新记录：
 035E           ; 
 035E           ; ----------------------------------------------------------------------
 035E           ; 入口参数说明：
 035E           ; 
 035E           ; ----------------------------------------------------------------------
 035E           ; 待定参数说明：
 035E           ; 
 035E           ; ----------------------------------------------------------------------        
 035E           ; 对外变量说明：
 035E           ;     
 035E           ; ----------------------------------------------------------------------
 035E           ; 对外函数说明：
 035E           ;    
 035E           ; ----------------------------------------------------------------------
 035E           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 035E           ; 
 035E           ; #ifndef Hardware_H
 035E           ; #define Hardware_H
 035E           ; 
 035E           ; #include <math.h>
 035E           ; #include <string.h>
 035E           ; #include <stdio.h>
 035E           ; #include <macros.h>
 035E           ; #include <eeprom.h>
 035E           ; //#include <wdt.h>
 035E           ; 
 035E           ; /* TWI configs */
 035E           ; //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
 035E           ; #if NO_INCLUDE_I2C_H
 035E           ; ;
 035E           ; #else
 035E           ; #include "D:\ICC_H\I2C.H"     //i2c即AVR的"twi"
 035E           ; #endif
 035E           ; 
 035E           ; /* hard configs */
 035E           ; #ifndef flash
 035E           ;       #define flash   const
 035E           ; #endif
 035E           ; 
 035E           ; #ifndef code
 035E           ;       #define code    const
 035E           ; #endif
 035E           ; 
 035E           ; #ifndef NOP
 035E           ;       #define NOP()   asm("nop")
 035E           ; #endif
 035E           ; 
 035E           ; /* io configs */
 035E           ; #define sbi(io,bit)           (  io |=  (1<<bit) )    //example: sbi(PORTA,0);sbi(DDRA,0);
 035E           ; #define cbi(io,bit)           (  io &= ~(1<<bit) )    //example: cbi(PORTA,0);cbi(DDRA,0);
 035E           ; #define gbi(pin ,bit) ( pin &   (1<<bit) )    //example: gbi(PINA,0);
 035E           ; 
 035E           ; /* interrupt configs */
 035E           ; #define DIS_INT  asm("sei")
 035E           ; #define EN_INT   asm("cli")
 035E           ; 
 035E           ; /* wdt configs */
 035E           ; #define WDT()    asm("wdr")
 035E           ; 
 035E           ; /* bit operation */
 035E           ; //#ifndef BIT
 035E           ; //#define BIT(x)      ( 1<<(x) )
 035E           ; //#endif
 035E           ; 
 035E           ; /* USART configs for 4 Mhz crystal */
 035E           ; //#define BAUD9600                    25
 035E           ; //#define BAUD19000                   12
 035E           ; //#define UART_TRAN_ON()      UCR |=  0x08
 035E           ; //#define UART_TRAN_OFF()     UCR &= ~0x08
 035E           ; //#define UART_RCV_ON()               UCR |=  0x10
 035E           ; //#define UART_RCV_OFF()      UCR &= ~0x10
 035E           ; 
 035E           ; /*--------------------------------------------------------------------
 035E           ; 函数全称：50us 延时
 035E           ; 函数功能：当然是 50us延时 啦
 035E           ; 注意事项：基于7.3728M晶振，稍微有点误差
 035E           ; 提示说明：调用delay50us（20），得到1ms延时
 035E           ; 输    入：    
 035E           ; 返    回：无 
 035E           ; --------------------------------------------------------------------*/
 035E           ; void delay50us(sint16 t)
 035E           ; {
 035E                   .dbline 107
 035E           ;     uint8 j;          
 035E           ;     for(;t>0;t--)                     
 035E 07C0              xjmp L107
 0360           L104:
 0360                   .dbline 108
 0360           ;         for(j=0;j<70;j++)     
 0360 4427              clr R20
 0362 01C0              xjmp L111
 0364           L108:
 0364                   .dbline 109
 0364           ;             ;
 0364           L109:
 0364                   .dbline 108
 0364 4395              inc R20
 0366           L111:
 0366                   .dbline 108
 0366 4634              cpi R20,70
 0368 E8F3              brlo L108
 036A           X40:
 036A           L105:
 036A                   .dbline 107
 036A 0150              subi R16,1
 036C 1040              sbci R17,0
 036E           L107:
 036E                   .dbline 107
 036E 2224              clr R2
 0370 3324              clr R3
 0372 2016              cp R2,R16
 0374 3106              cpc R3,R17
 0376 A4F3              brlt L104
 0378           X41:
 0378                   .dbline -2
 0378           L103:
 0378                   .dbline 0 ; func end
 0378 4991              ld R20,y+
 037A 0895              ret
 037C                   .dbsym r j 20 c
 037C                   .dbsym r t 16 I
 037C                   .dbend
 037C                   .dbfunc e delay50ms _delay50ms fV
 037C           ;              i -> R20,R21
 037C           ;              t -> R16,R17
                        .even
 037C           _delay50ms::
 037C 4A93              st -y,R20
 037E 5A93              st -y,R21
 0380                   .dbline -1
 0380                   .dbline 120
 0380           ; }
 0380           ; /*--------------------------------------------------------------------
 0380           ; 函数全称：50ms 延时
 0380           ; 函数功能：当然是 50ms延时 啦
 0380           ; 注意事项：基于7.3728M晶振，稍微有点误差
 0380           ; 提示说明：调用delay50ms（20），得到1s延时 
 0380           ; 输    入：
 0380           ; 返    回：无
 0380           ; --------------------------------------------------------------------*/
 0380           ; void delay50ms(sint16 t)
 0380           ; {
 0380                   .dbline 122
 0380           ;       uint16 i; 
 0380           ;       for(;t>0;t--)
 0380 13C0              xjmp L116
 0382           L113:
 0382                   .dbline 123
 0382           ;               for(i=0;i<52642;i++)
 0382 4427              clr R20
 0384 5527              clr R21
 0386 02C0              xjmp L120
 0388           L117:
 0388                   .dbline 124
 0388           ;                       ; 
 0388           L118:
 0388                   .dbline 123
 0388 4F5F              subi R20,255  ; offset = 1
 038A 5F4F              sbci R21,255
 038C           L120:
 038C                   .dbline 123
 038C 82EA              ldi R24,162
 038E 9DEC              ldi R25,205
 0390 A0E0              ldi R26,0
 0392 B0E0              ldi R27,0
 0394 1A01              movw R2,R20
 0396 4424              clr R4
 0398 5524              clr R5
 039A 2816              cp R2,R24
 039C 3906              cpc R3,R25
 039E 4A06              cpc R4,R26
 03A0 5B06              cpc R5,R27
 03A2 94F3              brlt L117
 03A4           X42:
 03A4           L114:
 03A4                   .dbline 122
 03A4 0150              subi R16,1
 03A6 1040              sbci R17,0
 03A8           L116:
 03A8                   .dbline 122
 03A8 2224              clr R2
 03AA 3324              clr R3
 03AC 2016              cp R2,R16
 03AE 3106              cpc R3,R17
 03B0 44F3              brlt L113
 03B2           X43:
 03B2                   .dbline -2
 03B2           L112:
 03B2                   .dbline 0 ; func end
 03B2 5991              ld R21,y+
 03B4 4991              ld R20,y+
 03B6 0895              ret
 03B8                   .dbsym r i 20 i
 03B8                   .dbsym r t 16 I
 03B8                   .dbend
 03B8                   .dbfunc e delayus _delayus fV
 03B8           ;              i -> R20,R21
 03B8           ;              t -> R16,R17
                        .even
 03B8           _delayus::
 03B8 4A93              st -y,R20
 03BA 5A93              st -y,R21
 03BC                   .dbline -1
 03BC                   .dbline 129
 03BC           ; }
 03BC           ; 
 03BC           ; 
 03BC           ; void delayus(uint16 t)
 03BC           ; {
 03BC                   .dbline 131
 03BC           ;       uint16 i;
 03BC           ;       for(i=0;i<t;i++)
 03BC 4427              clr R20
 03BE 5527              clr R21
 03C0 02C0              xjmp L125
 03C2           L122:
 03C2                   .dbline 132
 03C2           ;               {
 03C2                   .dbline 135
 03C2           ;                       //asm("NOP\n");
 03C2           ;                       //asm("NOP\n");
 03C2           ;               }
 03C2           L123:
 03C2                   .dbline 131
 03C2 4F5F              subi R20,255  ; offset = 1
 03C4 5F4F              sbci R21,255
 03C6           L125:
 03C6                   .dbline 131
 03C6 4017              cp R20,R16
 03C8 5107              cpc R21,R17
 03CA D8F3              brlo L122
 03CC           X44:
 03CC                   .dbline -2
 03CC           L121:
 03CC                   .dbline 0 ; func end
 03CC 5991              ld R21,y+
 03CE 4991              ld R20,y+
 03D0 0895              ret
 03D2                   .dbsym r i 20 i
 03D2                   .dbsym r t 16 i
 03D2                   .dbend
 03D2                   .dbfile D:\DVK501_ICC\KERNEL~1\ATmega128\内核－WDT\WDT\WDT.C
 03D2                   .dbfunc e wdt_init _wdt_init fV
                        .even
 03D2           _wdt_init::
 03D2                   .dbline -1
 03D2                   .dbline 53
 03D2           ; /*********************************************************************
 03D2           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 03D2           ;                                                                       
 03D2           ; 目    的:   建立使用WDT的示例程序
 03D2           ;       
 03D2           ; 目标系统:   基于AVR单片机
 03D2           ;                                                                               
 03D2           ; 应用软件:   ICCAVR
 03D2           ;                                                                               
 03D2           ; 版    本:   Version 1.0                                                          
 03D2           ;                                                                               
 03D2           ; 圆版时间:   2005-06-25
 03D2           ;       
 03D2           ; 开发人员:   SEE
 03D2           ; 
 03D2           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 03D2           ;       
 03D2           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 03D2           ; *********************************************************************/
 03D2           ; 
 03D2           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 版本更新记录：
 03D2           ; 
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 实验内容：
 03D2           ; 观察喂狗与不喂狗的区别，使用PB口的LED指示灯做状态指示。
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 硬件连接：    
 03D2           ; 将PB口的LED指示灯使能开关切换到"ON"状态。
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 注意事项： 
 03D2           ; （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
 03D2           ; （2）请详细阅读“使用必读”及相关资料。
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 03D2           ; 
 03D2           ; #include <iom128v.h>
 03D2           ; #include "D:\ICC_H\CmmICC.H"
 03D2           ; 
 03D2           ; #define DISP_DDR      DDRB
 03D2           ; #define DISP_PORT     PORTB
 03D2           ; 
 03D2           ; /*--------------------------------------------------------------------
 03D2           ; 函数名称：
 03D2           ; 函数功能：
 03D2           ; 注意事项：
 03D2           ; 提示说明：
 03D2           ; 输    入：
 03D2           ; 返    回：
 03D2           ; --------------------------------------------------------------------*/
 03D2           ; void wdt_init(void)
 03D2           ; {
 03D2                   .dbline 54
 03D2           ;       asm("wdr");                     //clr wdt
 03D2 A895              wdr
 03D4                   .dbline 55
 03D4           ;       WDTCR=0x0F;                     //enable wdt,clk = 2048，2.1S
 03D4 8FE0              ldi R24,15
 03D6 81BD              out 0x21,R24
 03D8                   .dbline -2
 03D8           L126:
 03D8                   .dbline 0 ; func end
 03D8 0895              ret
 03DA                   .dbend
 03DA                   .dbfunc e main _main fV
 03DA           ;              i -> <dead>
                        .even
 03DA           _main::
 03DA                   .dbline -1
 03DA                   .dbline 66
 03DA           ; } 
 03DA           ; /*--------------------------------------------------------------------
 03DA           ; 函数名称：
 03DA           ; 函数功能：
 03DA           ; 注意事项：
 03DA           ; 提示说明：
 03DA           ; 输    入：
 03DA           ; 返    回：
 03DA           ; --------------------------------------------------------------------*/
 03DA           ; void main(void) 
 03DA           ; {
 03DA                   .dbline 69
 03DA           ;       uint8 i;
 03DA           ;       
 03DA           ;       DISP_DDR = 0XFF;
 03DA 8FEF              ldi R24,255
 03DC 87BB              out 0x17,R24
 03DE                   .dbline 70
 03DE           ;       wdt_init();
 03DE F9DF              xcall _wdt_init
 03E0 07C0              xjmp L129
 03E2           L128:
 03E2                   .dbline 73
 03E2           ; 
 03E2           ;       while(1)
 03E2           ;       {
 03E2                   .dbline 74
 03E2           ;               DISP_PORT++;
 03E2 88B3              in R24,0x18
 03E4 8F5F              subi R24,255    ; addi 1
 03E6 88BB              out 0x18,R24
 03E8                   .dbline 75
 03E8           ;               asm("wdr");        //喂狗，去除此句将导致MCU复位，从而数据不会向上加
 03E8 A895              wdr
 03EA                   .dbline 76
 03EA           ;               delay50ms(20);  
 03EA 04E1              ldi R16,20
 03EC 10E0              ldi R17,0
 03EE C6DF              xcall _delay50ms
 03F0                   .dbline 77
 03F0           ;       }                       
 03F0           L129:
 03F0                   .dbline 72
 03F0 F8CF              xjmp L128
 03F2           X45:
 03F2                   .dbline -2
 03F2           L127:
 03F2                   .dbline 0 ; func end
 03F2 0895              ret
 03F4                   .dbsym l i 1 c
 03F4                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile D:\DVK501_ICC\KERNEL~1\ATmega128\内核－WDT\WDT\WDT.C
 0000           _dataElem::
 0000                   .blkb 6
 0006                   .dbfile D:\ICC_H\Software.H
 0006                   .dbsym e dataElem _dataElem A[6:6]c
 0006           ; }
