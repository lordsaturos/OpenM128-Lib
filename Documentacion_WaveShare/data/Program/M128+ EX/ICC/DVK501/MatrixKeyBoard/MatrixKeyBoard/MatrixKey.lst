__text_start:
__start:
    004A EFCF      LDI	R28,0xFF
    004B E1D0      LDI	R29,0x10
    004C BFCD      OUT	0x3D,R28
    004D BFDE      OUT	0x3E,R29
    004E 51CE      SUBI	R28,0x1E
    004F 40D0      SBCI	R29,0
    0050 EA0A      LDI	R16,0xAA
    0051 8308      STD	Y+0,R16
    0052 2400      CLR	R0
    0053 E0E0      LDI	R30,0
    0054 E0F1      LDI	R31,1
    0055 E011      LDI	R17,1
    0056 30E6      CPI	R30,6
    0057 07F1      CPC	R31,R17
    0058 F011      BEQ	0x005B
    0059 9201      ST	R0,Z+
    005A CFFB      RJMP	0x0056
    005B 8300      STD	Z+0,R16
    005C E9E4      LDI	R30,0x94
    005D E0F0      LDI	R31,0
    005E E0A0      LDI	R26,0
    005F E0B1      LDI	R27,1
    0060 E010      LDI	R17,0
    0061 39E4      CPI	R30,0x94
    0062 07F1      CPC	R31,R17
    0063 F021      BEQ	0x0068
    0064 95C8      LPM
    0065 9631      ADIW	R30,1
    0066 920D      ST	R0,X+
    0067 CFF9      RJMP	0x0061
    0068 940E027C  CALL	_main
_exit:
    006A CFFF      RJMP	_exit
_speaData:
  y                    --> Y+4
  j                    --> Y+0
  i                    --> R10
  len                  --> R12
  dat                  --> Y+16
    006B 940E0288  CALL	push_arg4
    006D 940E0336  CALL	push_gset4
    006F 9728      SBIW	R28,0x8
    0070 88CC      LDD	R12,Y+20
FILE: D:\ICC_H\Software.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                       
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Software_H
(0041) #define Software_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) 
(0046) /* 兼容一般程序员的常用写法 */
(0047) typedef unsigned char	uchar;
(0048) typedef unsigned int	uint;
(0049) typedef unsigned long	ulong;
(0050) typedef signed char		schar;
(0051) typedef signed int		sint;
(0052) typedef signed long		slong;
(0053) 
(0054) /* 为方便移植，建议使用下面写法 */
(0055) typedef unsigned char	bool;
(0056) typedef unsigned char	uint8;
(0057) typedef unsigned int	uint16;
(0058) typedef unsigned long   uint32;
(0059) typedef signed  char	sint8;
(0060) typedef signed	int		sint16;
(0061) typedef signed	long	sint32;
(0062) typedef signed  char	int8;
(0063) typedef signed  int		int16;
(0064) typedef signed  long	int32;
(0065) 
(0066) /* 下面写法一般不推荐 */
(0067) //typedef unsigned char ubyte;
(0068) //typedef unsigned int	uword;
(0069) //typedef unsigned long udword;
(0070) //typedef signed   char	sbyte;
(0071) //typedef signed   int	sword;
(0072) //typedef signed   long	sdword;
(0073) 
(0074) /* 一般程序定义的默认值 */
(0075) //#define NULL			0
(0076) //#define EOF			-1
(0077) //#define TRUE   		1
(0078) //#define FALSE  		0
(0079) //#define YES   		1
(0080) //#define NO  			0
(0081) //#define ON			1
(0082) //#define OFF			0
(0083) //#define ENABLE   		1
(0084) //#define DISABLE		0
(0085) //#define CRR			1
(0086) //#define ERR			0
(0087) //#define RIGHT			1
(0088) //#define WRONG			0
(0089) //#define SUCCESS		1
(0090) //#define FAILURE		0
(0091) //#define PI			3.1415926	//3.1415926535897932
(0092) 
(0093) /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
(0094) //#define _CALLOC(a)		( (a *)calloc(n,sizeof(a)) )
(0095) //#define _MALLOC(a)		( (a *)malloc(sizeof(a)) )
(0096) //#define _MIN(a,b)			( (a) < (b) ? (a) : (b) )
(0097) //#define _MAX(a,b)			( (a) > (b) ? (a) : (b) )
(0098) //#define _EXCHANGE(a,b)	{ int t; t=a; a=b; b=t; }
(0099) //#define _TOLOWER(c)		( (c)+32 )
(0100) //#define _TOUPPER(c)		( (c)-32 )
(0101) 
(0102) //#ifndef BIT
(0103) //#define BIT(x)	( 1<<(x) )
(0104) //#endif
(0105) 
(0106) /*--------------------------------------------------------------------
(0107) 函数全称：数据拆字
(0108) 函数功能：
(0109) 注意事项：D<=999999,C<=6
(0110) 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
(0111) 输    入：
(0112) 返    回：无
(0113) --------------------------------------------------------------------*/
(0114) uint8 dataElem[6];
(0115) void speaData(uint32 dat,sint8 len)
(0116) {
(0117)     uint8 i;
(0118)     uint32 j,y;
(0119)     for(i=0,j=1;i<len;i++)
    0071 24AA      CLR	R10
    0072 E041      LDI	R20,1
    0073 E050      LDI	R21,0
    0074 E060      LDI	R22,0
    0075 E070      LDI	R23,0
    0076 01FE      MOVW	R30,R28
    0077 8340      STD	Z+0,R20
    0078 8351      STD	Z+1,R21
    0079 8362      STD	Z+2,R22
    007A 8373      STD	Z+3,R23
    007B C046      RJMP	0x00C2
(0120)     {
(0121)         y=dat/j;
    007C 01FE      MOVW	R30,R28
    007D 8020      LDD	R2,Z+0
    007E 8031      LDD	R3,Z+1
    007F 8042      LDD	R4,Z+2
    0080 8053      LDD	R5,Z+3
    0081 01FE      MOVW	R30,R28
    0082 8860      LDD	R6,Z+16
    0083 8871      LDD	R7,Z+17
    0084 8882      LDD	R8,Z+18
    0085 8893      LDD	R9,Z+19
    0086 925A      ST	R5,-Y
    0087 924A      ST	R4,-Y
    0088 923A      ST	R3,-Y
    0089 922A      ST	R2,-Y
    008A 0183      MOVW	R16,R6
    008B 0194      MOVW	R18,R8
    008C 940E028D  CALL	div32u
    008E 01FE      MOVW	R30,R28
    008F 8304      STD	Z+4,R16
    0090 8315      STD	Z+5,R17
    0091 8326      STD	Z+6,R18
    0092 8337      STD	Z+7,R19
(0122)         dataElem[i]=y%10;
    0093 E04A      LDI	R20,0xA
    0094 E050      LDI	R21,0
    0095 E060      LDI	R22,0
    0096 E070      LDI	R23,0
    0097 01FE      MOVW	R30,R28
    0098 8024      LDD	R2,Z+4
    0099 8035      LDD	R3,Z+5
    009A 8046      LDD	R4,Z+6
    009B 8057      LDD	R5,Z+7
    009C 937A      ST	R23,-Y
    009D 936A      ST	R22,-Y
    009E 935A      ST	R21,-Y
    009F 934A      ST	R20,-Y
    00A0 0181      MOVW	R16,R2
    00A1 0192      MOVW	R18,R4
    00A2 940E028F  CALL	mod32u
    00A4 E080      LDI	R24,0
    00A5 E091      LDI	R25,1
    00A6 2DEA      MOV	R30,R10
    00A7 27FF      CLR	R31
    00A8 0FE8      ADD	R30,R24
    00A9 1FF9      ADC	R31,R25
    00AA 8300      STD	Z+0,R16
(0123)         j*=10;
    00AB 01FE      MOVW	R30,R28
    00AC 8020      LDD	R2,Z+0
    00AD 8031      LDD	R3,Z+1
    00AE 8042      LDD	R4,Z+2
    00AF 8053      LDD	R5,Z+3
    00B0 E04A      LDI	R20,0xA
    00B1 E050      LDI	R21,0
    00B2 E060      LDI	R22,0
    00B3 E070      LDI	R23,0
    00B4 925A      ST	R5,-Y
    00B5 924A      ST	R4,-Y
    00B6 923A      ST	R3,-Y
    00B7 922A      ST	R2,-Y
    00B8 018A      MOVW	R16,R20
    00B9 019B      MOVW	R18,R22
    00BA 940E02FE  CALL	empy32u
    00BC 01FE      MOVW	R30,R28
    00BD 8300      STD	Z+0,R16
    00BE 8311      STD	Z+1,R17
    00BF 8322      STD	Z+2,R18
    00C0 8333      STD	Z+3,R19
    00C1 94A3      INC	R10
    00C2 14AC      CP	R10,R12
    00C3 F408      BCC	0x00C5
    00C4 CFB7      RJMP	0x007C
    00C5 9628      ADIW	R28,0x8
    00C6 940E0331  CALL	pop_gset4
    00C8 9624      ADIW	R28,4
    00C9 9508      RET
FILE: D:\ICC_H\I2C.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立I2C操作库
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033) 
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036) 
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef I2C_H
(0041) #define I2C_H
(0042) 
(0043) /* TWSR values (not bits) */
(0044) /* Master */
(0045) #define I2C_START			0x08
(0046) #define I2C_RESTART			0x10
(0047) 
(0048) /* Master Transmitter */
(0049) #define I2C_MT_SLA_ACK		0x18
(0050) #define I2C_MT_SLA_NACK		0x20
(0051) #define I2C_MT_DATA_ACK		0x28
(0052) #define I2C_MT_DATA_NACK	0x30
(0053) #define I2C_MT_ARB_LOST		0x38
(0054) 
(0055) /* Master Receiver */
(0056) #define I2C_MR_ARB_LOST		0x38
(0057) #define I2C_MR_SLA_ACK		0x40
(0058) #define I2C_MR_SLA_NACK		0x48
(0059) #define I2C_MR_DATA_ACK		0x50
(0060) #define I2C_MR_DATA_NACK	0x58
(0061) 
(0062) /* Slave Transmitter */
(0063) #define I2C_ST_SLA_ACK			0xA8
(0064) #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
(0065) #define I2C_ST_DATA_ACK			0xB8
(0066) #define I2C_ST_DATA_NACK		0xC0
(0067) #define I2C_ST_LAST_DATA		0xC8
(0068) 
(0069) /* Slave Receiver */
(0070) #define I2C_SR_SLA_ACK				0x60
(0071) #define I2C_SR_ARB_LOST_SLA_ACK		0x68
(0072) #define I2C_SR_GCALL_ACK			0x70
(0073) #define I2C_SR_ARB_LOST_GCALL_ACK	0x78
(0074) #define I2C_SR_DATA_ACK				0x80
(0075) #define I2C_SR_DATA_NACK			0x88
(0076) #define I2C_SR_GCALL_DATA_ACK		0x90
(0077) #define I2C_SR_GCALL_DATA_NACK		0x98
(0078) #define I2C_SR_STOP					0xA0
(0079) 
(0080) /* Misc */
(0081) #define I2C_NO_INFO			0xF8
(0082) #define I2C_BUS_ERROR		0x00
(0083) 
(0084) /*
(0085)  * The lower 3 bits of TWSR are reserved on the ATmega163.
(0086)  * The 2 LSB carry the prescaler bits on the newer ATmegas.
(0087)  */
(0088) #define I2C_STATUS_MASK	(_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
(0089) #define I2C_STATUS		(TWSR & I2C_STATUS_MASK)
(0090) 
(0091) /*
(0092)  * R/~W bit in SLA+R/W address field.
(0093)  */
(0094) #define I2C_READ		1
(0095) #define I2C_WRITE		0
(0096) 
(0097) #define I2CStart()    	(TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
(0098) #define I2CStop()     	(TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
(0099) #define I2CWaitAck()	{while(!(TWCR&(1<<TWINT)));}
(0100) #define I2CChkAck() 	(TWSR&0xf8)					//check ack
(0101) #define I2CSendAck()	(TWCR|=(1<<TWEA))
(0102) #define I2CSendNoAck()	(TWCR&=~(1<<TWEA))
(0103) #define I2CSendByte(x)	{TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
(0104) #define I2CRcvNckByte()	(TWCR=(1<<TWINT)|(1<<TWEN))
(0105) #define I2CRcvAckByte()	(TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
(0106) 
(0107) /* For Program */
(0108) #define I2C_Stop()		I2CStop()
(0109) #define I2C_SendAck()	I2CSendAck()
(0110) #define I2C_SendNoAck() I2CSendNoAck()
(0111) #define I2C_WaitAck()	I2CWaitAck()
(0112) 
(0113) /* I2C Config */
(0114) #define I2C_ERR			0
(0115) #define I2C_CRR			1
(0116) 
(0117) /*--------------------------------------------------------------------
(0118) 函数名称：I2C Start
(0119) 函数功能：
(0120) 注意事项：
(0121) 提示说明：
(0122) 输    入：
(0123) 返    回：
(0124) --------------------------------------------------------------------*/
(0125) bool I2C_Start()					
(0126) {
(0127) 	I2CStart();						
_I2C_Start:
    00CA EA84      LDI	R24,0xA4
    00CB 93800074  STS	0x74,R24
(0128) 	I2CWaitAck();
    00CD 90200074  LDS	R2,0x74
    00CF FE27      SBRS	R2,7
    00D0 CFFC      RJMP	0x00CD
(0129) 	if( I2CChkAck()!=I2C_START ) 
    00D1 91800071  LDS	R24,0x71
    00D3 7F88      ANDI	R24,0xF8
    00D4 3088      CPI	R24,0x8
    00D5 F011      BEQ	0x00D8
(0130) 		return I2C_ERR;
    00D6 2700      CLR	R16
    00D7 C001      RJMP	0x00D9
(0131) 	return I2C_CRR;
    00D8 E001      LDI	R16,1
    00D9 9508      RET
(0132) }
(0133) /*--------------------------------------------------------------------
(0134) 函数名称：I2C ReStart
(0135) 函数功能：
(0136) 注意事项：
(0137) 提示说明：
(0138) 输    入：
(0139) 返    回：
(0140) --------------------------------------------------------------------*/
(0141) bool I2C_Restart()					
(0142) {
(0143) 	I2CStart();						
_I2C_Restart:
    00DA EA84      LDI	R24,0xA4
    00DB 93800074  STS	0x74,R24
(0144) 	I2CWaitAck();
    00DD 90200074  LDS	R2,0x74
    00DF FE27      SBRS	R2,7
    00E0 CFFC      RJMP	0x00DD
(0145) 	if( I2CChkAck()!=I2C_RESTART ) 
    00E1 91800071  LDS	R24,0x71
    00E3 7F88      ANDI	R24,0xF8
    00E4 3180      CPI	R24,0x10
    00E5 F011      BEQ	0x00E8
(0146) 		return I2C_ERR;
    00E6 2700      CLR	R16
    00E7 C001      RJMP	0x00E9
(0147) 	return I2C_CRR;
    00E8 E001      LDI	R16,1
    00E9 9508      RET
(0148) }
(0149) /*--------------------------------------------------------------------
(0150) 函数名称：发送 7位 器件写地址: XXXX XXX0
(0151) 函数功能：
(0152) 注意事项：
(0153) 提示说明：
(0154) 输    入：
(0155) 返    回：
(0156) --------------------------------------------------------------------*/
(0157) bool I2C_SendWrDAdr(uint8 wrDAdr)	
(0158) {
(0159) 	I2CSendByte(wrDAdr);			//设置 器件写地址
_I2C_SendWrDAdr:
  wrDAdr               --> R16
    00EA 93000073  STS	0x73,R16
    00EC E884      LDI	R24,0x84
    00ED 93800074  STS	0x74,R24
(0160) 	I2CWaitAck();
    00EF 90200074  LDS	R2,0x74
    00F1 FE27      SBRS	R2,7
    00F2 CFFC      RJMP	0x00EF
(0161) 	if( I2CChkAck()!=I2C_MT_SLA_ACK )  
    00F3 91800071  LDS	R24,0x71
    00F5 7F88      ANDI	R24,0xF8
    00F6 3188      CPI	R24,0x18
    00F7 F011      BEQ	0x00FA
(0162) 		return I2C_ERR;
    00F8 2700      CLR	R16
    00F9 C001      RJMP	0x00FB
(0163) 	return I2C_CRR;		
    00FA E001      LDI	R16,1
    00FB 9508      RET
_I2C_SendWrDAdr_:
  wrDAdr               --> R20
    00FC 940E033C  CALL	push_gset1
    00FE 01A8      MOVW	R20,R16
(0164) }
(0165) /*--------------------------------------------------------------------
(0166) 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
(0167) 函数功能：
(0168) 注意事项：
(0169) 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
(0170) 输    入：
(0171) 返    回：
(0172) --------------------------------------------------------------------*/
(0173) bool I2C_SendWrDAdr_(uint16 wrDAdr)	
(0174) {
(0175) 	if( wrDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    00FF FF40      SBRS	R20,0
    0100 C00B      RJMP	0x010C
(0176) 		if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )	//设置 （高位）器件写地址
    0101 2F04      MOV	R16,R20
    0102 2711      CLR	R17
    0103 2F01      MOV	R16,R17
    0104 2711      CLR	R17
    0105 FD07      SBRC	R16,7
    0106 9510      COM	R17
    0107 DFE2      RCALL	_I2C_SendWrDAdr
    0108 2300      TST	R16
    0109 F411      BNE	0x010C
(0177) 			return I2C_ERR;
    010A 2700      CLR	R16
    010B C007      RJMP	0x0113
(0178) 	if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )	//设置 （低位）器件写地址
    010C 2F04      MOV	R16,R20
    010D DFDC      RCALL	_I2C_SendWrDAdr
    010E 2300      TST	R16
    010F F411      BNE	0x0112
(0179) 		return I2C_ERR;
    0110 2700      CLR	R16
    0111 C001      RJMP	0x0113
(0180) 	return I2C_CRR;
    0112 E001      LDI	R16,1
    0113 940E033F  CALL	pop_gset1
    0115 9508      RET
(0181) }
(0182) /*--------------------------------------------------------------------
(0183) 函数名称：发送 7位 器件读地址: XXXX XXX1
(0184) 函数功能：
(0185) 注意事项：
(0186) 提示说明：
(0187) 输    入：
(0188) 返    回：
(0189) --------------------------------------------------------------------*/
(0190) bool I2C_SendRdDAdr(uint8 rdDAdr)	
(0191) {
(0192) 	I2CSendByte(rdDAdr);			//设置 器件读地址
_I2C_SendRdDAdr:
  rdDAdr               --> R16
    0116 93000073  STS	0x73,R16
    0118 E884      LDI	R24,0x84
    0119 93800074  STS	0x74,R24
(0193) 	I2CWaitAck();
    011B 90200074  LDS	R2,0x74
    011D FE27      SBRS	R2,7
    011E CFFC      RJMP	0x011B
(0194) 	if( I2CChkAck()!=I2C_MR_SLA_ACK )  
    011F 91800071  LDS	R24,0x71
    0121 7F88      ANDI	R24,0xF8
    0122 3480      CPI	R24,0x40
    0123 F011      BEQ	0x0126
(0195) 		return I2C_ERR;
    0124 2700      CLR	R16
    0125 C001      RJMP	0x0127
(0196) 	return I2C_CRR;	
    0126 E001      LDI	R16,1
    0127 9508      RET
_I2C_SendRdDAdr_:
  rdDAdr               --> R20
    0128 940E033C  CALL	push_gset1
    012A 2F40      MOV	R20,R16
(0197) }
(0198) /*--------------------------------------------------------------------
(0199) 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
(0200) 函数功能：
(0201) 注意事项：
(0202) 提示说明：
(0203) 输    入：
(0204) 返    回：
(0205) --------------------------------------------------------------------*/
(0206) bool I2C_SendRdDAdr_(uint8 rdDAdr)	
(0207) {
(0208) 	if( rdDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    012B FF40      SBRS	R20,0
    012C C00B      RJMP	0x0138
(0209) 		if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )	//设置 （高位）器件读地址
    012D 2F04      MOV	R16,R20
    012E 2711      CLR	R17
    012F 2F01      MOV	R16,R17
    0130 2711      CLR	R17
    0131 FD07      SBRC	R16,7
    0132 9510      COM	R17
    0133 DFB6      RCALL	_I2C_SendWrDAdr
    0134 2300      TST	R16
    0135 F411      BNE	0x0138
(0210) 			return I2C_ERR;
    0136 2700      CLR	R16
    0137 C007      RJMP	0x013F
(0211) 	if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )	//设置 （低位）器件读地址
    0138 2F04      MOV	R16,R20
    0139 DFB0      RCALL	_I2C_SendWrDAdr
    013A 2300      TST	R16
    013B F411      BNE	0x013E
(0212) 		return I2C_ERR;
    013C 2700      CLR	R16
    013D C001      RJMP	0x013F
(0213) 	return I2C_CRR;
    013E E001      LDI	R16,1
    013F 940E033F  CALL	pop_gset1
    0141 9508      RET
(0214) }
(0215) /*--------------------------------------------------------------------
(0216) 函数名称：I2C发送数据
(0217) 函数功能：
(0218) 注意事项：
(0219) 提示说明：
(0220) 输    入：
(0221) 返    回：
(0222) --------------------------------------------------------------------*/
(0223) bool I2C_SendDat(uint8 configDat)	
(0224) {
(0225) 	I2CSendByte(configDat);			
_I2C_SendDat:
  configDat            --> R16
    0142 93000073  STS	0x73,R16
    0144 E884      LDI	R24,0x84
    0145 93800074  STS	0x74,R24
(0226) 	I2CWaitAck();
    0147 90200074  LDS	R2,0x74
    0149 FE27      SBRS	R2,7
    014A CFFC      RJMP	0x0147
(0227) 	if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
    014B 91800071  LDS	R24,0x71
    014D 7F88      ANDI	R24,0xF8
    014E 3288      CPI	R24,0x28
    014F F011      BEQ	0x0152
(0228) 		return I2C_ERR;
    0150 2700      CLR	R16
    0151 C001      RJMP	0x0153
(0229) 	return I2C_CRR;	
    0152 E001      LDI	R16,1
    0153 9508      RET
(0230) }
(0231) /*--------------------------------------------------------------------
(0232) 函数名称：I2C接收数据且不产生应答
(0233) 函数功能：
(0234) 注意事项：
(0235) 提示说明：
(0236) 输    入：
(0237) 返    回：
(0238) --------------------------------------------------------------------*/
(0239) bool I2C_RcvNAckDat(uint8 *pRdDat)	
(0240) {
(0241) 	I2CRcvNckByte();
_I2C_RcvNAckDat:
  pRdDat               --> R16
    0154 E884      LDI	R24,0x84
    0155 93800074  STS	0x74,R24
(0242) 	I2CWaitAck();
    0157 90200074  LDS	R2,0x74
    0159 FE27      SBRS	R2,7
    015A CFFC      RJMP	0x0157
(0243) 	if( I2CChkAck()!=I2C_MR_DATA_NACK )
    015B 91800071  LDS	R24,0x71
    015D 7F88      ANDI	R24,0xF8
    015E 3588      CPI	R24,0x58
    015F F011      BEQ	0x0162
(0244) 		return I2C_ERR;
    0160 2700      CLR	R16
    0161 C005      RJMP	0x0167
(0245) 	*pRdDat=TWDR;
    0162 90200073  LDS	R2,0x73
    0164 01F8      MOVW	R30,R16
    0165 8220      STD	Z+0,R2
(0246) 	return I2C_CRR;
    0166 E001      LDI	R16,1
    0167 9508      RET
(0247) }
(0248) /*--------------------------------------------------------------------
(0249) 函数名称：I2C接收数据且产生应答
(0250) 函数功能：
(0251) 注意事项：
(0252) 提示说明：
(0253) 输    入：
(0254) 返    回：
(0255) --------------------------------------------------------------------*/
(0256) bool I2C_RcvAckDat(uint8 *pRdDat)	
(0257) {
(0258) 	I2CRcvAckByte();					
_I2C_RcvAckDat:
  pRdDat               --> R16
    0168 EC84      LDI	R24,0xC4
    0169 93800074  STS	0x74,R24
(0259) 	I2CWaitAck();
    016B 90200074  LDS	R2,0x74
    016D FE27      SBRS	R2,7
    016E CFFC      RJMP	0x016B
(0260) 	if( I2CChkAck()!=I2C_MR_DATA_ACK )
    016F 91800071  LDS	R24,0x71
    0171 7F88      ANDI	R24,0xF8
    0172 3580      CPI	R24,0x50
    0173 F011      BEQ	0x0176
(0261) 		return I2C_ERR;
    0174 2700      CLR	R16
    0175 C005      RJMP	0x017B
(0262) 	*pRdDat=TWDR;
    0176 90200073  LDS	R2,0x73
    0178 01F8      MOVW	R30,R16
    0179 8220      STD	Z+0,R2
(0263) 	return I2C_CRR;
    017A E001      LDI	R16,1
    017B 9508      RET
_I2C_Write:
  dat                  --> Y+4
  wordAdr              --> R20
  wrDAdr               --> R22
    017C 940E033A  CALL	push_gset2
    017E 2F42      MOV	R20,R18
    017F 01B8      MOVW	R22,R16
(0264) }
(0265) /*--------------------------------------------------------------------
(0266) 函数名称：I2C写器件，写一个数据
(0267) 函数功能：
(0268) 注意事项：
(0269) 提示说明：
(0270) 输    入：wrDAdr: write device-address 写器件地址
(0271) 		 wordAdr: word address 字地址
(0272) 		 dat: data 数据
(0273) 返    回：
(0274) --------------------------------------------------------------------*/
(0275) bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
(0276) {
(0277) 	if( I2C_Start()==I2C_ERR )
    0180 DF49      RCALL	_I2C_Start
    0181 2300      TST	R16
    0182 F411      BNE	0x0185
(0278) 		return I2C_ERR;
    0183 2700      CLR	R16
    0184 C016      RJMP	0x019B
(0279) 
(0280) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    0185 018B      MOVW	R16,R22
    0186 DF75      RCALL	_I2C_SendWrDAdr_
    0187 2300      TST	R16
    0188 F411      BNE	0x018B
(0281) 		return I2C_ERR;
    0189 2700      CLR	R16
    018A C010      RJMP	0x019B
(0282) 
(0283) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    018B 2F04      MOV	R16,R20
    018C DFB5      RCALL	_I2C_SendDat
    018D 2300      TST	R16
    018E F411      BNE	0x0191
(0284) 		return I2C_ERR;
    018F 2700      CLR	R16
    0190 C00A      RJMP	0x019B
(0285) 
(0286) 	if( I2C_SendDat(dat)==I2C_ERR )
    0191 810C      LDD	R16,Y+4
    0192 DFAF      RCALL	_I2C_SendDat
    0193 2300      TST	R16
    0194 F411      BNE	0x0197
(0287) 		return I2C_ERR;
    0195 2700      CLR	R16
    0196 C004      RJMP	0x019B
(0288) 
(0289) 	I2C_Stop();
    0197 E984      LDI	R24,0x94
    0198 93800074  STS	0x74,R24
(0290) 
(0291) 	return I2C_CRR;
    019A E001      LDI	R16,1
    019B 940E032E  CALL	pop_gset2
    019D 9508      RET
_I2C_Read:
  pRdDat               --> Y+6
  rdDAdr               --> Y+4
  wordAdr              --> R20
  wrDAdr               --> R22
    019E 940E033A  CALL	push_gset2
    01A0 2F42      MOV	R20,R18
    01A1 01B8      MOVW	R22,R16
(0292) }
(0293) /*--------------------------------------------------------------------
(0294) 函数名称：I2C写器件，写N个数据
(0295) 函数功能：
(0296) 注意事项：
(0297) 提示说明：
(0298) 输    入：wrDAdr: write device-address 写器件地址
(0299) 		 wordAdr: word address 字地址
(0300) 		 *pWrDat: p->write data 写入数据指针
(0301) 		 num: number 写入数据个数
(0302) 返    回：
(0303) --------------------------------------------------------------------*/
(0304) //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
(0305) //				  uint8 *pWrDat,uint8 num)
(0306) //{
(0307) //
(0308) //} 
(0309) /*--------------------------------------------------------------------
(0310) 函数名称：I2C读器件，读一个数据
(0311) 函数功能：
(0312) 注意事项：
(0313) 提示说明：
(0314) 输    入：wrDAdr: write device-address 写器件地址
(0315) 		 wordAdr: word address 字地址
(0316) 		 rdDAdr: read device-address 读器件地址
(0317) 		 *pRdDat: p->read data 读取数据指针
(0318) 返    回：
(0319) --------------------------------------------------------------------*/
(0320) bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
(0321) 			  uint8 rdDAdr,uint8 *pRdDat)
(0322) {
(0323) 	if( I2C_Start()==I2C_ERR )
    01A2 DF27      RCALL	_I2C_Start
    01A3 2300      TST	R16
    01A4 F411      BNE	0x01A7
(0324) 		return I2C_ERR;
    01A5 2700      CLR	R16
    01A6 C022      RJMP	0x01C9
(0325) 
(0326) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    01A7 018B      MOVW	R16,R22
    01A8 DF53      RCALL	_I2C_SendWrDAdr_
    01A9 2300      TST	R16
    01AA F411      BNE	0x01AD
(0327) 		return I2C_ERR;
    01AB 2700      CLR	R16
    01AC C01C      RJMP	0x01C9
(0328) 
(0329) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    01AD 2F04      MOV	R16,R20
    01AE DF93      RCALL	_I2C_SendDat
    01AF 2300      TST	R16
    01B0 F411      BNE	0x01B3
(0330) 		return I2C_ERR;
    01B1 2700      CLR	R16
    01B2 C016      RJMP	0x01C9
(0331) 
(0332) 	if( I2C_Restart()==I2C_ERR )
    01B3 DF26      RCALL	_I2C_Restart
    01B4 2300      TST	R16
    01B5 F411      BNE	0x01B8
(0333) 		return I2C_ERR;
    01B6 2700      CLR	R16
    01B7 C011      RJMP	0x01C9
(0334) 
(0335) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    01B8 810C      LDD	R16,Y+4
    01B9 DF5C      RCALL	_I2C_SendRdDAdr
    01BA 2300      TST	R16
    01BB F411      BNE	0x01BE
(0336) 		return I2C_ERR;
    01BC 2700      CLR	R16
    01BD C00B      RJMP	0x01C9
(0337) 
(0338) 	if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
    01BE 810E      LDD	R16,Y+6
    01BF 811F      LDD	R17,Y+7
    01C0 DF93      RCALL	_I2C_RcvNAckDat
    01C1 2300      TST	R16
    01C2 F411      BNE	0x01C5
(0339) 		return I2C_ERR;
    01C3 2700      CLR	R16
    01C4 C004      RJMP	0x01C9
(0340) 
(0341) 	I2C_Stop();
    01C5 E984      LDI	R24,0x94
    01C6 93800074  STS	0x74,R24
(0342) 
(0343) 	return I2C_CRR;
    01C8 E001      LDI	R16,1
    01C9 940E032E  CALL	pop_gset2
    01CB 9508      RET
_I2C_Read_:
  i                    --> R20
  num                  --> R22
  pRdDat               --> R10
  rdDAdr               --> Y+8
  wordAdr              --> R20
  wrDAdr               --> R12
    01CC 940E0336  CALL	push_gset4
    01CE 2F42      MOV	R20,R18
    01CF 0168      MOVW	R12,R16
    01D0 84AA      LDD	R10,Y+10
    01D1 84BB      LDD	R11,Y+11
    01D2 856C      LDD	R22,Y+12
(0344) }
(0345) /*--------------------------------------------------------------------
(0346) 函数名称：I2C读器件，读N个数据
(0347) 函数功能：
(0348) 注意事项：
(0349) 提示说明：
(0350) 输    入：wrDAdr: write device-address 写器件地址
(0351) 		 wordAdr: word address 字地址
(0352) 		 rdDAdr: read device-address 读器件地址
(0353) 		 *pRdDat: p->read data 读取数据指针
(0354) 		 num: number 读取数据个数
(0355) 返    回：
(0356) --------------------------------------------------------------------*/
(0357) bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
(0358) 			   uint8 rdDAdr,uint8 *pRdDat,uint8 num)
(0359) {
(0360)  	uint8 i;
(0361) 	
(0362) 	if( I2C_Start()==I2C_ERR )
    01D3 DEF6      RCALL	_I2C_Start
    01D4 2300      TST	R16
    01D5 F411      BNE	0x01D8
(0363) 		return I2C_ERR;
    01D6 2700      CLR	R16
    01D7 C034      RJMP	0x020C
(0364) 
(0365) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    01D8 0186      MOVW	R16,R12
    01D9 DF22      RCALL	_I2C_SendWrDAdr_
    01DA 2300      TST	R16
    01DB F411      BNE	0x01DE
(0366) 		return I2C_ERR;
    01DC 2700      CLR	R16
    01DD C02E      RJMP	0x020C
(0367) 
(0368) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    01DE 2F04      MOV	R16,R20
    01DF DF62      RCALL	_I2C_SendDat
    01E0 2300      TST	R16
    01E1 F411      BNE	0x01E4
(0369) 		return I2C_ERR;
    01E2 2700      CLR	R16
    01E3 C028      RJMP	0x020C
(0370) 
(0371) 	if( I2C_Restart()==I2C_ERR )
    01E4 DEF5      RCALL	_I2C_Restart
    01E5 2300      TST	R16
    01E6 F411      BNE	0x01E9
(0372) 		return I2C_ERR;
    01E7 2700      CLR	R16
    01E8 C023      RJMP	0x020C
(0373) 
(0374) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    01E9 8508      LDD	R16,Y+8
    01EA DF2B      RCALL	_I2C_SendRdDAdr
    01EB 2300      TST	R16
    01EC F411      BNE	0x01EF
(0375) 		return I2C_ERR;
    01ED 2700      CLR	R16
    01EE C01D      RJMP	0x020C
(0376) 
(0377) 	for(i=0;i<num-1;i++)
    01EF 2744      CLR	R20
    01F0 C00A      RJMP	0x01FB
(0378) 		if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
    01F1 2F04      MOV	R16,R20
    01F2 2711      CLR	R17
    01F3 0D0A      ADD	R16,R10
    01F4 1D1B      ADC	R17,R11
    01F5 DF72      RCALL	_I2C_RcvAckDat
    01F6 2300      TST	R16
    01F7 F411      BNE	0x01FA
(0379) 			return I2C_ERR;
    01F8 2700      CLR	R16
    01F9 C012      RJMP	0x020C
    01FA 9543      INC	R20
    01FB 2F86      MOV	R24,R22
    01FC 5081      SUBI	R24,1
    01FD 1748      CP	R20,R24
    01FE F390      BCS	0x01F1
(0380) 	
(0381) 	if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
    01FF 2F04      MOV	R16,R20
    0200 2711      CLR	R17
    0201 0D0A      ADD	R16,R10
    0202 1D1B      ADC	R17,R11
    0203 DF50      RCALL	_I2C_RcvNAckDat
    0204 2300      TST	R16
    0205 F411      BNE	0x0208
(0382) 			return I2C_ERR;
    0206 2700      CLR	R16
    0207 C004      RJMP	0x020C
(0383) 
(0384) 	I2C_Stop();
    0208 E984      LDI	R24,0x94
    0209 93800074  STS	0x74,R24
(0385) 	
(0386) 	return I2C_CRR;
    020B E001      LDI	R16,1
    020C 940E0331  CALL	pop_gset4
    020E 9508      RET
_delay50us:
  j                    --> R20
  t                    --> R16
    020F 940E033C  CALL	push_gset1
FILE: D:\ICC_H\Hardware.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
(0005) 					
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Hardware_H
(0041) #define Hardware_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) #include <stdio.h>
(0046) #include <macros.h>
(0047) #include <eeprom.h>
(0048) //#include <wdt.h>
(0049) 
(0050) /* TWI configs */
(0051) //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
(0052) #if NO_INCLUDE_I2C_H
(0053) ;
(0054) #else
(0055) #include "D:\ICC_H\I2C.H"	//i2c即AVR的"twi"
(0056) #endif
(0057) 
(0058) /* hard configs */
(0059) #ifndef flash
(0060) 	#define flash	const
(0061) #endif
(0062) 
(0063) #ifndef code
(0064) 	#define code	const
(0065) #endif
(0066) 
(0067) #ifndef NOP
(0068) 	#define NOP()	asm("nop")
(0069) #endif
(0070) 
(0071) /* io configs */
(0072) #define sbi(io,bit)		(  io |=  (1<<bit) )	//example: sbi(PORTA,0);sbi(DDRA,0);
(0073) #define cbi(io,bit)		(  io &= ~(1<<bit) )	//example: cbi(PORTA,0);cbi(DDRA,0);
(0074) #define gbi(pin ,bit)	( pin &   (1<<bit) )	//example: gbi(PINA,0);
(0075) 
(0076) /* interrupt configs */
(0077) #define DIS_INT  asm("sei")
(0078) #define EN_INT   asm("cli")
(0079) 
(0080) /* wdt configs */
(0081) #define WDT()    asm("wdr")
(0082) 
(0083) /* bit operation */
(0084) //#ifndef BIT
(0085) //#define BIT(x)	( 1<<(x) )
(0086) //#endif
(0087) 
(0088) /* USART configs for 4 Mhz crystal */
(0089) //#define BAUD9600			25
(0090) //#define BAUD19000			12
(0091) //#define UART_TRAN_ON()	UCR |=  0x08
(0092) //#define UART_TRAN_OFF()	UCR &= ~0x08
(0093) //#define UART_RCV_ON()		UCR |=  0x10
(0094) //#define UART_RCV_OFF()	UCR &= ~0x10
(0095) 
(0096) /*--------------------------------------------------------------------
(0097) 函数全称：50us 延时
(0098) 函数功能：当然是 50us延时 啦
(0099) 注意事项：基于7.3728M晶振，稍微有点误差
(0100) 提示说明：调用delay50us（20），得到1ms延时
(0101) 输    入：	
(0102) 返    回：无 
(0103) --------------------------------------------------------------------*/
(0104) void delay50us(sint16 t)
(0105) {
(0106)     uint8 j;		
(0107)     for(;t>0;t--)			
    0211 C007      RJMP	0x0219
(0108)         for(j=0;j<70;j++)	
    0212 2744      CLR	R20
    0213 C001      RJMP	0x0215
    0214 9543      INC	R20
    0215 3446      CPI	R20,0x46
    0216 F3E8      BCS	0x0214
    0217 5001      SUBI	R16,1
    0218 4010      SBCI	R17,0
    0219 2422      CLR	R2
    021A 2433      CLR	R3
    021B 1620      CP	R2,R16
    021C 0631      CPC	R3,R17
    021D F3A4      BLT	0x0212
    021E 940E033F  CALL	pop_gset1
    0220 9508      RET
_delay50ms:
  i                    --> R20
  t                    --> R16
    0221 940E033C  CALL	push_gset1
(0109)             ;
(0110) }
(0111) /*--------------------------------------------------------------------
(0112) 函数全称：50ms 延时
(0113) 函数功能：当然是 50ms延时 啦
(0114) 注意事项：基于7.3728M晶振，稍微有点误差
(0115) 提示说明：调用delay50ms（20），得到1s延时 
(0116) 输    入：
(0117) 返    回：无
(0118) --------------------------------------------------------------------*/
(0119) void delay50ms(sint16 t)
(0120) {
(0121) 	uint16 i; 
(0122) 	for(;t>0;t--)
    0223 C00B      RJMP	0x022F
(0123) 		for(i=0;i<52642;i++)
    0224 2744      CLR	R20
    0225 2755      CLR	R21
    0226 C002      RJMP	0x0229
    0227 5F4F      SUBI	R20,0xFF
    0228 4F5F      SBCI	R21,0xFF
    0229 3A42      CPI	R20,0xA2
    022A ECED      LDI	R30,0xCD
    022B 075E      CPC	R21,R30
    022C F3D0      BCS	0x0227
    022D 5001      SUBI	R16,1
    022E 4010      SBCI	R17,0
    022F 2422      CLR	R2
    0230 2433      CLR	R3
    0231 1620      CP	R2,R16
    0232 0631      CPC	R3,R17
    0233 F384      BLT	0x0224
    0234 940E033F  CALL	pop_gset1
    0236 9508      RET
_delayus:
  i                    --> R20
  t                    --> R16
    0237 940E033C  CALL	push_gset1
(0124) 			; 
(0125) }
(0126) 
(0127) 
(0128) void delayus(uint16 t)
(0129) {
(0130) 	uint16 i;
(0131) 	for(i=0;i<=t;i++){asm("NOP\n");}
    0239 2744      CLR	R20
    023A 2755      CLR	R21
    023B C003      RJMP	0x023F
    023C 0000      NOP
    023D 5F4F      SUBI	R20,0xFF
    023E 4F5F      SBCI	R21,0xFF
    023F 1704      CP	R16,R20
    0240 0715      CPC	R17,R21
    0241 F7D0      BCC	0x023C
    0242 940E033F  CALL	pop_gset1
    0244 9508      RET
_GetKeyVal:
  keyVal               --> R12
  getSta               --> R10
  i                    --> R20
  j                    --> R22
    0245 940E0336  CALL	push_gset4
FILE: E:\吴泽程序备份\DVK500\stk128+\MATRIX~1\MatrixKeyBoard\MatrixKey.c
(0001) /*********************************************************************
(0002)     微 雪 电 子   WaveShare   http://www.waveShare.net  
(0003) 
(0004) 功能目的:   测试"MatrixKeyBoard"模块
(0005) 
(0006) 目标系统:   基于AVR单片机
(0007) 
(0008) 应用软件:   ICCAVR                                               
(0009) 
(0010) 版    本:   Version 1.0
(0011) 
(0012) 圆版时间:   2005-03-01
(0013) 
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源 
(0017) 
(0018)     深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 实验内容：
(0027) 循环扫描PA口接入的按键，并使用PB口的LED指示灯指示按键的码值。
(0028) ----------------------------------------------------------------------
(0029) 硬件连接：
(0030) 将PB口的LED指示灯使能开关切换到"ON"状态，使其指示按键的码值。
(0031) MatrixKeyBoard：K0----K7
(0032)                  |    |
(0033) SMK1632：       PA0--PA7
(0034) ----------------------------------------------------------------------
(0035) 注意事项： 
(0036) （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
(0037) （2）请详细阅读“使用必读”及相关资料。
(0038) ----------------------------------------------------------------------
(0039) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0040) 
(0041) #include <iom128v.H>
(0042) #include "D:\ICC_H\CmmICC.H"
(0043) 
(0044) #define LED_DDR     DDRB
(0045) #define LED_PORT    PORTB
(0046) #define KEY_DDR     DDRA
(0047) #define KEY_PORT    PORTA
(0048) #define KEY_PIN     PINA
(0049) 
(0050) /*--------------------------------------------------------------------
(0051) 函数名称：
(0052) 函数功能：
(0053) 注意事项：
(0054) 提示说明：
(0055) 输    入：
(0056) 返    回：
(0057) --------------------------------------------------------------------*/
(0058) /*
(0059)     K4-----K5-----K6-----K7
(0060)      |      |      |      |
(0061)     03H----02H----01H----00H －K0
(0062)     07H----06H----05H----04H －K1
(0063)     0BH----0AH----09H----08H －K2
(0064)     0FH----0EH----0DH----0CH －K3
(0065) */
(0066) const uint8 setSta_[4]={0xfe,0xfd,0xfb,0xf7};       
(0067) const uint8 getSta_[4]={0x70,0xb0,0xd0,0xe0};  
(0068) uint8 GetKeyVal()
(0069) {
(0070)     uint8 i,j,getSta,keyVal;
(0071)     
(0072)     for(i=0;i<4;i++)              
    0247 2744      CLR	R20
    0248 C02D      RJMP	0x0276
(0073)     {               			
(0074)         KEY_PORT = setSta_[i];
    0249 E88C      LDI	R24,0x8C
    024A E090      LDI	R25,0
    024B 2FE4      MOV	R30,R20
    024C 27FF      CLR	R31
    024D 0FE8      ADD	R30,R24
    024E 1FF9      ADC	R31,R25
    024F 91E4      LPM	R30,0(Z)
    0250 BBEB      OUT	0x1B,R30
(0075)         delay50us(1);       
    0251 E001      LDI	R16,1
    0252 E010      LDI	R17,0
    0253 DFBB      RCALL	_delay50us
(0076)         if(KEY_PIN!=setSta_[i])
    0254 E88C      LDI	R24,0x8C
    0255 E090      LDI	R25,0
    0256 2FE4      MOV	R30,R20
    0257 27FF      CLR	R31
    0258 0FE8      ADD	R30,R24
    0259 1FF9      ADC	R31,R25
    025A 91E4      LPM	R30,0(Z)
    025B B229      IN	R2,0x19
    025C 162E      CP	R2,R30
    025D F0B9      BEQ	0x0275
(0077)         {
(0078)             getSta=KEY_PIN&0xf0;
    025E B389      IN	R24,0x19
    025F 7F80      ANDI	R24,0xF0
    0260 2EA8      MOV	R10,R24
(0079)             for(j=0;j<4;j++)    
    0261 2766      CLR	R22
    0262 C010      RJMP	0x0273
(0080)                 if(getSta==getSta_[j])                                 
    0263 E980      LDI	R24,0x90
    0264 E090      LDI	R25,0
    0265 2FE6      MOV	R30,R22
    0266 27FF      CLR	R31
    0267 0FE8      ADD	R30,R24
    0268 1FF9      ADC	R31,R25
    0269 91E4      LPM	R30,0(Z)
    026A 16AE      CP	R10,R30
    026B F431      BNE	0x0272
(0081)             	{
(0082)                     keyVal=j+i*4;
    026C E084      LDI	R24,4
    026D 9F84      MUL	R24,R20
    026E 2EC6      MOV	R12,R22
    026F 0CC0      ADD	R12,R0
(0083)                     return keyVal;
    0270 2D0C      MOV	R16,R12
    0271 C007      RJMP	0x0279
    0272 9563      INC	R22
    0273 3064      CPI	R22,4
    0274 F370      BCS	0x0263
    0275 9543      INC	R20
    0276 3044      CPI	R20,4
    0277 F288      BCS	0x0249
(0084)             	}
(0085)         }
(0086)     }
(0087)     return 0xFF;
    0278 EF0F      LDI	R16,0xFF
    0279 940E0331  CALL	pop_gset4
    027B 9508      RET
(0088) }
(0089) /*--------------------------------------------------------------------
(0090) 函数名称：
(0091) 函数功能：
(0092) 注意事项：
(0093) 提示说明：
(0094) 输    入：
(0095) 返    回：
(0096) --------------------------------------------------------------------*/
(0097) void main()
(0098) {
(0099)     uint8 keyVal;
(0100)     LED_DDR = 0XFF;
_main:
  keyVal               --> R20
    027C EF8F      LDI	R24,0xFF
    027D BB87      OUT	0x17,R24
(0101)     KEY_DDR = 0X0F;     
    027E E08F      LDI	R24,0xF
    027F BB8A      OUT	0x1A,R24
    0280 C005      RJMP	0x0286
(0102)     while(1)
(0103)     {
(0104)         keyVal = GetKeyVal();
    0281 DFC3      RCALL	_GetKeyVal
    0282 2F40      MOV	R20,R16
(0105)         if( keyVal!=0xFF )  	
    0283 3F0F      CPI	R16,0xFF
    0284 F009      BEQ	0x0286
(0106)             LED_PORT = keyVal;
FILE: <library>
    0285 BB08      OUT	0x18,R16
    0286 CFFA      RJMP	0x0281
    0287 9508      RET
push_arg4:
    0288 933A      ST	R19,-Y
    0289 932A      ST	R18,-Y
push_arg2:
    028A 931A      ST	R17,-Y
    028B 930A      ST	R16,-Y
    028C 9508      RET
div32u:
    028D 94E8      BCLR	6
    028E C001      RJMP	0x0290
mod32u:
    028F 9468      BSET	6
    0290 D02F      RCALL	long_div_prolog
    0291 24CC      CLR	R12
    0292 C008      RJMP	0x029B
div32s:
    0293 94E8      BCLR	6
    0294 C001      RJMP	0x0296
mod32s:
    0295 9468      BSET	6
    0296 D029      RCALL	long_div_prolog
    0297 FD37      SBRC	R19,7
    0298 D053      RCALL	neg_R16_R19
    0299 FDB7      SBRC	R27,7
    029A D05A      RCALL	neg_R24_R27
    029B 2477      CLR	R7
    029C 2488      CLR	R8
    029D 2499      CLR	R9
    029E 24AA      CLR	R10
    029F 24BB      CLR	R11
    02A0 D041      RCALL	tst_R16_R19
    02A1 F0C1      BEQ	0x02BA
    02A2 D044      RCALL	tst_R24_R27
    02A3 F0B1      BEQ	0x02BA
    02A4 E2E8      LDI	R30,0x28
    02A5 0F00      LSL	R16
    02A6 1F11      ROL	R17
    02A7 1F22      ROL	R18
    02A8 1F33      ROL	R19
    02A9 1C77      ROL	R7
    02AA 1C88      ROL	R8
    02AB 1C99      ROL	R9
    02AC 1CAA      ROL	R10
    02AD 1CBB      ROL	R11
    02AE 1688      CP	R8,R24
    02AF 0699      CPC	R9,R25
    02B0 06AA      CPC	R10,R26
    02B1 06BB      CPC	R11,R27
    02B2 F028      BCS	0x02B8
    02B3 1A88      SUB	R8,R24
    02B4 0A99      SBC	R9,R25
    02B5 0AAA      SBC	R10,R26
    02B6 0ABB      SBC	R11,R27
    02B7 9503      INC	R16
    02B8 95EA      DEC	R30
    02B9 F759      BNE	0x02A5
    02BA F426      BRTC	0x02BF
    02BB 2D08      MOV	R16,R8
    02BC 2D19      MOV	R17,R9
    02BD 2D2A      MOV	R18,R10
    02BE 2D3B      MOV	R19,R11
    02BF C013      RJMP	long_div_epilog
long_div_prolog:
    02C0 927A      ST	R7,-Y
    02C1 928A      ST	R8,-Y
    02C2 929A      ST	R9,-Y
    02C3 92AA      ST	R10,-Y
    02C4 92BA      ST	R11,-Y
    02C5 92CA      ST	R12,-Y
    02C6 93EA      ST	R30,-Y
    02C7 938A      ST	R24,-Y
    02C8 939A      ST	R25,-Y
    02C9 93AA      ST	R26,-Y
    02CA 93BA      ST	R27,-Y
    02CB 858B      LDD	R24,Y+11
    02CC 859C      LDD	R25,Y+12
    02CD 85AD      LDD	R26,Y+13
    02CE 85BE      LDD	R27,Y+14
    02CF 2EC3      MOV	R12,R19
    02D0 F00E      BRTS	0x02D2
    02D1 26CB      EOR	R12,R27
    02D2 9508      RET
long_div_epilog:
    02D3 FCC7      SBRC	R12,7
    02D4 D017      RCALL	neg_R16_R19
    02D5 91B9      LD	R27,Y+
    02D6 91A9      LD	R26,Y+
    02D7 9199      LD	R25,Y+
    02D8 9189      LD	R24,Y+
    02D9 91E9      LD	R30,Y+
    02DA 90C9      LD	R12,Y+
    02DB 90B9      LD	R11,Y+
    02DC 90A9      LD	R10,Y+
    02DD 9099      LD	R9,Y+
    02DE 9089      LD	R8,Y+
    02DF 9079      LD	R7,Y+
    02E0 9624      ADIW	R28,4
    02E1 9508      RET
tst_R16_R19:
    02E2 2FE0      MOV	R30,R16
    02E3 2BE1      OR	R30,R17
    02E4 2BE2      OR	R30,R18
    02E5 2BE3      OR	R30,R19
    02E6 9508      RET
tst_R24_R27:
    02E7 2FE8      MOV	R30,R24
    02E8 2BE9      OR	R30,R25
    02E9 2BEA      OR	R30,R26
    02EA 2BEB      OR	R30,R27
    02EB 9508      RET
neg_R16_R19:
    02EC 9500      COM	R16
    02ED 9510      COM	R17
    02EE 9520      COM	R18
    02EF 9530      COM	R19
    02F0 5F0F      SUBI	R16,0xFF
    02F1 4F1F      SBCI	R17,0xFF
    02F2 4F2F      SBCI	R18,0xFF
    02F3 4F3F      SBCI	R19,0xFF
    02F4 9508      RET
neg_R24_R27:
    02F5 9580      COM	R24
    02F6 9590      COM	R25
    02F7 95A0      COM	R26
    02F8 95B0      COM	R27
    02F9 5F8F      SUBI	R24,0xFF
    02FA 4F9F      SBCI	R25,0xFF
    02FB 4FAF      SBCI	R26,0xFF
    02FC 4FBF      SBCI	R27,0xFF
    02FD 9508      RET
empy32u:
empy32s:
    02FE 940E0353  CALL	long_prolog
    0300 927F      PUSH	R7
    0301 940E036C  CALL	tstzero1
    0303 F139      BEQ	0x032B
    0304 2477      CLR	R7
    0305 940E0372  CALL	tstzero2
    0307 F419      BNE	0x030B
    0308 018C      MOVW	R16,R24
    0309 019D      MOVW	R18,R26
    030A C020      RJMP	0x032B
    030B 9F08      MUL	R16,R24
    030C 2CB0      MOV	R11,R0
    030D 2CA1      MOV	R10,R1
    030E 9F28      MUL	R18,R24
    030F 2C90      MOV	R9,R0
    0310 2C81      MOV	R8,R1
    0311 9F18      MUL	R17,R24
    0312 0CA0      ADD	R10,R0
    0313 1C91      ADC	R9,R1
    0314 1C87      ADC	R8,R7
    0315 9F09      MUL	R16,R25
    0316 0CA0      ADD	R10,R0
    0317 1C91      ADC	R9,R1
    0318 1C87      ADC	R8,R7
    0319 9F19      MUL	R17,R25
    031A 0C90      ADD	R9,R0
    031B 1C81      ADC	R8,R1
    031C 9F0A      MUL	R16,R26
    031D 0C90      ADD	R9,R0
    031E 1C81      ADC	R8,R1
    031F 9F38      MUL	R19,R24
    0320 0C80      ADD	R8,R0
    0321 9F29      MUL	R18,R25
    0322 0C80      ADD	R8,R0
    0323 9F1A      MUL	R17,R26
    0324 0C80      ADD	R8,R0
    0325 9F0B      MUL	R16,R27
    0326 0C80      ADD	R8,R0
    0327 2D0B      MOV	R16,R11
    0328 2D1A      MOV	R17,R10
    0329 2D29      MOV	R18,R9
    032A 2D38      MOV	R19,R8
    032B 907F      POP	R7
    032C 940C0361  JMP	long_epilog
pop_gset2:
    032E E0E2      LDI	R30,2
    032F 940C0340  JMP	pop
pop_gset4:
    0331 E0E8      LDI	R30,0x8
    0332 940C0340  JMP	pop
push_gset5:
    0334 92FA      ST	R15,-Y
    0335 92EA      ST	R14,-Y
push_gset4:
    0336 92DA      ST	R13,-Y
    0337 92CA      ST	R12,-Y
push_gset3:
    0338 92BA      ST	R11,-Y
    0339 92AA      ST	R10,-Y
push_gset2:
    033A 937A      ST	R23,-Y
    033B 936A      ST	R22,-Y
push_gset1:
    033C 935A      ST	R21,-Y
    033D 934A      ST	R20,-Y
    033E 9508      RET
pop_gset1:
    033F E0E1      LDI	R30,1
pop:
    0340 9149      LD	R20,Y+
    0341 9159      LD	R21,Y+
    0342 FDE0      SBRC	R30,0
    0343 9508      RET
    0344 9169      LD	R22,Y+
    0345 9179      LD	R23,Y+
    0346 FDE1      SBRC	R30,1
    0347 9508      RET
    0348 90A9      LD	R10,Y+
    0349 90B9      LD	R11,Y+
    034A FDE2      SBRC	R30,2
    034B 9508      RET
    034C 90C9      LD	R12,Y+
    034D 90D9      LD	R13,Y+
    034E FDE3      SBRC	R30,3
    034F 9508      RET
    0350 90E9      LD	R14,Y+
    0351 90F9      LD	R15,Y+
    0352 9508      RET
long_prolog:
    0353 928A      ST	R8,-Y
    0354 929A      ST	R9,-Y
    0355 92AA      ST	R10,-Y
    0356 92BA      ST	R11,-Y
    0357 93EA      ST	R30,-Y
    0358 938A      ST	R24,-Y
    0359 939A      ST	R25,-Y
    035A 93AA      ST	R26,-Y
    035B 93BA      ST	R27,-Y
    035C 8589      LDD	R24,Y+9
    035D 859A      LDD	R25,Y+10
    035E 85AB      LDD	R26,Y+11
    035F 85BC      LDD	R27,Y+12
    0360 9508      RET
long_epilog:
    0361 91B9      LD	R27,Y+
    0362 91A9      LD	R26,Y+
    0363 9199      LD	R25,Y+
    0364 9189      LD	R24,Y+
    0365 91E9      LD	R30,Y+
    0366 90B9      LD	R11,Y+
    0367 90A9      LD	R10,Y+
    0368 9099      LD	R9,Y+
    0369 9089      LD	R8,Y+
    036A 9624      ADIW	R28,4
    036B 9508      RET
tstzero1:
    036C 27EE      CLR	R30
    036D 2BE0      OR	R30,R16
    036E 2BE1      OR	R30,R17
    036F 2BE2      OR	R30,R18
    0370 2BE3      OR	R30,R19
    0371 9508      RET
tstzero2:
    0372 27EE      CLR	R30
    0373 2BE8      OR	R30,R24
    0374 2BE9      OR	R30,R25
    0375 2BEA      OR	R30,R26
    0376 2BEB      OR	R30,R27
    0377 9508      RET
