                        .module PCF8563.C
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\..\M128_E~1\PCF856~1\PCF8563_LCD12864\PCF8563.C
 0000                   .dbfile D:\ICC_H\Software.H
 0000                   .dbfunc e speaData _speaData fV
 0000           ;              y -> y+4
 0000           ;              j -> y+0
 0000           ;              i -> R10
 0000           ;            len -> R12
 0000           ;            dat -> y+16
                        .even
 0000           _speaData::
 0000 0E940000          xcall push_arg4
 0004 0E940000          xcall push_xgsetF03C
 0008 2897              sbiw R28,8
 000A CC88              ldd R12,y+20
 000C                   .dbline -1
 000C                   .dbline 116
 000C           ; /*********************************************************************
 000C           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 000C           ;                                                                       
 000C           ; 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
 000C           ;       
 000C           ; 目标系统:   基于AVR单片机
 000C           ;                                                                               
 000C           ; 应用软件:   ICCAVR
 000C           ;                                                                               
 000C           ; 版    本:   Version 1.0                                                       
 000C           ;                                                                               
 000C           ; 圆版时间:   2005-06-25
 000C           ;       
 000C           ; 开发人员:   SEE
 000C           ; 
 000C           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 000C           ;       
 000C           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 000C           ; *********************************************************************/
 000C           ; 
 000C           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 000C           ; ----------------------------------------------------------------------
 000C           ; 版本更新记录：
 000C           ; 
 000C           ; ----------------------------------------------------------------------
 000C           ; 入口参数说明：
 000C           ; 
 000C           ; ----------------------------------------------------------------------
 000C           ; 待定参数说明：
 000C           ; 
 000C           ; ----------------------------------------------------------------------        
 000C           ; 对外变量说明：
 000C           ;     
 000C           ; ----------------------------------------------------------------------
 000C           ; 对外函数说明：
 000C           ;    
 000C           ; ----------------------------------------------------------------------
 000C           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 000C           ; 
 000C           ; #ifndef Software_H
 000C           ; #define Software_H
 000C           ; 
 000C           ; #include <math.h>
 000C           ; #include <string.h>
 000C           ; 
 000C           ; /* 兼容一般程序员的常用写法 */
 000C           ; typedef unsigned char uchar;
 000C           ; typedef unsigned int  uint;
 000C           ; typedef unsigned long ulong;
 000C           ; typedef signed char           schar;
 000C           ; typedef signed int            sint;
 000C           ; typedef signed long           slong;
 000C           ; 
 000C           ; /* 为方便移植，建议使用下面写法 */
 000C           ; typedef unsigned char bool;
 000C           ; typedef unsigned char uint8;
 000C           ; typedef unsigned int  uint16;
 000C           ; typedef unsigned long   uint32;
 000C           ; typedef signed  char  sint8;
 000C           ; typedef signed        int             sint16;
 000C           ; typedef signed        long    sint32;
 000C           ; typedef signed  char  int8;
 000C           ; typedef signed  int           int16;
 000C           ; typedef signed  long  int32;
 000C           ; 
 000C           ; /* 下面写法一般不推荐 */
 000C           ; //typedef unsigned char ubyte;
 000C           ; //typedef unsigned int        uword;
 000C           ; //typedef unsigned long udword;
 000C           ; //typedef signed   char       sbyte;
 000C           ; //typedef signed   int        sword;
 000C           ; //typedef signed   long       sdword;
 000C           ; 
 000C           ; /* 一般程序定义的默认值 */
 000C           ; //#define NULL                        0
 000C           ; //#define EOF                 -1
 000C           ; //#define TRUE                1
 000C           ; //#define FALSE               0
 000C           ; //#define YES                 1
 000C           ; //#define NO                          0
 000C           ; //#define ON                  1
 000C           ; //#define OFF                 0
 000C           ; //#define ENABLE              1
 000C           ; //#define DISABLE             0
 000C           ; //#define CRR                 1
 000C           ; //#define ERR                 0
 000C           ; //#define RIGHT                       1
 000C           ; //#define WRONG                       0
 000C           ; //#define SUCCESS             1
 000C           ; //#define FAILURE             0
 000C           ; //#define PI                  3.1415926       //3.1415926535897932
 000C           ; 
 000C           ; /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
 000C           ; //#define _CALLOC(a)          ( (a *)calloc(n,sizeof(a)) )
 000C           ; //#define _MALLOC(a)          ( (a *)malloc(sizeof(a)) )
 000C           ; //#define _MIN(a,b)                   ( (a) < (b) ? (a) : (b) )
 000C           ; //#define _MAX(a,b)                   ( (a) > (b) ? (a) : (b) )
 000C           ; //#define _EXCHANGE(a,b)      { int t; t=a; a=b; b=t; }
 000C           ; //#define _TOLOWER(c)         ( (c)+32 )
 000C           ; //#define _TOUPPER(c)         ( (c)-32 )
 000C           ; 
 000C           ; //#ifndef BIT
 000C           ; //#define BIT(x)      ( 1<<(x) )
 000C           ; //#endif
 000C           ; 
 000C           ; /*--------------------------------------------------------------------
 000C           ; 函数全称：数据拆字
 000C           ; 函数功能：
 000C           ; 注意事项：D<=999999,C<=6
 000C           ; 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
 000C           ; 输    入：
 000C           ; 返    回：无
 000C           ; --------------------------------------------------------------------*/
 000C           ; uint8 dataElem[6];
 000C           ; void speaData(uint32 dat,sint8 len)
 000C           ; {
 000C                   .dbline 119
 000C           ;     uint8 i;
 000C           ;     uint32 j,y;
 000C           ;     for(i=0,j=1;i<len;i++)
 000C AA24              clr R10
 000E 81E0              ldi R24,1
 0010 8883              std y+0,R24
 0012 80E0              ldi R24,0
 0014 8983              std y+1,R24
 0016 8A83              std y+2,R24
 0018 8B83              std y+3,R24
 001A 3CC0              xjmp L5
 001C           L2:
 001C                   .dbline 120
 001C           ;     {
 001C                   .dbline 121
 001C           ;         y=dat/j;
 001C 2880              ldd R2,y+0
 001E 3980              ldd R3,y+1
 0020 4A80              ldd R4,y+2
 0022 5B80              ldd R5,y+3
 0024 0889              ldd R16,y+16
 0026 1989              ldd R17,y+17
 0028 2A89              ldd R18,y+18
 002A 3B89              ldd R19,y+19
 002C 5A92              st -y,R5
 002E 4A92              st -y,R4
 0030 3A92              st -y,R3
 0032 2A92              st -y,R2
 0034 0E940000          xcall div32u
 0038 0C83              std y+4,R16
 003A 1D83              std y+5,R17
 003C 2E83              std y+6,R18
 003E 3F83              std y+7,R19
 0040                   .dbline 122
 0040           ;         dataElem[i]=y%10;
 0040 4AE0              ldi R20,10
 0042 50E0              ldi R21,0
 0044 60E0              ldi R22,0
 0046 70E0              ldi R23,0
 0048 0C81              ldd R16,y+4
 004A 1D81              ldd R17,y+5
 004C 2E81              ldd R18,y+6
 004E 3F81              ldd R19,y+7
 0050 7A93              st -y,R23
 0052 6A93              st -y,R22
 0054 5A93              st -y,R21
 0056 4A93              st -y,R20
 0058 0E940000          xcall mod32u
 005C 80E0              ldi R24,<_dataElem
 005E 90E0              ldi R25,>_dataElem
 0060 EA2D              mov R30,R10
 0062 FF27              clr R31
 0064 E80F              add R30,R24
 0066 F91F              adc R31,R25
 0068 0083              std z+0,R16
 006A                   .dbline 123
 006A           ;         j*=10;
 006A 2880              ldd R2,y+0
 006C 3980              ldd R3,y+1
 006E 4A80              ldd R4,y+2
 0070 5B80              ldd R5,y+3
 0072 4AE0              ldi R20,10
 0074 50E0              ldi R21,0
 0076 60E0              ldi R22,0
 0078 70E0              ldi R23,0
 007A 5A92              st -y,R5
 007C 4A92              st -y,R4
 007E 3A92              st -y,R3
 0080 2A92              st -y,R2
 0082 8A01              movw R16,R20
 0084 9B01              movw R18,R22
 0086 0E940000          xcall empy32u
 008A 0883              std y+0,R16
 008C 1983              std y+1,R17
 008E 2A83              std y+2,R18
 0090 3B83              std y+3,R19
 0092                   .dbline 124
 0092           ;     }
 0092           L3:
 0092                   .dbline 119
 0092 A394              inc R10
 0094           L5:
 0094                   .dbline 119
 0094 2C2C              mov R2,R12
 0096 3324              clr R3
 0098 27FC              sbrc R2,7
 009A 3094              com R3
 009C 4A2C              mov R4,R10
 009E 5524              clr R5
 00A0 4214              cp R4,R2
 00A2 5304              cpc R5,R3
 00A4 0CF4              brge X1
 00A6 BACF              xjmp L2
 00A8           X1:
 00A8           X0:
 00A8                   .dbline -2
 00A8           L1:
 00A8                   .dbline 0 ; func end
 00A8 2896              adiw R28,8
 00AA 0E940000          xcall pop_xgsetF03C
 00AE 2496              adiw R28,4
 00B0 0895              ret
 00B2                   .dbsym l y 4 l
 00B2                   .dbsym l j 0 l
 00B2                   .dbsym r i 10 c
 00B2                   .dbsym r len 12 C
 00B2                   .dbsym l dat 16 l
 00B2                   .dbend
 00B2                   .dbfile D:\ICC_H\I2C.H
 00B2                   .dbfunc e I2C_Start _I2C_Start fc
                        .even
 00B2           _I2C_Start::
 00B2                   .dbline -1
 00B2                   .dbline 126
 00B2           ; /*********************************************************************
 00B2           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 00B2           ;                                                                       
 00B2           ; 目    的:   建立I2C操作库
 00B2           ;       
 00B2           ; 目标系统:   基于AVR单片机
 00B2           ;                                                                               
 00B2           ; 应用软件:   ICCAVR
 00B2           ;                                                                               
 00B2           ; 版    本:   Version 1.0                                                          
 00B2           ;                                                                               
 00B2           ; 圆版时间:   2005-06-25
 00B2           ;       
 00B2           ; 开发人员:   SEE
 00B2           ; 
 00B2           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 00B2           ;       
 00B2           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 00B2           ; *********************************************************************/
 00B2           ; 
 00B2           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 版本更新记录：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 入口参数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 待定参数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------        
 00B2           ; 对外变量说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 对外函数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 00B2           ; 
 00B2           ; #ifndef I2C_H
 00B2           ; #define I2C_H
 00B2           ; 
 00B2           ; /* TWSR values (not bits) */
 00B2           ; /* Master */
 00B2           ; #define I2C_START                     0x08
 00B2           ; #define I2C_RESTART                   0x10
 00B2           ; 
 00B2           ; /* Master Transmitter */
 00B2           ; #define I2C_MT_SLA_ACK                0x18
 00B2           ; #define I2C_MT_SLA_NACK               0x20
 00B2           ; #define I2C_MT_DATA_ACK               0x28
 00B2           ; #define I2C_MT_DATA_NACK      0x30
 00B2           ; #define I2C_MT_ARB_LOST               0x38
 00B2           ; 
 00B2           ; /* Master Receiver */
 00B2           ; #define I2C_MR_ARB_LOST               0x38
 00B2           ; #define I2C_MR_SLA_ACK                0x40
 00B2           ; #define I2C_MR_SLA_NACK               0x48
 00B2           ; #define I2C_MR_DATA_ACK               0x50
 00B2           ; #define I2C_MR_DATA_NACK      0x58
 00B2           ; 
 00B2           ; /* Slave Transmitter */
 00B2           ; #define I2C_ST_SLA_ACK                        0xA8
 00B2           ; #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
 00B2           ; #define I2C_ST_DATA_ACK                       0xB8
 00B2           ; #define I2C_ST_DATA_NACK              0xC0
 00B2           ; #define I2C_ST_LAST_DATA              0xC8
 00B2           ; 
 00B2           ; /* Slave Receiver */
 00B2           ; #define I2C_SR_SLA_ACK                                0x60
 00B2           ; #define I2C_SR_ARB_LOST_SLA_ACK               0x68
 00B2           ; #define I2C_SR_GCALL_ACK                      0x70
 00B2           ; #define I2C_SR_ARB_LOST_GCALL_ACK     0x78
 00B2           ; #define I2C_SR_DATA_ACK                               0x80
 00B2           ; #define I2C_SR_DATA_NACK                      0x88
 00B2           ; #define I2C_SR_GCALL_DATA_ACK         0x90
 00B2           ; #define I2C_SR_GCALL_DATA_NACK                0x98
 00B2           ; #define I2C_SR_STOP                                   0xA0
 00B2           ; 
 00B2           ; /* Misc */
 00B2           ; #define I2C_NO_INFO                   0xF8
 00B2           ; #define I2C_BUS_ERROR         0x00
 00B2           ; 
 00B2           ; /*
 00B2           ;  * The lower 3 bits of TWSR are reserved on the ATmega163.
 00B2           ;  * The 2 LSB carry the prescaler bits on the newer ATmegas.
 00B2           ;  */
 00B2           ; #define I2C_STATUS_MASK       (_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
 00B2           ; #define I2C_STATUS            (TWSR & I2C_STATUS_MASK)
 00B2           ; 
 00B2           ; /*
 00B2           ;  * R/~W bit in SLA+R/W address field.
 00B2           ;  */
 00B2           ; #define I2C_READ              1
 00B2           ; #define I2C_WRITE             0
 00B2           ; 
 00B2           ; #define I2CStart()            (TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
 00B2           ; #define I2CStop()             (TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
 00B2           ; #define I2CWaitAck()  {while(!(TWCR&(1<<TWINT)));}
 00B2           ; #define I2CChkAck()   (TWSR&0xf8)                                     //check ack
 00B2           ; #define I2CSendAck()  (TWCR|=(1<<TWEA))
 00B2           ; #define I2CSendNoAck()        (TWCR&=~(1<<TWEA))
 00B2           ; #define I2CSendByte(x)        {TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
 00B2           ; #define I2CRcvNckByte()       (TWCR=(1<<TWINT)|(1<<TWEN))
 00B2           ; #define I2CRcvAckByte()       (TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
 00B2           ; 
 00B2           ; /* For Program */
 00B2           ; #define I2C_Stop()            I2CStop()
 00B2           ; #define I2C_SendAck() I2CSendAck()
 00B2           ; #define I2C_SendNoAck() I2CSendNoAck()
 00B2           ; #define I2C_WaitAck() I2CWaitAck()
 00B2           ; 
 00B2           ; /* I2C Config */
 00B2           ; #define I2C_ERR                       0
 00B2           ; #define I2C_CRR                       1
 00B2           ; 
 00B2           ; /*--------------------------------------------------------------------
 00B2           ; 函数名称：I2C Start
 00B2           ; 函数功能：
 00B2           ; 注意事项：
 00B2           ; 提示说明：
 00B2           ; 输    入：
 00B2           ; 返    回：
 00B2           ; --------------------------------------------------------------------*/
 00B2           ; bool I2C_Start()                                      
 00B2           ; {
 00B2                   .dbline 127
 00B2           ;       I2CStart();                                             
 00B2 84EA              ldi R24,164
 00B4 80937400          sts 116,R24
 00B8                   .dbline 128
 00B8           ;       I2CWaitAck();
 00B8           L7:
 00B8                   .dbline 128
 00B8           L8:
 00B8                   .dbline 128
 00B8 20907400          lds R2,116
 00BC 27FE              sbrs R2,7
 00BE FCCF              rjmp L7
 00C0           X2:
 00C0                   .dbline 128
 00C0                   .dbline 128
 00C0                   .dbline 129
 00C0           ;       if( I2CChkAck()!=I2C_START ) 
 00C0 80917100          lds R24,113
 00C4 887F              andi R24,248
 00C6 8830              cpi R24,8
 00C8 11F0              breq L10
 00CA           X3:
 00CA                   .dbline 130
 00CA           ;               return I2C_ERR;
 00CA 0027              clr R16
 00CC 01C0              xjmp L6
 00CE           L10:
 00CE                   .dbline 131
 00CE           ;       return I2C_CRR;
 00CE 01E0              ldi R16,1
 00D0                   .dbline -2
 00D0           L6:
 00D0                   .dbline 0 ; func end
 00D0 0895              ret
 00D2                   .dbend
 00D2                   .dbfunc e I2C_Restart _I2C_Restart fc
                        .even
 00D2           _I2C_Restart::
 00D2                   .dbline -1
 00D2                   .dbline 142
 00D2           ; }
 00D2           ; /*--------------------------------------------------------------------
 00D2           ; 函数名称：I2C ReStart
 00D2           ; 函数功能：
 00D2           ; 注意事项：
 00D2           ; 提示说明：
 00D2           ; 输    入：
 00D2           ; 返    回：
 00D2           ; --------------------------------------------------------------------*/
 00D2           ; bool I2C_Restart()                                    
 00D2           ; {
 00D2                   .dbline 143
 00D2           ;       I2CStart();                                             
 00D2 84EA              ldi R24,164
 00D4 80937400          sts 116,R24
 00D8                   .dbline 144
 00D8           ;       I2CWaitAck();
 00D8           L13:
 00D8                   .dbline 144
 00D8           L14:
 00D8                   .dbline 144
 00D8 20907400          lds R2,116
 00DC 27FE              sbrs R2,7
 00DE FCCF              rjmp L13
 00E0           X4:
 00E0                   .dbline 144
 00E0                   .dbline 144
 00E0                   .dbline 145
 00E0           ;       if( I2CChkAck()!=I2C_RESTART ) 
 00E0 80917100          lds R24,113
 00E4 887F              andi R24,248
 00E6 8031              cpi R24,16
 00E8 11F0              breq L16
 00EA           X5:
 00EA                   .dbline 146
 00EA           ;               return I2C_ERR;
 00EA 0027              clr R16
 00EC 01C0              xjmp L12
 00EE           L16:
 00EE                   .dbline 147
 00EE           ;       return I2C_CRR;
 00EE 01E0              ldi R16,1
 00F0                   .dbline -2
 00F0           L12:
 00F0                   .dbline 0 ; func end
 00F0 0895              ret
 00F2                   .dbend
 00F2                   .dbfunc e I2C_SendWrDAdr _I2C_SendWrDAdr fc
 00F2           ;         wrDAdr -> R16
                        .even
 00F2           _I2C_SendWrDAdr::
 00F2                   .dbline -1
 00F2                   .dbline 158
 00F2           ; }
 00F2           ; /*--------------------------------------------------------------------
 00F2           ; 函数名称：发送 7位 器件写地址: XXXX XXX0
 00F2           ; 函数功能：
 00F2           ; 注意事项：
 00F2           ; 提示说明：
 00F2           ; 输    入：
 00F2           ; 返    回：
 00F2           ; --------------------------------------------------------------------*/
 00F2           ; bool I2C_SendWrDAdr(uint8 wrDAdr)     
 00F2           ; {
 00F2                   .dbline 159
 00F2           ;       I2CSendByte(wrDAdr);                    //设置 器件写地址
 00F2                   .dbline 159
 00F2 00937300          sts 115,R16
 00F6                   .dbline 159
 00F6 84E8              ldi R24,132
 00F8 80937400          sts 116,R24
 00FC                   .dbline 159
 00FC                   .dbline 159
 00FC                   .dbline 160
 00FC           ;       I2CWaitAck();
 00FC           L19:
 00FC                   .dbline 160
 00FC           L20:
 00FC                   .dbline 160
 00FC 20907400          lds R2,116
 0100 27FE              sbrs R2,7
 0102 FCCF              rjmp L19
 0104           X6:
 0104                   .dbline 160
 0104                   .dbline 160
 0104                   .dbline 161
 0104           ;       if( I2CChkAck()!=I2C_MT_SLA_ACK )  
 0104 80917100          lds R24,113
 0108 887F              andi R24,248
 010A 8831              cpi R24,24
 010C 11F0              breq L22
 010E           X7:
 010E                   .dbline 162
 010E           ;               return I2C_ERR;
 010E 0027              clr R16
 0110 01C0              xjmp L18
 0112           L22:
 0112                   .dbline 163
 0112           ;       return I2C_CRR;         
 0112 01E0              ldi R16,1
 0114                   .dbline -2
 0114           L18:
 0114                   .dbline 0 ; func end
 0114 0895              ret
 0116                   .dbsym r wrDAdr 16 c
 0116                   .dbend
 0116                   .dbfunc e I2C_SendWrDAdr_ _I2C_SendWrDAdr_ fc
 0116           ;         wrDAdr -> R10,R11
                        .even
 0116           _I2C_SendWrDAdr_::
 0116 AA92              st -y,R10
 0118 BA92              st -y,R11
 011A 5801              movw R10,R16
 011C                   .dbline -1
 011C                   .dbline 174
 011C           ; }
 011C           ; /*--------------------------------------------------------------------
 011C           ; 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
 011C           ; 函数功能：
 011C           ; 注意事项：
 011C           ; 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
 011C           ; 输    入：
 011C           ; 返    回：
 011C           ; --------------------------------------------------------------------*/
 011C           ; bool I2C_SendWrDAdr_(uint16 wrDAdr)   
 011C           ; {
 011C                   .dbline 175
 011C           ;       if( wrDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 011C A0FE              sbrs R10,0
 011E 0EC0              rjmp L25
 0120           X8:
 0120                   .dbline 176
 0120           ;               if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )       //设置 （高位）器件写地址
 0120 0A2D              mov R16,R10
 0122 0695              lsr R16
 0124 0695              lsr R16
 0126 0695              lsr R16
 0128 0695              lsr R16
 012A 0695              lsr R16
 012C 0695              lsr R16
 012E 0695              lsr R16
 0130 0695              lsr R16
 0132 DFDF              xcall _I2C_SendWrDAdr
 0134 0023              tst R16
 0136 11F4              brne L27
 0138           X9:
 0138                   .dbline 177
 0138           ;                       return I2C_ERR;
 0138 0027              clr R16
 013A 07C0              xjmp L24
 013C           L27:
 013C           L25:
 013C                   .dbline 178
 013C           ;       if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )  //设置 （低位）器件写地址
 013C 0A2D              mov R16,R10
 013E D9DF              xcall _I2C_SendWrDAdr
 0140 0023              tst R16
 0142 11F4              brne L29
 0144           X10:
 0144                   .dbline 179
 0144           ;               return I2C_ERR;
 0144 0027              clr R16
 0146 01C0              xjmp L24
 0148           L29:
 0148                   .dbline 180
 0148           ;       return I2C_CRR;
 0148 01E0              ldi R16,1
 014A                   .dbline -2
 014A           L24:
 014A                   .dbline 0 ; func end
 014A B990              ld R11,y+
 014C A990              ld R10,y+
 014E 0895              ret
 0150                   .dbsym r wrDAdr 10 i
 0150                   .dbend
 0150                   .dbfunc e I2C_SendRdDAdr _I2C_SendRdDAdr fc
 0150           ;         rdDAdr -> R16
                        .even
 0150           _I2C_SendRdDAdr::
 0150                   .dbline -1
 0150                   .dbline 191
 0150           ; }
 0150           ; /*--------------------------------------------------------------------
 0150           ; 函数名称：发送 7位 器件读地址: XXXX XXX1
 0150           ; 函数功能：
 0150           ; 注意事项：
 0150           ; 提示说明：
 0150           ; 输    入：
 0150           ; 返    回：
 0150           ; --------------------------------------------------------------------*/
 0150           ; bool I2C_SendRdDAdr(uint8 rdDAdr)     
 0150           ; {
 0150                   .dbline 192
 0150           ;       I2CSendByte(rdDAdr);                    //设置 器件读地址
 0150                   .dbline 192
 0150 00937300          sts 115,R16
 0154                   .dbline 192
 0154 84E8              ldi R24,132
 0156 80937400          sts 116,R24
 015A                   .dbline 192
 015A                   .dbline 192
 015A                   .dbline 193
 015A           ;       I2CWaitAck();
 015A           L32:
 015A                   .dbline 193
 015A           L33:
 015A                   .dbline 193
 015A 20907400          lds R2,116
 015E 27FE              sbrs R2,7
 0160 FCCF              rjmp L32
 0162           X11:
 0162                   .dbline 193
 0162                   .dbline 193
 0162                   .dbline 194
 0162           ;       if( I2CChkAck()!=I2C_MR_SLA_ACK )  
 0162 80917100          lds R24,113
 0166 887F              andi R24,248
 0168 8034              cpi R24,64
 016A 11F0              breq L35
 016C           X12:
 016C                   .dbline 195
 016C           ;               return I2C_ERR;
 016C 0027              clr R16
 016E 01C0              xjmp L31
 0170           L35:
 0170                   .dbline 196
 0170           ;       return I2C_CRR; 
 0170 01E0              ldi R16,1
 0172                   .dbline -2
 0172           L31:
 0172                   .dbline 0 ; func end
 0172 0895              ret
 0174                   .dbsym r rdDAdr 16 c
 0174                   .dbend
 0174                   .dbfunc e I2C_SendRdDAdr_ _I2C_SendRdDAdr_ fc
 0174           ;         rdDAdr -> R10
                        .even
 0174           _I2C_SendRdDAdr_::
 0174 AA92              st -y,R10
 0176 A02E              mov R10,R16
 0178                   .dbline -1
 0178                   .dbline 207
 0178           ; }
 0178           ; /*--------------------------------------------------------------------
 0178           ; 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
 0178           ; 函数功能：
 0178           ; 注意事项：
 0178           ; 提示说明：
 0178           ; 输    入：
 0178           ; 返    回：
 0178           ; --------------------------------------------------------------------*/
 0178           ; bool I2C_SendRdDAdr_(uint8 rdDAdr)    
 0178           ; {
 0178                   .dbline 208
 0178           ;       if( rdDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 0178 A0FE              sbrs R10,0
 017A 0EC0              rjmp L38
 017C           X13:
 017C                   .dbline 209
 017C           ;               if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )       //设置 （高位）器件读地址
 017C 0A2D              mov R16,R10
 017E 0695              lsr R16
 0180 0695              lsr R16
 0182 0695              lsr R16
 0184 0695              lsr R16
 0186 0695              lsr R16
 0188 0695              lsr R16
 018A 0695              lsr R16
 018C 0695              lsr R16
 018E B1DF              xcall _I2C_SendWrDAdr
 0190 0023              tst R16
 0192 11F4              brne L40
 0194           X14:
 0194                   .dbline 210
 0194           ;                       return I2C_ERR;
 0194 0027              clr R16
 0196 07C0              xjmp L37
 0198           L40:
 0198           L38:
 0198                   .dbline 211
 0198           ;       if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )  //设置 （低位）器件读地址
 0198 0A2D              mov R16,R10
 019A ABDF              xcall _I2C_SendWrDAdr
 019C 0023              tst R16
 019E 11F4              brne L42
 01A0           X15:
 01A0                   .dbline 212
 01A0           ;               return I2C_ERR;
 01A0 0027              clr R16
 01A2 01C0              xjmp L37
 01A4           L42:
 01A4                   .dbline 213
 01A4           ;       return I2C_CRR;
 01A4 01E0              ldi R16,1
 01A6                   .dbline -2
 01A6           L37:
 01A6                   .dbline 0 ; func end
 01A6 A990              ld R10,y+
 01A8 0895              ret
 01AA                   .dbsym r rdDAdr 10 c
 01AA                   .dbend
 01AA                   .dbfunc e I2C_SendDat _I2C_SendDat fc
 01AA           ;      configDat -> R16
                        .even
 01AA           _I2C_SendDat::
 01AA                   .dbline -1
 01AA                   .dbline 224
 01AA           ; }
 01AA           ; /*--------------------------------------------------------------------
 01AA           ; 函数名称：I2C发送数据
 01AA           ; 函数功能：
 01AA           ; 注意事项：
 01AA           ; 提示说明：
 01AA           ; 输    入：
 01AA           ; 返    回：
 01AA           ; --------------------------------------------------------------------*/
 01AA           ; bool I2C_SendDat(uint8 configDat)     
 01AA           ; {
 01AA                   .dbline 225
 01AA           ;       I2CSendByte(configDat);                 
 01AA                   .dbline 225
 01AA 00937300          sts 115,R16
 01AE                   .dbline 225
 01AE 84E8              ldi R24,132
 01B0 80937400          sts 116,R24
 01B4                   .dbline 225
 01B4                   .dbline 225
 01B4                   .dbline 226
 01B4           ;       I2CWaitAck();
 01B4           L45:
 01B4                   .dbline 226
 01B4           L46:
 01B4                   .dbline 226
 01B4 20907400          lds R2,116
 01B8 27FE              sbrs R2,7
 01BA FCCF              rjmp L45
 01BC           X16:
 01BC                   .dbline 226
 01BC                   .dbline 226
 01BC                   .dbline 227
 01BC           ;       if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
 01BC 80917100          lds R24,113
 01C0 887F              andi R24,248
 01C2 8832              cpi R24,40
 01C4 11F0              breq L48
 01C6           X17:
 01C6                   .dbline 228
 01C6           ;               return I2C_ERR;
 01C6 0027              clr R16
 01C8 01C0              xjmp L44
 01CA           L48:
 01CA                   .dbline 229
 01CA           ;       return I2C_CRR; 
 01CA 01E0              ldi R16,1
 01CC                   .dbline -2
 01CC           L44:
 01CC                   .dbline 0 ; func end
 01CC 0895              ret
 01CE                   .dbsym r configDat 16 c
 01CE                   .dbend
 01CE                   .dbfunc e I2C_RcvNAckDat _I2C_RcvNAckDat fc
 01CE           ;         pRdDat -> R16,R17
                        .even
 01CE           _I2C_RcvNAckDat::
 01CE                   .dbline -1
 01CE                   .dbline 240
 01CE           ; }
 01CE           ; /*--------------------------------------------------------------------
 01CE           ; 函数名称：I2C接收数据且不产生应答
 01CE           ; 函数功能：
 01CE           ; 注意事项：
 01CE           ; 提示说明：
 01CE           ; 输    入：
 01CE           ; 返    回：
 01CE           ; --------------------------------------------------------------------*/
 01CE           ; bool I2C_RcvNAckDat(uint8 *pRdDat)    
 01CE           ; {
 01CE                   .dbline 241
 01CE           ;       I2CRcvNckByte();
 01CE 84E8              ldi R24,132
 01D0 80937400          sts 116,R24
 01D4                   .dbline 242
 01D4           ;       I2CWaitAck();
 01D4           L51:
 01D4                   .dbline 242
 01D4           L52:
 01D4                   .dbline 242
 01D4 20907400          lds R2,116
 01D8 27FE              sbrs R2,7
 01DA FCCF              rjmp L51
 01DC           X18:
 01DC                   .dbline 242
 01DC                   .dbline 242
 01DC                   .dbline 243
 01DC           ;       if( I2CChkAck()!=I2C_MR_DATA_NACK )
 01DC 80917100          lds R24,113
 01E0 887F              andi R24,248
 01E2 8835              cpi R24,88
 01E4 11F0              breq L54
 01E6           X19:
 01E6                   .dbline 244
 01E6           ;               return I2C_ERR;
 01E6 0027              clr R16
 01E8 05C0              xjmp L50
 01EA           L54:
 01EA                   .dbline 245
 01EA           ;       *pRdDat=TWDR;
 01EA 20907300          lds R2,115
 01EE F801              movw R30,R16
 01F0 2082              std z+0,R2
 01F2                   .dbline 246
 01F2           ;       return I2C_CRR;
 01F2 01E0              ldi R16,1
 01F4                   .dbline -2
 01F4           L50:
 01F4                   .dbline 0 ; func end
 01F4 0895              ret
 01F6                   .dbsym r pRdDat 16 pc
 01F6                   .dbend
 01F6                   .dbfunc e I2C_RcvAckDat _I2C_RcvAckDat fc
 01F6           ;         pRdDat -> R16,R17
                        .even
 01F6           _I2C_RcvAckDat::
 01F6                   .dbline -1
 01F6                   .dbline 257
 01F6           ; }
 01F6           ; /*--------------------------------------------------------------------
 01F6           ; 函数名称：I2C接收数据且产生应答
 01F6           ; 函数功能：
 01F6           ; 注意事项：
 01F6           ; 提示说明：
 01F6           ; 输    入：
 01F6           ; 返    回：
 01F6           ; --------------------------------------------------------------------*/
 01F6           ; bool I2C_RcvAckDat(uint8 *pRdDat)     
 01F6           ; {
 01F6                   .dbline 258
 01F6           ;       I2CRcvAckByte();                                        
 01F6 84EC              ldi R24,196
 01F8 80937400          sts 116,R24
 01FC                   .dbline 259
 01FC           ;       I2CWaitAck();
 01FC           L57:
 01FC                   .dbline 259
 01FC           L58:
 01FC                   .dbline 259
 01FC 20907400          lds R2,116
 0200 27FE              sbrs R2,7
 0202 FCCF              rjmp L57
 0204           X20:
 0204                   .dbline 259
 0204                   .dbline 259
 0204                   .dbline 260
 0204           ;       if( I2CChkAck()!=I2C_MR_DATA_ACK )
 0204 80917100          lds R24,113
 0208 887F              andi R24,248
 020A 8035              cpi R24,80
 020C 11F0              breq L60
 020E           X21:
 020E                   .dbline 261
 020E           ;               return I2C_ERR;
 020E 0027              clr R16
 0210 05C0              xjmp L56
 0212           L60:
 0212                   .dbline 262
 0212           ;       *pRdDat=TWDR;
 0212 20907300          lds R2,115
 0216 F801              movw R30,R16
 0218 2082              std z+0,R2
 021A                   .dbline 263
 021A           ;       return I2C_CRR;
 021A 01E0              ldi R16,1
 021C                   .dbline -2
 021C           L56:
 021C                   .dbline 0 ; func end
 021C 0895              ret
 021E                   .dbsym r pRdDat 16 pc
 021E                   .dbend
 021E                   .dbfunc e I2C_Write _I2C_Write fc
 021E           ;            dat -> R10
 021E           ;        wordAdr -> R12
 021E           ;         wrDAdr -> R14,R15
                        .even
 021E           _I2C_Write::
 021E 0E940000          xcall push_xgset00FC
 0222 C22E              mov R12,R18
 0224 7801              movw R14,R16
 0226 AE80              ldd R10,y+6
 0228                   .dbline -1
 0228                   .dbline 276
 0228           ; }
 0228           ; /*--------------------------------------------------------------------
 0228           ; 函数名称：I2C写器件，写一个数据
 0228           ; 函数功能：
 0228           ; 注意事项：
 0228           ; 提示说明：
 0228           ; 输    入：wrDAdr: write device-address 写器件地址
 0228           ;                wordAdr: word address 字地址
 0228           ;                dat: data 数据
 0228           ; 返    回：
 0228           ; --------------------------------------------------------------------*/
 0228           ; bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
 0228           ; {
 0228                   .dbline 277
 0228           ;       if( I2C_Start()==I2C_ERR )
 0228 44DF              xcall _I2C_Start
 022A 0023              tst R16
 022C 11F4              brne L63
 022E           X22:
 022E                   .dbline 278
 022E           ;               return I2C_ERR;
 022E 0027              clr R16
 0230 18C0              xjmp L62
 0232           L63:
 0232                   .dbline 280
 0232           ; 
 0232           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 0232 8701              movw R16,R14
 0234 70DF              xcall _I2C_SendWrDAdr_
 0236 0023              tst R16
 0238 11F4              brne L65
 023A           X23:
 023A                   .dbline 281
 023A           ;               return I2C_ERR;
 023A 0027              clr R16
 023C 12C0              xjmp L62
 023E           L65:
 023E                   .dbline 283
 023E           ; 
 023E           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 023E 0C2D              mov R16,R12
 0240 B4DF              xcall _I2C_SendDat
 0242 C02E              mov R12,R16
 0244 0023              tst R16
 0246 11F4              brne L67
 0248           X24:
 0248                   .dbline 284
 0248           ;               return I2C_ERR;
 0248 0027              clr R16
 024A 0BC0              xjmp L62
 024C           L67:
 024C                   .dbline 286
 024C           ; 
 024C           ;       if( I2C_SendDat(dat)==I2C_ERR )
 024C 0A2D              mov R16,R10
 024E ADDF              xcall _I2C_SendDat
 0250 A02E              mov R10,R16
 0252 0023              tst R16
 0254 11F4              brne L69
 0256           X25:
 0256                   .dbline 287
 0256           ;               return I2C_ERR;
 0256 0027              clr R16
 0258 04C0              xjmp L62
 025A           L69:
 025A                   .dbline 289
 025A           ; 
 025A           ;       I2C_Stop();
 025A 84E9              ldi R24,148
 025C 80937400          sts 116,R24
 0260                   .dbline 291
 0260           ; 
 0260           ;       return I2C_CRR;
 0260 01E0              ldi R16,1
 0262                   .dbline -2
 0262           L62:
 0262                   .dbline 0 ; func end
 0262 0C940000          xjmp pop_xgset00FC
 0266                   .dbsym r dat 10 c
 0266                   .dbsym r wordAdr 12 c
 0266                   .dbsym r wrDAdr 14 i
 0266                   .dbend
 0266                   .dbfunc e I2C_Read _I2C_Read fc
 0266           ;         pRdDat -> R10,R11
 0266           ;         rdDAdr -> R12
 0266           ;        wordAdr -> R14
 0266           ;         wrDAdr -> R20,R21
                        .even
 0266           _I2C_Read::
 0266 0E940000          xcall push_xgset30FC
 026A E22E              mov R14,R18
 026C A801              movw R20,R16
 026E C884              ldd R12,y+8
 0270 AA84              ldd R10,y+10
 0272 BB84              ldd R11,y+11
 0274                   .dbline -1
 0274                   .dbline 322
 0274           ; }
 0274           ; /*--------------------------------------------------------------------
 0274           ; 函数名称：I2C写器件，写N个数据
 0274           ; 函数功能：
 0274           ; 注意事项：
 0274           ; 提示说明：
 0274           ; 输    入：wrDAdr: write device-address 写器件地址
 0274           ;                wordAdr: word address 字地址
 0274           ;                *pWrDat: p->write data 写入数据指针
 0274           ;                num: number 写入数据个数
 0274           ; 返    回：
 0274           ; --------------------------------------------------------------------*/
 0274           ; //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
 0274           ; //                              uint8 *pWrDat,uint8 num)
 0274           ; //{
 0274           ; //
 0274           ; //} 
 0274           ; /*--------------------------------------------------------------------
 0274           ; 函数名称：I2C读器件，读一个数据
 0274           ; 函数功能：
 0274           ; 注意事项：
 0274           ; 提示说明：
 0274           ; 输    入：wrDAdr: write device-address 写器件地址
 0274           ;                wordAdr: word address 字地址
 0274           ;                rdDAdr: read device-address 读器件地址
 0274           ;                *pRdDat: p->read data 读取数据指针
 0274           ; 返    回：
 0274           ; --------------------------------------------------------------------*/
 0274           ; bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
 0274           ;                         uint8 rdDAdr,uint8 *pRdDat)
 0274           ; {
 0274                   .dbline 323
 0274           ;       if( I2C_Start()==I2C_ERR )
 0274 1EDF              xcall _I2C_Start
 0276 0023              tst R16
 0278 11F4              brne L72
 027A           X26:
 027A                   .dbline 324
 027A           ;               return I2C_ERR;
 027A 0027              clr R16
 027C 25C0              xjmp L71
 027E           L72:
 027E                   .dbline 326
 027E           ; 
 027E           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 027E 8A01              movw R16,R20
 0280 4ADF              xcall _I2C_SendWrDAdr_
 0282 0023              tst R16
 0284 11F4              brne L74
 0286           X27:
 0286                   .dbline 327
 0286           ;               return I2C_ERR;
 0286 0027              clr R16
 0288 1FC0              xjmp L71
 028A           L74:
 028A                   .dbline 329
 028A           ; 
 028A           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 028A 0E2D              mov R16,R14
 028C 8EDF              xcall _I2C_SendDat
 028E E02E              mov R14,R16
 0290 0023              tst R16
 0292 11F4              brne L76
 0294           X28:
 0294                   .dbline 330
 0294           ;               return I2C_ERR;
 0294 0027              clr R16
 0296 18C0              xjmp L71
 0298           L76:
 0298                   .dbline 332
 0298           ; 
 0298           ;       if( I2C_Restart()==I2C_ERR )
 0298 1CDF              xcall _I2C_Restart
 029A E02E              mov R14,R16
 029C 0023              tst R16
 029E 11F4              brne L78
 02A0           X29:
 02A0                   .dbline 333
 02A0           ;               return I2C_ERR;
 02A0 0027              clr R16
 02A2 12C0              xjmp L71
 02A4           L78:
 02A4                   .dbline 335
 02A4           ; 
 02A4           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 02A4 0C2D              mov R16,R12
 02A6 54DF              xcall _I2C_SendRdDAdr
 02A8 C02E              mov R12,R16
 02AA 0023              tst R16
 02AC 11F4              brne L80
 02AE           X30:
 02AE                   .dbline 336
 02AE           ;               return I2C_ERR;
 02AE 0027              clr R16
 02B0 0BC0              xjmp L71
 02B2           L80:
 02B2                   .dbline 338
 02B2           ; 
 02B2           ;       if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
 02B2 8501              movw R16,R10
 02B4 8CDF              xcall _I2C_RcvNAckDat
 02B6 A02E              mov R10,R16
 02B8 0023              tst R16
 02BA 11F4              brne L82
 02BC           X31:
 02BC                   .dbline 339
 02BC           ;               return I2C_ERR;
 02BC 0027              clr R16
 02BE 04C0              xjmp L71
 02C0           L82:
 02C0                   .dbline 341
 02C0           ; 
 02C0           ;       I2C_Stop();
 02C0 84E9              ldi R24,148
 02C2 80937400          sts 116,R24
 02C6                   .dbline 343
 02C6           ; 
 02C6           ;       return I2C_CRR;
 02C6 01E0              ldi R16,1
 02C8                   .dbline -2
 02C8           L71:
 02C8                   .dbline 0 ; func end
 02C8 0C940000          xjmp pop_xgset30FC
 02CC                   .dbsym r pRdDat 10 pc
 02CC                   .dbsym r rdDAdr 12 c
 02CC                   .dbsym r wordAdr 14 c
 02CC                   .dbsym r wrDAdr 20 i
 02CC                   .dbend
 02CC                   .dbfunc e I2C_Read_ _I2C_Read_ fc
 02CC           ;              i -> R12
 02CC           ;            num -> R20
 02CC           ;         pRdDat -> R10,R11
 02CC           ;         rdDAdr -> R12
 02CC           ;        wordAdr -> R14
 02CC           ;         wrDAdr -> R22,R23
                        .even
 02CC           _I2C_Read_::
 02CC 0E940000          xcall push_xgsetF0FC
 02D0 E22E              mov R14,R18
 02D2 B801              movw R22,R16
 02D4 CA84              ldd R12,y+10
 02D6 AC84              ldd R10,y+12
 02D8 BD84              ldd R11,y+13
 02DA 4E85              ldd R20,y+14
 02DC                   .dbline -1
 02DC                   .dbline 359
 02DC           ; }
 02DC           ; /*--------------------------------------------------------------------
 02DC           ; 函数名称：I2C读器件，读N个数据
 02DC           ; 函数功能：
 02DC           ; 注意事项：
 02DC           ; 提示说明：
 02DC           ; 输    入：wrDAdr: write device-address 写器件地址
 02DC           ;                wordAdr: word address 字地址
 02DC           ;                rdDAdr: read device-address 读器件地址
 02DC           ;                *pRdDat: p->read data 读取数据指针
 02DC           ;                num: number 读取数据个数
 02DC           ; 返    回：
 02DC           ; --------------------------------------------------------------------*/
 02DC           ; bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
 02DC           ;                          uint8 rdDAdr,uint8 *pRdDat,uint8 num)
 02DC           ; {
 02DC                   .dbline 362
 02DC           ;       uint8 i;
 02DC           ;       
 02DC           ;       if( I2C_Start()==I2C_ERR )
 02DC EADE              xcall _I2C_Start
 02DE 0023              tst R16
 02E0 11F4              brne L85
 02E2           X32:
 02E2                   .dbline 363
 02E2           ;               return I2C_ERR;
 02E2 0027              clr R16
 02E4 39C0              xjmp L84
 02E6           L85:
 02E6                   .dbline 365
 02E6           ; 
 02E6           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 02E6 8B01              movw R16,R22
 02E8 16DF              xcall _I2C_SendWrDAdr_
 02EA 0023              tst R16
 02EC 11F4              brne L87
 02EE           X33:
 02EE                   .dbline 366
 02EE           ;               return I2C_ERR;
 02EE 0027              clr R16
 02F0 33C0              xjmp L84
 02F2           L87:
 02F2                   .dbline 368
 02F2           ; 
 02F2           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 02F2 0E2D              mov R16,R14
 02F4 5ADF              xcall _I2C_SendDat
 02F6 E02E              mov R14,R16
 02F8 0023              tst R16
 02FA 11F4              brne L89
 02FC           X34:
 02FC                   .dbline 369
 02FC           ;               return I2C_ERR;
 02FC 0027              clr R16
 02FE 2CC0              xjmp L84
 0300           L89:
 0300                   .dbline 371
 0300           ; 
 0300           ;       if( I2C_Restart()==I2C_ERR )
 0300 E8DE              xcall _I2C_Restart
 0302 E02E              mov R14,R16
 0304 0023              tst R16
 0306 11F4              brne L91
 0308           X35:
 0308                   .dbline 372
 0308           ;               return I2C_ERR;
 0308 0027              clr R16
 030A 26C0              xjmp L84
 030C           L91:
 030C                   .dbline 374
 030C           ; 
 030C           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 030C 0C2D              mov R16,R12
 030E 20DF              xcall _I2C_SendRdDAdr
 0310 C02E              mov R12,R16
 0312 0023              tst R16
 0314 11F4              brne L93
 0316           X36:
 0316                   .dbline 375
 0316           ;               return I2C_ERR;
 0316 0027              clr R16
 0318 1FC0              xjmp L84
 031A           L93:
 031A                   .dbline 377
 031A           ; 
 031A           ;       for(i=0;i<num-1;i++)
 031A CC24              clr R12
 031C 0BC0              xjmp L98
 031E           L95:
 031E                   .dbline 378
 031E           ;               if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
 031E 0C2D              mov R16,R12
 0320 1127              clr R17
 0322 0A0D              add R16,R10
 0324 1B1D              adc R17,R11
 0326 67DF              xcall _I2C_RcvAckDat
 0328 E02E              mov R14,R16
 032A 0023              tst R16
 032C 11F4              brne L99
 032E           X37:
 032E                   .dbline 379
 032E           ;                       return I2C_ERR;
 032E 0027              clr R16
 0330 13C0              xjmp L84
 0332           L99:
 0332           L96:
 0332                   .dbline 377
 0332 C394              inc R12
 0334           L98:
 0334                   .dbline 377
 0334 842F              mov R24,R20
 0336 8150              subi R24,1
 0338 C816              cp R12,R24
 033A 88F3              brlo L95
 033C           X38:
 033C                   .dbline 381
 033C           ;       
 033C           ;       if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
 033C 0C2D              mov R16,R12
 033E 1127              clr R17
 0340 0A0D              add R16,R10
 0342 1B1D              adc R17,R11
 0344 44DF              xcall _I2C_RcvNAckDat
 0346 A02E              mov R10,R16
 0348 0023              tst R16
 034A 11F4              brne L101
 034C           X39:
 034C                   .dbline 382
 034C           ;                       return I2C_ERR;
 034C 0027              clr R16
 034E 04C0              xjmp L84
 0350           L101:
 0350                   .dbline 384
 0350           ; 
 0350           ;       I2C_Stop();
 0350 84E9              ldi R24,148
 0352 80937400          sts 116,R24
 0356                   .dbline 386
 0356           ;       
 0356           ;       return I2C_CRR;
 0356 01E0              ldi R16,1
 0358                   .dbline -2
 0358           L84:
 0358                   .dbline 0 ; func end
 0358 0C940000          xjmp pop_xgsetF0FC
 035C                   .dbsym r i 12 c
 035C                   .dbsym r num 20 c
 035C                   .dbsym r pRdDat 10 pc
 035C                   .dbsym r rdDAdr 12 c
 035C                   .dbsym r wordAdr 14 c
 035C                   .dbsym r wrDAdr 22 i
 035C                   .dbend
 035C                   .dbfile D:\ICC_H\Hardware.H
 035C                   .dbfunc e delay50us _delay50us fV
 035C           ;              j -> R20
 035C           ;              t -> R16,R17
                        .even
 035C           _delay50us::
 035C 4A93              st -y,R20
 035E                   .dbline -1
 035E                   .dbline 105
 035E           ; /*********************************************************************
 035E           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 035E           ;                                                                       
 035E           ; 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
 035E           ;                                       
 035E           ; 目标系统:   基于AVR单片机
 035E           ;                                                                               
 035E           ; 应用软件:   ICCAVR
 035E           ;                                                                               
 035E           ; 版    本:   Version 1.0                                                          
 035E           ;                                                                               
 035E           ; 圆版时间:   2005-06-25
 035E           ;       
 035E           ; 开发人员:   SEE
 035E           ; 
 035E           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 035E           ;       
 035E           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 035E           ; *********************************************************************/
 035E           ; 
 035E           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 035E           ; ----------------------------------------------------------------------
 035E           ; 版本更新记录：
 035E           ; 
 035E           ; ----------------------------------------------------------------------
 035E           ; 入口参数说明：
 035E           ; 
 035E           ; ----------------------------------------------------------------------
 035E           ; 待定参数说明：
 035E           ; 
 035E           ; ----------------------------------------------------------------------        
 035E           ; 对外变量说明：
 035E           ;     
 035E           ; ----------------------------------------------------------------------
 035E           ; 对外函数说明：
 035E           ;    
 035E           ; ----------------------------------------------------------------------
 035E           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 035E           ; 
 035E           ; #ifndef Hardware_H
 035E           ; #define Hardware_H
 035E           ; 
 035E           ; #include <math.h>
 035E           ; #include <string.h>
 035E           ; #include <stdio.h>
 035E           ; #include <macros.h>
 035E           ; #include <eeprom.h>
 035E           ; //#include <wdt.h>
 035E           ; 
 035E           ; /* TWI configs */
 035E           ; //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
 035E           ; #if NO_INCLUDE_I2C_H
 035E           ; ;
 035E           ; #else
 035E           ; #include "D:\ICC_H\I2C.H"     //i2c即AVR的"twi"
 035E           ; #endif
 035E           ; 
 035E           ; /* hard configs */
 035E           ; #ifndef flash
 035E           ;       #define flash   const
 035E           ; #endif
 035E           ; 
 035E           ; #ifndef code
 035E           ;       #define code    const
 035E           ; #endif
 035E           ; 
 035E           ; #ifndef NOP
 035E           ;       #define NOP()   asm("nop")
 035E           ; #endif
 035E           ; 
 035E           ; /* io configs */
 035E           ; #define sbi(io,bit)           (  io |=  (1<<bit) )    //example: sbi(PORTA,0);sbi(DDRA,0);
 035E           ; #define cbi(io,bit)           (  io &= ~(1<<bit) )    //example: cbi(PORTA,0);cbi(DDRA,0);
 035E           ; #define gbi(pin ,bit) ( pin &   (1<<bit) )    //example: gbi(PINA,0);
 035E           ; 
 035E           ; /* interrupt configs */
 035E           ; #define DIS_INT  asm("sei")
 035E           ; #define EN_INT   asm("cli")
 035E           ; 
 035E           ; /* wdt configs */
 035E           ; #define WDT()    asm("wdr")
 035E           ; 
 035E           ; /* bit operation */
 035E           ; //#ifndef BIT
 035E           ; //#define BIT(x)      ( 1<<(x) )
 035E           ; //#endif
 035E           ; 
 035E           ; /* USART configs for 4 Mhz crystal */
 035E           ; //#define BAUD9600                    25
 035E           ; //#define BAUD19000                   12
 035E           ; //#define UART_TRAN_ON()      UCR |=  0x08
 035E           ; //#define UART_TRAN_OFF()     UCR &= ~0x08
 035E           ; //#define UART_RCV_ON()               UCR |=  0x10
 035E           ; //#define UART_RCV_OFF()      UCR &= ~0x10
 035E           ; 
 035E           ; /*--------------------------------------------------------------------
 035E           ; 函数全称：50us 延时
 035E           ; 函数功能：当然是 50us延时 啦
 035E           ; 注意事项：基于7.3728M晶振，稍微有点误差
 035E           ; 提示说明：调用delay50us（20），得到1ms延时
 035E           ; 输    入：    
 035E           ; 返    回：无 
 035E           ; --------------------------------------------------------------------*/
 035E           ; void delay50us(sint16 t)
 035E           ; {
 035E                   .dbline 107
 035E           ;     uint8 j;          
 035E           ;     for(;t>0;t--)                     
 035E 07C0              xjmp L107
 0360           L104:
 0360                   .dbline 108
 0360           ;         for(j=0;j<70;j++)     
 0360 4427              clr R20
 0362 01C0              xjmp L111
 0364           L108:
 0364                   .dbline 109
 0364           ;             ;
 0364           L109:
 0364                   .dbline 108
 0364 4395              inc R20
 0366           L111:
 0366                   .dbline 108
 0366 4634              cpi R20,70
 0368 E8F3              brlo L108
 036A           X40:
 036A           L105:
 036A                   .dbline 107
 036A 0150              subi R16,1
 036C 1040              sbci R17,0
 036E           L107:
 036E                   .dbline 107
 036E 2224              clr R2
 0370 3324              clr R3
 0372 2016              cp R2,R16
 0374 3106              cpc R3,R17
 0376 A4F3              brlt L104
 0378           X41:
 0378                   .dbline -2
 0378           L103:
 0378                   .dbline 0 ; func end
 0378 4991              ld R20,y+
 037A 0895              ret
 037C                   .dbsym r j 20 c
 037C                   .dbsym r t 16 I
 037C                   .dbend
 037C                   .dbfunc e delay50ms _delay50ms fV
 037C           ;              i -> R20,R21
 037C           ;              t -> R16,R17
                        .even
 037C           _delay50ms::
 037C 4A93              st -y,R20
 037E 5A93              st -y,R21
 0380                   .dbline -1
 0380                   .dbline 120
 0380           ; }
 0380           ; /*--------------------------------------------------------------------
 0380           ; 函数全称：50ms 延时
 0380           ; 函数功能：当然是 50ms延时 啦
 0380           ; 注意事项：基于7.3728M晶振，稍微有点误差
 0380           ; 提示说明：调用delay50ms（20），得到1s延时 
 0380           ; 输    入：
 0380           ; 返    回：无
 0380           ; --------------------------------------------------------------------*/
 0380           ; void delay50ms(sint16 t)
 0380           ; {
 0380                   .dbline 122
 0380           ;       uint16 i; 
 0380           ;       for(;t>0;t--)
 0380 13C0              xjmp L116
 0382           L113:
 0382                   .dbline 123
 0382           ;               for(i=0;i<52642;i++)
 0382 4427              clr R20
 0384 5527              clr R21
 0386 02C0              xjmp L120
 0388           L117:
 0388                   .dbline 124
 0388           ;                       ; 
 0388           L118:
 0388                   .dbline 123
 0388 4F5F              subi R20,255  ; offset = 1
 038A 5F4F              sbci R21,255
 038C           L120:
 038C                   .dbline 123
 038C 82EA              ldi R24,162
 038E 9DEC              ldi R25,205
 0390 A0E0              ldi R26,0
 0392 B0E0              ldi R27,0
 0394 1A01              movw R2,R20
 0396 4424              clr R4
 0398 5524              clr R5
 039A 2816              cp R2,R24
 039C 3906              cpc R3,R25
 039E 4A06              cpc R4,R26
 03A0 5B06              cpc R5,R27
 03A2 94F3              brlt L117
 03A4           X42:
 03A4           L114:
 03A4                   .dbline 122
 03A4 0150              subi R16,1
 03A6 1040              sbci R17,0
 03A8           L116:
 03A8                   .dbline 122
 03A8 2224              clr R2
 03AA 3324              clr R3
 03AC 2016              cp R2,R16
 03AE 3106              cpc R3,R17
 03B0 44F3              brlt L113
 03B2           X43:
 03B2                   .dbline -2
 03B2           L112:
 03B2                   .dbline 0 ; func end
 03B2 5991              ld R21,y+
 03B4 4991              ld R20,y+
 03B6 0895              ret
 03B8                   .dbsym r i 20 i
 03B8                   .dbsym r t 16 I
 03B8                   .dbend
 03B8                   .dbfunc e delayus _delayus fV
 03B8           ;              i -> R20,R21
 03B8           ;              t -> R16,R17
                        .even
 03B8           _delayus::
 03B8 4A93              st -y,R20
 03BA 5A93              st -y,R21
 03BC                   .dbline -1
 03BC                   .dbline 129
 03BC           ; }
 03BC           ; 
 03BC           ; 
 03BC           ; void delayus(uint16 t)
 03BC           ; {
 03BC                   .dbline 131
 03BC           ;       uint16 i;
 03BC           ;       for(i=0;i<t;i++)
 03BC 4427              clr R20
 03BE 5527              clr R21
 03C0 02C0              xjmp L125
 03C2           L122:
 03C2                   .dbline 132
 03C2           ;               {
 03C2                   .dbline 135
 03C2           ;                       //asm("NOP\n");
 03C2           ;                       //asm("NOP\n");
 03C2           ;               }
 03C2           L123:
 03C2                   .dbline 131
 03C2 4F5F              subi R20,255  ; offset = 1
 03C4 5F4F              sbci R21,255
 03C6           L125:
 03C6                   .dbline 131
 03C6 4017              cp R20,R16
 03C8 5107              cpc R21,R17
 03CA D8F3              brlo L122
 03CC           X44:
 03CC                   .dbline -2
 03CC           L121:
 03CC                   .dbline 0 ; func end
 03CC 5991              ld R21,y+
 03CE 4991              ld R20,y+
 03D0 0895              ret
 03D2                   .dbsym r i 20 i
 03D2                   .dbsym r t 16 i
 03D2                   .dbend
 03D2                   .dbfile D:\ICC_H\LCD12864_ST7920_.H
 03D2                   .dbfunc e SPI_init _SPI_init fV
                        .even
 03D2           _SPI_init::
 03D2                   .dbline -1
 03D2                   .dbline 60
 03D2           ; /*********************************************************************
 03D2           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 03D2           ;                                                               
 03D2           ; 目    的:   建立LCD12864_ST7920的串模式操作库
 03D2           ; 
 03D2           ; 目标系统:   基于AVR单片机
 03D2           ;                                                                       
 03D2           ; 应用软件:   ICCAVR                                               
 03D2           ;                                                                       
 03D2           ; 版    本:   Version 1.0
 03D2           ;                                                                       
 03D2           ; 圆版时间:   2005-09-06
 03D2           ; 
 03D2           ; 开发人员:   SEE
 03D2           ; 
 03D2           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 03D2           ; 
 03D2           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权 
 03D2           ; *********************************************************************/
 03D2           ; 
 03D2           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 版本更新记录：
 03D2           ; 
 03D2           ; 
 03D2           ; 
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 入口参数说明：
 03D2           ; mega128接口
 03D2           ;                         DVK500                                 STK128+
 03D2           ;                               CS              ---------         VCC
 03D2           ;                               PSB         ---------     GND
 03D2           ;                               SID             ---------         PB2
 03D2           ;                               CLK             ---------         PB1   
 03D2           ; 
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 待定参数说明：
 03D2           ;       
 03D2           ; 
 03D2           ; ----------------------------------------------------------------------        
 03D2           ; 对外变量说明：
 03D2           ; 
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 对外函数说明：
 03D2           ; 
 03D2           ; ----------------------------------------------------------------------
 03D2           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 03D2           ; 
 03D2           ; 
 03D2           ; /*--------------------------------------------------------------------
 03D2           ; 
 03D2           ; --------------------------------------------------------------------*/
 03D2           ; 
 03D2           ; #ifndef LCD12864_ST7920_H
 03D2           ; #define LCD12864_ST7920_H
 03D2           ; 
 03D2           ; #include "D:\ICC_H\CmmIcc.h"
 03D2           ; 
 03D2           ; void SPI_init()
 03D2           ; {
 03D2                   .dbline 61
 03D2           ;       DDRB |= 0x0F;
 03D2 87B3              in R24,0x17
 03D4 8F60              ori R24,15
 03D6 87BB              out 0x17,R24
 03D8                   .dbline 62
 03D8           ;       SPCR = 0x50;    //setup SPI
 03D8 80E5              ldi R24,80
 03DA 8DB9              out 0xd,R24
 03DC                   .dbline 63
 03DC           ;       SPSR = 0x01;    //setup SPI
 03DC 81E0              ldi R24,1
 03DE 8EB9              out 0xe,R24
 03E0                   .dbline 64
 03E0           ;       SEI();                  
 03E0 7894              sei
 03E2                   .dbline -2
 03E2           L126:
 03E2                   .dbline 0 ; func end
 03E2 0895              ret
 03E4                   .dbend
 03E4                   .dbfunc e lcd_wrByte _lcd_wrByte fV
 03E4           ;           data -> R16
                        .even
 03E4           _lcd_wrByte::
 03E4                   .dbline -1
 03E4                   .dbline 68
 03E4           ; }
 03E4           ; 
 03E4           ; void lcd_wrByte(uint8 data)
 03E4           ; {  
 03E4                   .dbline 69
 03E4           ;       SPDR = data;        
 03E4 0FB9              out 0xf,R16
 03E6           L128:
 03E6                   .dbline 70
 03E6           ;       while ((SPSR & 0x80) == 0);  
 03E6           L129:
 03E6                   .dbline 70
 03E6 779B              sbis 0xe,7
 03E8 FECF              rjmp L128
 03EA           X45:
 03EA                   .dbline -2
 03EA           L127:
 03EA                   .dbline 0 ; func end
 03EA 0895              ret
 03EC                   .dbsym r data 16 c
 03EC                   .dbend
 03EC                   .dbfunc e lcd_wrCmd _lcd_wrCmd fV
 03EC           ;             LC -> R10
 03EC           ;             HC -> R12
                        .even
 03EC           _lcd_wrCmd::
 03EC AA92              st -y,R10
 03EE CA92              st -y,R12
 03F0 A22E              mov R10,R18
 03F2 C02E              mov R12,R16
 03F4                   .dbline -1
 03F4                   .dbline 74
 03F4           ; }
 03F4           ; 
 03F4           ; void lcd_wrCmd(uint8 HC,uint8 LC)
 03F4           ; {
 03F4                   .dbline 75
 03F4           ;       lcd_wrByte(0xF8);
 03F4 08EF              ldi R16,248
 03F6 F6DF              xcall _lcd_wrByte
 03F8                   .dbline 76
 03F8           ;       lcd_wrByte(HC);         //传输高四位
 03F8 0C2D              mov R16,R12
 03FA F4DF              xcall _lcd_wrByte
 03FC                   .dbline 77
 03FC           ;       lcd_wrByte(LC);         //传输低四位
 03FC 0A2D              mov R16,R10
 03FE F2DF              xcall _lcd_wrByte
 0400                   .dbline -2
 0400           L131:
 0400                   .dbline 0 ; func end
 0400 C990              ld R12,y+
 0402 A990              ld R10,y+
 0404 0895              ret
 0406                   .dbsym r LC 10 c
 0406                   .dbsym r HC 12 c
 0406                   .dbend
 0406                   .dbfunc e lcd_wrDat _lcd_wrDat fV
 0406           ;             LD -> R10
 0406           ;             HD -> R12
                        .even
 0406           _lcd_wrDat::
 0406 AA92              st -y,R10
 0408 CA92              st -y,R12
 040A A22E              mov R10,R18
 040C C02E              mov R12,R16
 040E                   .dbline -1
 040E                   .dbline 81
 040E           ; }
 040E           ; 
 040E           ; void lcd_wrDat(uint8 HD,uint8 LD)
 040E           ; {
 040E                   .dbline 82
 040E           ;       lcd_wrByte(0xFA);
 040E 0AEF              ldi R16,250
 0410 E9DF              xcall _lcd_wrByte
 0412                   .dbline 83
 0412           ;       lcd_wrByte(HD);         //传输高四位
 0412 0C2D              mov R16,R12
 0414 E7DF              xcall _lcd_wrByte
 0416                   .dbline 84
 0416           ;       lcd_wrByte(LD);         //传输低四位
 0416 0A2D              mov R16,R10
 0418 E5DF              xcall _lcd_wrByte
 041A                   .dbline -2
 041A           L132:
 041A                   .dbline 0 ; func end
 041A C990              ld R12,y+
 041C A990              ld R10,y+
 041E 0895              ret
 0420                   .dbsym r LD 10 c
 0420                   .dbsym r HD 12 c
 0420                   .dbend
 0420                   .dbfunc e lcd_set_xy _lcd_set_xy fV
 0420           ;            adr -> R20
 0420           ;              y -> R22
 0420           ;              x -> R10
                        .even
 0420           _lcd_set_xy::
 0420 0E940000          xcall push_xgsetF00C
 0424 622F              mov R22,R18
 0426 A02E              mov R10,R16
 0428                   .dbline -1
 0428                   .dbline 91
 0428           ; } 
 0428           ; 
 0428           ; /*
 0428           ; x表示在第几行显示，y表示在第几列显示
 0428           ; */
 0428           ; void lcd_set_xy(uint8 x,uint8 y) 
 0428           ; {
 0428                   .dbline 94
 0428           ;       uint8 adr;
 0428           ; 
 0428           ;       switch(x)
 0428 BB24              clr R11
 042A C501              movw R24,R10
 042C 8130              cpi R24,1
 042E E0E0              ldi R30,0
 0430 9E07              cpc R25,R30
 0432 69F0              breq L137
 0434           X46:
 0434 8230              cpi R24,2
 0436 E0E0              ldi R30,0
 0438 9E07              cpc R25,R30
 043A 61F0              breq L138
 043C           X47:
 043C 8330              cpi R24,3
 043E E0E0              ldi R30,0
 0440 9E07              cpc R25,R30
 0442 59F0              breq L139
 0444           X48:
 0444 8430              cpi R24,4
 0446 E0E0              ldi R30,0
 0448 9E07              cpc R25,R30
 044A 51F0              breq L140
 044C           X49:
 044C 0BC0              xjmp L134
 044E           L137:
 044E                   .dbline 96
 044E           ;       {
 044E           ;       case 1: adr = 0x7F + y;
 044E 462F              mov R20,R22
 0450 4158              subi R20,129    ; addi 127
 0452                   .dbline 97
 0452           ;               break;          //在第1行y列显示
 0452 08C0              xjmp L135
 0454           L138:
 0454                   .dbline 98
 0454           ;       case 2: adr = 0x8F + y;
 0454 462F              mov R20,R22
 0456 4157              subi R20,113    ; addi 143
 0458                   .dbline 99
 0458           ;               break;          //在第2行y列显示
 0458 05C0              xjmp L135
 045A           L139:
 045A                   .dbline 100
 045A           ;       case 3: adr = 0x87 + y;
 045A 462F              mov R20,R22
 045C 4957              subi R20,121    ; addi 135
 045E                   .dbline 101
 045E           ;               break;          //在第3行y列显示
 045E 02C0              xjmp L135
 0460           L140:
 0460                   .dbline 102
 0460           ;       case 4: adr = 0x97 + y;
 0460 462F              mov R20,R22
 0462 4956              subi R20,105    ; addi 151
 0464                   .dbline 103
 0464           ;               break;          //在第4行y列显示
 0464           L134:
 0464                   .dbline 104
 0464           ;       default:        ;
 0464                   .dbline 105
 0464           ;       }
 0464           L135:
 0464                   .dbline 106
 0464           ;       lcd_wrCmd(adr&0xF0,(adr&0x0F)<<4);
 0464 242F              mov R18,R20
 0466 2F70              andi R18,15
 0468 2F70              andi R18,#0x0F
 046A 2295              swap R18
 046C 042F              mov R16,R20
 046E 007F              andi R16,240
 0470 BDDF              xcall _lcd_wrCmd
 0472                   .dbline -2
 0472           L133:
 0472                   .dbline 0 ; func end
 0472 0C940000          xjmp pop_xgsetF00C
 0476                   .dbsym r adr 20 c
 0476                   .dbsym r y 22 c
 0476                   .dbsym r x 10 c
 0476                   .dbend
 0476                   .dbfunc e lcd_putc _lcd_putc fV
 0476           ;             ch -> R20
 0476           ;              y -> R12
 0476           ;              x -> R10
                        .even
 0476           _lcd_putc::
 0476 0E940000          xcall push_xgset303C
 047A C22E              mov R12,R18
 047C A02E              mov R10,R16
 047E 4E81              ldd R20,y+6
 0480                   .dbline -1
 0480                   .dbline 110
 0480           ; }
 0480           ; 
 0480           ; void lcd_putc(uint8 x,uint8 y,uint8 ch)
 0480           ; {
 0480                   .dbline 111
 0480           ;       lcd_set_xy(x,y);
 0480 2C2D              mov R18,R12
 0482 0A2D              mov R16,R10
 0484 CDDF              xcall _lcd_set_xy
 0486                   .dbline 112
 0486           ;       delay50us(20); 
 0486 04E1              ldi R16,20
 0488 10E0              ldi R17,0
 048A 68DF              xcall _delay50us
 048C                   .dbline 113
 048C           ;       lcd_wrDat(ch&0xF0,(ch&0x0F)<<4);
 048C 242F              mov R18,R20
 048E 2F70              andi R18,15
 0490 2F70              andi R18,#0x0F
 0492 2295              swap R18
 0494 042F              mov R16,R20
 0496 007F              andi R16,240
 0498 B6DF              xcall _lcd_wrDat
 049A                   .dbline -2
 049A           L141:
 049A                   .dbline 0 ; func end
 049A 0C940000          xjmp pop_xgset303C
 049E                   .dbsym r ch 20 c
 049E                   .dbsym r y 12 c
 049E                   .dbsym r x 10 c
 049E                   .dbend
 049E                   .dbfunc e lcd_putd0 _lcd_putd0 fV
 049E           ;              i -> R20
 049E           ;         length -> R20
 049E           ;            dat -> y+7
 049E           ;              y -> R12
 049E           ;              x -> R10
                        .even
 049E           _lcd_putd0::
 049E 0E940000          xcall push_xgset303C
 04A2 C22E              mov R12,R18
 04A4 A02E              mov R10,R16
 04A6 2197              sbiw R28,1
 04A8 4B85              ldd R20,y+11
 04AA                   .dbline -1
 04AA                   .dbline 117
 04AA           ; }
 04AA           ; 
 04AA           ; void lcd_putd0(uint8 x,uint8 y,uint32 dat,uint8 length)
 04AA           ; {
 04AA                   .dbline 120
 04AA           ;       sint8 i;
 04AA           ; 
 04AA           ;       speaData(dat,length);
 04AA 4883              std y+0,R20
 04AC 0F81              ldd R16,y+7
 04AE 1885              ldd R17,y+8
 04B0 2985              ldd R18,y+9
 04B2 3A85              ldd R19,y+10
 04B4 A5DD              xcall _speaData
 04B6                   .dbline 121
 04B6           ;       lcd_set_xy(x,y);
 04B6 2C2D              mov R18,R12
 04B8 0A2D              mov R16,R10
 04BA B2DF              xcall _lcd_set_xy
 04BC                   .dbline 122
 04BC           ;       delay50us(40);
 04BC 08E2              ldi R16,40
 04BE 10E0              ldi R17,0
 04C0 4DDF              xcall _delay50us
 04C2                   .dbline 123
 04C2           ;       for(i=length-1;i>=0;i--)
 04C2 4150              subi R20,1
 04C4 1EC0              xjmp L146
 04C6           L143:
 04C6                   .dbline 124
 04C6           ;       {
 04C6                   .dbline 125
 04C6           ;               lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
 04C6 80E0              ldi R24,<_dataElem
 04C8 90E0              ldi R25,>_dataElem
 04CA E42F              mov R30,R20
 04CC FF27              clr R31
 04CE E7FD              sbrc R30,7
 04D0 F095              com R31
 04D2 E80F              add R30,R24
 04D4 F91F              adc R31,R25
 04D6 8081              ldd R24,z+0
 04D8 9927              clr R25
 04DA C096              adiw R24,48
 04DC 9C01              movw R18,R24
 04DE 2F70              andi R18,15
 04E0 3070              andi R19,0
 04E2 220F              lsl R18
 04E4 331F              rol R19
 04E6 220F              lsl R18
 04E8 331F              rol R19
 04EA 220F              lsl R18
 04EC 331F              rol R19
 04EE 220F              lsl R18
 04F0 331F              rol R19
 04F2 8C01              movw R16,R24
 04F4 007F              andi R16,240
 04F6 1070              andi R17,0
 04F8 86DF              xcall _lcd_wrDat
 04FA                   .dbline 126
 04FA           ;               delay50us(40); 
 04FA 08E2              ldi R16,40
 04FC 10E0              ldi R17,0
 04FE 2EDF              xcall _delay50us
 0500                   .dbline 127
 0500           ;       }
 0500           L144:
 0500                   .dbline 123
 0500 4A95              dec R20
 0502           L146:
 0502                   .dbline 123
 0502 4030              cpi R20,0
 0504 04F7              brge L143
 0506           X50:
 0506                   .dbline -2
 0506           L142:
 0506                   .dbline 0 ; func end
 0506 2196              adiw R28,1
 0508 0C940000          xjmp pop_xgset303C
 050C                   .dbsym r i 20 C
 050C                   .dbsym r length 20 c
 050C                   .dbsym l dat 7 l
 050C                   .dbsym r y 12 c
 050C                   .dbsym r x 10 c
 050C                   .dbend
 050C                   .dbfunc e lcd_putd _lcd_putd fV
 050C           ;      effectLen -> R22
 050C           ;              i -> R20
 050C           ;         length -> R10
 050C           ;            dat -> y+11
 050C           ;              y -> R14
 050C           ;              x -> R12
                        .even
 050C           _lcd_putd::
 050C 0E940000          xcall push_xgsetF0FC
 0510 E22E              mov R14,R18
 0512 C02E              mov R12,R16
 0514 2197              sbiw R28,1
 0516 AF84              ldd R10,y+15
 0518                   .dbline -1
 0518                   .dbline 131
 0518           ; }
 0518           ; 
 0518           ; void lcd_putd(uint8 x,uint8 y,uint32 dat,uint8 length)
 0518           ; {
 0518                   .dbline 135
 0518           ;       sint8 i;
 0518           ;       sint8 effectLen;
 0518           ; 
 0518           ;       if(dat>999999)
 0518 8FE3              ldi R24,63
 051A 92E4              ldi R25,66
 051C AFE0              ldi R26,15
 051E B0E0              ldi R27,0
 0520 2B84              ldd R2,y+11
 0522 3C84              ldd R3,y+12
 0524 4D84              ldd R4,y+13
 0526 5E84              ldd R5,y+14
 0528 8215              cp R24,R2
 052A 9305              cpc R25,R3
 052C A405              cpc R26,R4
 052E B505              cpc R27,R5
 0530 10F4              brsh L148
 0532           X51:
 0532                   .dbline 136
 0532           ;               effectLen=7;
 0532 67E0              ldi R22,7
 0534 4CC0              xjmp L149
 0536           L148:
 0536                   .dbline 137
 0536           ;       else if(dat>99999)
 0536 8FE9              ldi R24,159
 0538 96E8              ldi R25,134
 053A A1E0              ldi R26,1
 053C B0E0              ldi R27,0
 053E 2B84              ldd R2,y+11
 0540 3C84              ldd R3,y+12
 0542 4D84              ldd R4,y+13
 0544 5E84              ldd R5,y+14
 0546 8215              cp R24,R2
 0548 9305              cpc R25,R3
 054A A405              cpc R26,R4
 054C B505              cpc R27,R5
 054E 10F4              brsh L150
 0550           X52:
 0550                   .dbline 138
 0550           ;               effectLen=6;
 0550 66E0              ldi R22,6
 0552 3DC0              xjmp L151
 0554           L150:
 0554                   .dbline 139
 0554           ;       else if(dat>9999)
 0554 8FE0              ldi R24,15
 0556 97E2              ldi R25,39
 0558 A0E0              ldi R26,0
 055A B0E0              ldi R27,0
 055C 2B84              ldd R2,y+11
 055E 3C84              ldd R3,y+12
 0560 4D84              ldd R4,y+13
 0562 5E84              ldd R5,y+14
 0564 8215              cp R24,R2
 0566 9305              cpc R25,R3
 0568 A405              cpc R26,R4
 056A B505              cpc R27,R5
 056C 10F4              brsh L152
 056E           X53:
 056E                   .dbline 140
 056E           ;               effectLen=5;
 056E 65E0              ldi R22,5
 0570 2EC0              xjmp L153
 0572           L152:
 0572                   .dbline 141
 0572           ;       else if(dat>999)
 0572 87EE              ldi R24,231
 0574 93E0              ldi R25,3
 0576 A0E0              ldi R26,0
 0578 B0E0              ldi R27,0
 057A 2B84              ldd R2,y+11
 057C 3C84              ldd R3,y+12
 057E 4D84              ldd R4,y+13
 0580 5E84              ldd R5,y+14
 0582 8215              cp R24,R2
 0584 9305              cpc R25,R3
 0586 A405              cpc R26,R4
 0588 B505              cpc R27,R5
 058A 10F4              brsh L154
 058C           X54:
 058C                   .dbline 142
 058C           ;               effectLen=4;
 058C 64E0              ldi R22,4
 058E 1FC0              xjmp L155
 0590           L154:
 0590                   .dbline 143
 0590           ;       else if(dat>99)
 0590 83E6              ldi R24,99
 0592 90E0              ldi R25,0
 0594 A0E0              ldi R26,0
 0596 B0E0              ldi R27,0
 0598 2B84              ldd R2,y+11
 059A 3C84              ldd R3,y+12
 059C 4D84              ldd R4,y+13
 059E 5E84              ldd R5,y+14
 05A0 8215              cp R24,R2
 05A2 9305              cpc R25,R3
 05A4 A405              cpc R26,R4
 05A6 B505              cpc R27,R5
 05A8 10F4              brsh L156
 05AA           X55:
 05AA                   .dbline 144
 05AA           ;               effectLen=3;
 05AA 63E0              ldi R22,3
 05AC 10C0              xjmp L157
 05AE           L156:
 05AE                   .dbline 145
 05AE           ;       else if(dat>9)
 05AE 89E0              ldi R24,9
 05B0 90E0              ldi R25,0
 05B2 A0E0              ldi R26,0
 05B4 B0E0              ldi R27,0
 05B6 2B84              ldd R2,y+11
 05B8 3C84              ldd R3,y+12
 05BA 4D84              ldd R4,y+13
 05BC 5E84              ldd R5,y+14
 05BE 8215              cp R24,R2
 05C0 9305              cpc R25,R3
 05C2 A405              cpc R26,R4
 05C4 B505              cpc R27,R5
 05C6 10F4              brsh L158
 05C8           X56:
 05C8                   .dbline 146
 05C8           ;               effectLen=2;
 05C8 62E0              ldi R22,2
 05CA 01C0              xjmp L159
 05CC           L158:
 05CC                   .dbline 148
 05CC           ;       else
 05CC           ;               effectLen=1;
 05CC 61E0              ldi R22,1
 05CE           L159:
 05CE           L157:
 05CE           L155:
 05CE           L153:
 05CE           L151:
 05CE           L149:
 05CE                   .dbline 149
 05CE           ;       speaData(dat,effectLen);
 05CE 6883              std y+0,R22
 05D0 0B85              ldd R16,y+11
 05D2 1C85              ldd R17,y+12
 05D4 2D85              ldd R18,y+13
 05D6 3E85              ldd R19,y+14
 05D8 13DD              xcall _speaData
 05DA                   .dbline 151
 05DA           ; 
 05DA           ;       lcd_set_xy(x,y);
 05DA 2E2D              mov R18,R14
 05DC 0C2D              mov R16,R12
 05DE 20DF              xcall _lcd_set_xy
 05E0                   .dbline 152
 05E0           ;       delay50us(40); 
 05E0 08E2              ldi R16,40
 05E2 10E0              ldi R17,0
 05E4 BBDE              xcall _delay50us
 05E6                   .dbline 153
 05E6           ;       if(length>effectLen)
 05E6 262E              mov R2,R22
 05E8 3324              clr R3
 05EA 27FC              sbrc R2,7
 05EC 3094              com R3
 05EE 4A2C              mov R4,R10
 05F0 5524              clr R5
 05F2 2414              cp R2,R4
 05F4 3504              cpc R3,R5
 05F6 6CF4              brge L160
 05F8           X57:
 05F8                   .dbline 154
 05F8           ;       {
 05F8                   .dbline 155
 05F8           ;               for(i=length-effectLen-1;i>=0;i--)
 05F8 442D              mov R20,R4
 05FA 461B              sub R20,R22
 05FC 4150              subi R20,1
 05FE 07C0              xjmp L165
 0600           L162:
 0600                   .dbline 156
 0600           ;               {
 0600                   .dbline 157
 0600           ;                       lcd_wrDat(' '&0xF0,(' '&0x0F)<<4);
 0600 2227              clr R18
 0602 00E2              ldi R16,32
 0604 00DF              xcall _lcd_wrDat
 0606                   .dbline 158
 0606           ;                       delay50us(40); 
 0606 08E2              ldi R16,40
 0608 10E0              ldi R17,0
 060A A8DE              xcall _delay50us
 060C                   .dbline 159
 060C           ;               }
 060C           L163:
 060C                   .dbline 155
 060C 4A95              dec R20
 060E           L165:
 060E                   .dbline 155
 060E 4030              cpi R20,0
 0610 BCF7              brge L162
 0612           X58:
 0612                   .dbline 160
 0612           ;       }
 0612           L160:
 0612                   .dbline 161
 0612           ;       for(i=effectLen-1;i>=0;i--)
 0612 462F              mov R20,R22
 0614 4150              subi R20,1
 0616 1EC0              xjmp L169
 0618           L166:
 0618                   .dbline 162
 0618           ;       {
 0618                   .dbline 163
 0618           ;               lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
 0618 80E0              ldi R24,<_dataElem
 061A 90E0              ldi R25,>_dataElem
 061C E42F              mov R30,R20
 061E FF27              clr R31
 0620 E7FD              sbrc R30,7
 0622 F095              com R31
 0624 E80F              add R30,R24
 0626 F91F              adc R31,R25
 0628 8081              ldd R24,z+0
 062A 9927              clr R25
 062C C096              adiw R24,48
 062E 9C01              movw R18,R24
 0630 2F70              andi R18,15
 0632 3070              andi R19,0
 0634 220F              lsl R18
 0636 331F              rol R19
 0638 220F              lsl R18
 063A 331F              rol R19
 063C 220F              lsl R18
 063E 331F              rol R19
 0640 220F              lsl R18
 0642 331F              rol R19
 0644 8C01              movw R16,R24
 0646 007F              andi R16,240
 0648 1070              andi R17,0
 064A DDDE              xcall _lcd_wrDat
 064C                   .dbline 164
 064C           ;               delay50us(40);
 064C 08E2              ldi R16,40
 064E 10E0              ldi R17,0
 0650 85DE              xcall _delay50us
 0652                   .dbline 165
 0652           ;       }
 0652           L167:
 0652                   .dbline 161
 0652 4A95              dec R20
 0654           L169:
 0654                   .dbline 161
 0654 4030              cpi R20,0
 0656 04F7              brge L166
 0658           X59:
 0658                   .dbline -2
 0658           L147:
 0658                   .dbline 0 ; func end
 0658 2196              adiw R28,1
 065A 0C940000          xjmp pop_xgsetF0FC
 065E                   .dbsym r effectLen 22 C
 065E                   .dbsym r i 20 C
 065E                   .dbsym r length 10 c
 065E                   .dbsym l dat 11 l
 065E                   .dbsym r y 14 c
 065E                   .dbsym r x 12 c
 065E                   .dbend
 065E                   .dbfunc e lcd_puts _lcd_puts fV
 065E           ;            str -> R20,R21
 065E           ;              y -> R12
 065E           ;              x -> R10
                        .even
 065E           _lcd_puts::
 065E 0E940000          xcall push_xgset303C
 0662 C22E              mov R12,R18
 0664 A02E              mov R10,R16
 0666 4E81              ldd R20,y+6
 0668 5F81              ldd R21,y+7
 066A                   .dbline -1
 066A                   .dbline 169
 066A           ; }
 066A           ; 
 066A           ; void lcd_puts(uint8 x,uint8 y,uint8 *str)
 066A           ; { 
 066A                   .dbline 170
 066A           ;       lcd_set_xy(x,y);
 066A 2C2D              mov R18,R12
 066C 0A2D              mov R16,R10
 066E D8DE              xcall _lcd_set_xy
 0670                   .dbline 171
 0670           ;       delay50us(20);   
 0670 04E1              ldi R16,20
 0672 10E0              ldi R17,0
 0674 73DE              xcall _delay50us
 0676 0FC0              xjmp L172
 0678           L171:
 0678                   .dbline 173
 0678           ;       while(*str)
 0678           ;       {
 0678                   .dbline 174
 0678           ;               lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
 0678 FA01              movw R30,R20
 067A 2080              ldd R2,z+0
 067C 3324              clr R3
 067E 222D              mov R18,R2
 0680 2F70              andi R18,15
 0682 2F70              andi R18,#0x0F
 0684 2295              swap R18
 0686 022D              mov R16,R2
 0688 007F              andi R16,240
 068A BDDE              xcall _lcd_wrDat
 068C                   .dbline 175
 068C           ;               str++;
 068C 4F5F              subi R20,255  ; offset = 1
 068E 5F4F              sbci R21,255
 0690                   .dbline 176
 0690           ;               delay50us(20);
 0690 04E1              ldi R16,20
 0692 10E0              ldi R17,0
 0694 63DE              xcall _delay50us
 0696                   .dbline 177
 0696           ;       } 
 0696           L172:
 0696                   .dbline 172
 0696 FA01              movw R30,R20
 0698 2080              ldd R2,z+0
 069A 2220              tst R2
 069C 69F7              brne L171
 069E           X60:
 069E                   .dbline -2
 069E           L170:
 069E                   .dbline 0 ; func end
 069E 0C940000          xjmp pop_xgset303C
 06A2                   .dbsym r str 20 pc
 06A2                   .dbsym r y 12 c
 06A2                   .dbsym r x 10 c
 06A2                   .dbend
 06A2                   .dbfunc e lcd_puts_ _lcd_puts_ fV
 06A2           ;          dlyMs -> R10
 06A2           ;            str -> R20,R21
 06A2           ;              y -> R14
 06A2           ;              x -> R12
                        .even
 06A2           _lcd_puts_::
 06A2 0E940000          xcall push_xgset30FC
 06A6 E22E              mov R14,R18
 06A8 C02E              mov R12,R16
 06AA 4885              ldd R20,y+8
 06AC 5985              ldd R21,y+9
 06AE AA84              ldd R10,y+10
 06B0                   .dbline -1
 06B0                   .dbline 181
 06B0           ; }
 06B0           ; 
 06B0           ; void lcd_puts_(uint8 x,uint8 y,uint8 *str,uint8 dlyMs)
 06B0           ; { 
 06B0                   .dbline 182
 06B0           ;       lcd_set_xy(x,y);
 06B0 2E2D              mov R18,R14
 06B2 0C2D              mov R16,R12
 06B4 B5DE              xcall _lcd_set_xy
 06B6                   .dbline 183
 06B6           ;       delay50us(20);   
 06B6 04E1              ldi R16,20
 06B8 10E0              ldi R17,0
 06BA 50DE              xcall _delay50us
 06BC 0FC0              xjmp L176
 06BE           L175:
 06BE                   .dbline 185
 06BE           ;       while(*str)
 06BE           ;       {
 06BE                   .dbline 186
 06BE           ;               lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
 06BE FA01              movw R30,R20
 06C0 2080              ldd R2,z+0
 06C2 3324              clr R3
 06C4 222D              mov R18,R2
 06C6 2F70              andi R18,15
 06C8 2F70              andi R18,#0x0F
 06CA 2295              swap R18
 06CC 022D              mov R16,R2
 06CE 007F              andi R16,240
 06D0 9ADE              xcall _lcd_wrDat
 06D2                   .dbline 187
 06D2           ;               str++;
 06D2 4F5F              subi R20,255  ; offset = 1
 06D4 5F4F              sbci R21,255
 06D6                   .dbline 188
 06D6           ;               delay50ms(dlyMs);
 06D6 0A2D              mov R16,R10
 06D8 1127              clr R17
 06DA 50DE              xcall _delay50ms
 06DC                   .dbline 189
 06DC           ;       } 
 06DC           L176:
 06DC                   .dbline 184
 06DC FA01              movw R30,R20
 06DE 2080              ldd R2,z+0
 06E0 2220              tst R2
 06E2 69F7              brne L175
 06E4           X61:
 06E4                   .dbline -2
 06E4           L174:
 06E4                   .dbline 0 ; func end
 06E4 0C940000          xjmp pop_xgset30FC
 06E8                   .dbsym r dlyMs 10 c
 06E8                   .dbsym r str 20 pc
 06E8                   .dbsym r y 14 c
 06E8                   .dbsym r x 12 c
 06E8                   .dbend
 06E8                   .dbfunc e lcd_clr _lcd_clr fV
                        .even
 06E8           _lcd_clr::
 06E8                   .dbline -1
 06E8                   .dbline 193
 06E8           ; }
 06E8           ; 
 06E8           ; void lcd_clr()
 06E8           ; {
 06E8                   .dbline 194
 06E8           ;       lcd_wrCmd(0x00,0x10);
 06E8 20E1              ldi R18,16
 06EA 0027              clr R16
 06EC 7FDE              xcall _lcd_wrCmd
 06EE                   .dbline 195
 06EE           ;       delay50us(200);
 06EE 08EC              ldi R16,200
 06F0 10E0              ldi R17,0
 06F2                   .dbline -2
 06F2           L178:
 06F2                   .dbline 0 ; func end
 06F2 34CE              xjmp _delay50us
 06F4                   .dbend
 06F4                   .dbfunc e lcd_init _lcd_init fV
                        .even
 06F4           _lcd_init::
 06F4                   .dbline -1
 06F4                   .dbline 199
 06F4           ; }
 06F4           ; 
 06F4           ; void lcd_init(void)
 06F4           ; {
 06F4                   .dbline 200
 06F4           ;       SPI_init();     
 06F4 6EDE              xcall _SPI_init
 06F6                   .dbline 203
 06F6           ;       //OUT_LCD_CS;           //若LCD_CS
 06F6           ;       //SET_LCD_CS;           
 06F6           ;       delay50ms(1);
 06F6 01E0              ldi R16,1
 06F8 10E0              ldi R17,0
 06FA 40DE              xcall _delay50ms
 06FC                   .dbline 204
 06FC           ;       lcd_wrCmd(0x30,0x30);   //使用8位控制界面,使用基本指令集
 06FC 20E3              ldi R18,48
 06FE 00E3              ldi R16,48
 0700 75DE              xcall _lcd_wrCmd
 0702                   .dbline 206
 0702           ;       //lcd_wrCmd(0x00,0xF0); //整体显示ON
 0702           ;       lcd_wrCmd(0x00,0xC0);   //整体显示ON
 0702 20EC              ldi R18,192
 0704 0027              clr R16
 0706 72DE              xcall _lcd_wrCmd
 0708                   .dbline 207
 0708           ;       lcd_wrCmd(0x00,0x10);   //清屏
 0708 20E1              ldi R18,16
 070A 0027              clr R16
 070C 6FDE              xcall _lcd_wrCmd
 070E                   .dbline 209
 070E           ;       //lcd_wrCmd(0x10,0x00); //光标
 070E           ;       lcd_wrCmd(0x00,0x60);
 070E 20E6              ldi R18,96
 0710 0027              clr R16
 0712 6CDE              xcall _lcd_wrCmd
 0714                   .dbline 211
 0714           ;       //lcd_wrCmd(0x00,0x70); //显示右移
 0714           ;       delay50ms(1);           //不可省去！！！
 0714 01E0              ldi R16,1
 0716 10E0              ldi R17,0
 0718                   .dbline -2
 0718           L179:
 0718                   .dbline 0 ; func end
 0718 31CE              xjmp _delay50ms
 071A                   .dbend
 071A                   .dbfile D:\ICC_H\PCF8563.H
 071A                   .dbfunc e WriteAByte _WriteAByte fc
 071A           ;            dat -> R12
 071A           ;        wordAdr -> R10
                        .even
 071A           _WriteAByte::
 071A AA92              st -y,R10
 071C CA92              st -y,R12
 071E C22E              mov R12,R18
 0720 A02E              mov R10,R16
 0722 2197              sbiw R28,1
 0724                   .dbline -1
 0724                   .dbline 89
 0724           ; /*********************************************************************
 0724           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0724           ;                                                                       
 0724           ; 目    的:   建立PCF8563操作库
 0724           ;       
 0724           ; 目标系统:   基于AVR单片机
 0724           ;                                                                               
 0724           ; 应用软件:   ICCAVR
 0724           ;                                                                               
 0724           ; 版    本:   Version 1.0                                                
 0724           ;                                                                               
 0724           ; 圆版时间:   2005-06-25
 0724           ;       
 0724           ; 开发人员:   SEE
 0724           ; 
 0724           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0724           ;       
 0724           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0724           ; *********************************************************************/
 0724           ; 
 0724           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0724           ; ----------------------------------------------------------------------
 0724           ; 版本更新记录：
 0724           ; 
 0724           ; ----------------------------------------------------------------------
 0724           ; 入口参数说明：
 0724           ;       //#define WR_DADR       0xA2    //器件地址：A2 A1 A0 = 0 0 0
 0724           ;       //#define RD_DADR       0xA3    //器件地址：A2 A1 A0 = 0 0 0
 0724           ; 
 0724           ; ----------------------------------------------------------------------
 0724           ; 待定参数说明：
 0724           ; 
 0724           ; ----------------------------------------------------------------------        
 0724           ; 对外变量说明：
 0724           ; 
 0724           ; ----------------------------------------------------------------------
 0724           ; 对外函数说明：
 0724           ; 
 0724           ; ----------------------------------------------------------------------
 0724           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 0724           ; 
 0724           ; #ifndef PCF8563_H
 0724           ; #define PCF8563_H
 0724           ; 
 0724           ; #include "D:\ICC_H\CmmICC.H"
 0724           ; #include "D:\ICC_H\I2C.H"
 0724           ; 
 0724           ; //器件地址：A0 A1 A2 = 0 0 0
 0724           ; #ifndef WR_DADR 
 0724           ;       #define WR_DADR         0xA2    //write device-address 
 0724           ; #endif
 0724           ; #ifndef RD_DADR 
 0724           ;       #define RD_DADR         0xA3    //read device-address
 0724           ; #endif
 0724           ; 
 0724           ; #define CTRL_BUF1             0x00
 0724           ; #define CTRL_BUF2             0x01
 0724           ; 
 0724           ; #define SECOND_DATA_BUF       0x02
 0724           ; #define MINUTE_DATA_BUF       0x03
 0724           ; #define HOUR_DATA_BUF 0x04
 0724           ; 
 0724           ; #define DAY_DATA_BUF  0x05
 0724           ; #define WEEK_DATA_BUF 0x06
 0724           ; #define MONTH_DATA_BUF        0x07
 0724           ; #define YEAR_DATA_BUF 0x08
 0724           ; 
 0724           ; #define MINUTE_AE_BUF 0x09
 0724           ; #define HOUR_AE_BUF           0x0A
 0724           ; #define DAY_AE_BUF            0x0B
 0724           ; #define WEEK_AE_BUF           0x0C
 0724           ; 
 0724           ; #define CLK_FRQ_BUF           0x0D
 0724           ; #define TIMER_CTRL_BUF        0x0E
 0724           ; #define COUNT_VAL_BUF 0x0F
 0724           ; 
 0724           ; #define PCF8563_ERR           0
 0724           ; #define PCF8563_CRR           1
 0724           ; 
 0724           ; /*--------------------------------------------------------------------
 0724           ; 函数名称：
 0724           ; 函数功能：写 1个 Byte 到相应的寄存器
 0724           ; 注意事项：
 0724           ; 提示说明：
 0724           ; 输    入：
 0724           ; 返    回：
 0724           ; --------------------------------------------------------------------*/
 0724           ; bool WriteAByte(uint8 wordAdr,uint8 dat)
 0724           ; {
 0724                   .dbline 90
 0724           ;       if( I2C_Write(WR_DADR,wordAdr,dat)==I2C_ERR )
 0724 C882              std y+0,R12
 0726 2A2D              mov R18,R10
 0728 02EA              ldi R16,162
 072A 10E0              ldi R17,0
 072C 78DD              xcall _I2C_Write
 072E 0023              tst R16
 0730 11F4              brne L181
 0732           X62:
 0732                   .dbline 91
 0732           ;               return I2C_ERR;
 0732 0027              clr R16
 0734 01C0              xjmp L180
 0736           L181:
 0736                   .dbline 92
 0736           ;       return I2C_CRR;
 0736 01E0              ldi R16,1
 0738                   .dbline -2
 0738           L180:
 0738                   .dbline 0 ; func end
 0738 2196              adiw R28,1
 073A C990              ld R12,y+
 073C A990              ld R10,y+
 073E 0895              ret
 0740                   .dbsym r dat 12 c
 0740                   .dbsym r wordAdr 10 c
 0740                   .dbend
 0740                   .dbfunc e ReadNByte _ReadNByte fc
 0740           ;            num -> R14
 0740           ;         pRdDat -> R12,R13
 0740           ;        wordAdr -> R10
                        .even
 0740           _ReadNByte::
 0740 0E940000          xcall push_xgset00FC
 0744 6901              movw R12,R18
 0746 A02E              mov R10,R16
 0748 2597              sbiw R28,5
 074A EB84              ldd R14,y+11
 074C                   .dbline -1
 074C                   .dbline 143
 074C           ; }
 074C           ; /*--------------------------------------------------------------------
 074C           ; 函数名称：
 074C           ; 函数功能：写 N个 Byte 到相应的寄存器
 074C           ; 注意事项：
 074C           ; 提示说明：
 074C           ; 输    入：
 074C           ; 返    回：
 074C           ; --------------------------------------------------------------------*/
 074C           ; //void WriteNByte(uint8 wordAdr,uint8 num,uint8 *pWrDat)
 074C           ; //{
 074C           ; //
 074C           ; //}
 074C           ; /*--------------------------------------------------------------------
 074C           ; 函数名称：
 074C           ; 函数功能：读 1个 Byte 到相应的寄存器
 074C           ; 注意事项：
 074C           ; 提示说明：
 074C           ; 输    入：
 074C           ; 返    回：
 074C           ; --------------------------------------------------------------------*/
 074C           ; //void ReadAByte(uint8 wordAdr,uint8 *pRdDat) 
 074C           ; //{  
 074C           ; //    I2C_Start();
 074C           ; //
 074C           ; //    I2C_SendByte(WR_DADR);                  
 074C           ; //    I2C_WaitAck();
 074C           ; //
 074C           ; //    I2C_SendByte(wordAdr);                  
 074C           ; //    I2C_WaitAck();
 074C           ; //
 074C           ; //    I2C_Start();
 074C           ; //
 074C           ; //    I2C_SendByte(RD_DADR);                  
 074C           ; //    I2C_WaitAck();
 074C           ; //
 074C           ; //    I2C_RcvByte(pRdDat);
 074C           ; //    I2C_SendNoAck();
 074C           ; //
 074C           ; //    I2C_Stop();
 074C           ; //}
 074C           ; /*--------------------------------------------------------------------
 074C           ; 函数名称：
 074C           ; 函数功能：读 N个 Byte 到相应的寄存器
 074C           ; 注意事项：
 074C           ; 提示说明：
 074C           ; 输    入：
 074C           ; 返    回：
 074C           ; --------------------------------------------------------------------*/
 074C           ; bool ReadNByte(uint8 wordAdr,uint8 *pRdDat,uint8 num)
 074C           ; {  
 074C                   .dbline 144
 074C           ;       if( I2C_Read_(WR_DADR,wordAdr,RD_DADR,pRdDat,num)==I2C_ERR )
 074C EC82              std y+4,R14
 074E DB82              std y+3,R13
 0750 CA82              std y+2,R12
 0752 83EA              ldi R24,163
 0754 8883              std y+0,R24
 0756 2A2D              mov R18,R10
 0758 02EA              ldi R16,162
 075A 10E0              ldi R17,0
 075C B7DD              xcall _I2C_Read_
 075E 0023              tst R16
 0760 11F4              brne L184
 0762           X63:
 0762                   .dbline 145
 0762           ;               return I2C_ERR;
 0762 0027              clr R16
 0764 01C0              xjmp L183
 0766           L184:
 0766                   .dbline 146
 0766           ;       return I2C_CRR;
 0766 01E0              ldi R16,1
 0768                   .dbline -2
 0768           L183:
 0768                   .dbline 0 ; func end
 0768 2596              adiw R28,5
 076A 0C940000          xjmp pop_xgset00FC
 076E                   .dbsym r num 14 c
 076E                   .dbsym r pRdDat 12 pc
 076E                   .dbsym r wordAdr 10 c
 076E                   .dbend
 076E                   .dbfunc e PCF8563_getTime _PCF8563_getTime fV
 076E           ;            buf -> R20,R21
                        .even
 076E           _PCF8563_getTime::
 076E 0E940000          xcall push_xgsetF00C
 0772 A801              movw R20,R16
 0774 2197              sbiw R28,1
 0776                   .dbline -1
 0776                   .dbline 157
 0776           ; }
 0776           ; /*--------------------------------------------------------------------
 0776           ; 函数名称：
 0776           ; 函数功能：获取PCF8563的时间
 0776           ; 注意事项：
 0776           ; 提示说明：
 0776           ; 输    入：
 0776           ; 返    回：
 0776           ; --------------------------------------------------------------------*/
 0776           ; void PCF8563_getTime(uint8 *buf)
 0776           ; {
 0776           L187:
 0776                   .dbline 159
 0776           ; ReadAgain:    
 0776           ;       ReadNByte(SECOND_DATA_BUF,buf,3);
 0776 83E0              ldi R24,3
 0778 8883              std y+0,R24
 077A 9A01              movw R18,R20
 077C 02E0              ldi R16,2
 077E E0DF              xcall _ReadNByte
 0780                   .dbline 160
 0780           ;       buf[0]=buf[0]&0x7f;             //get second data
 0780 FA01              movw R30,R20
 0782 8081              ldd R24,z+0
 0784 8F77              andi R24,127
 0786 8083              std z+0,R24
 0788                   .dbline 161
 0788           ;       if(buf[0]==0)
 0788 2080              ldd R2,z+0
 078A 2220              tst R2
 078C 09F4              brne L188
 078E           X64:
 078E                   .dbline 162
 078E           ;               goto ReadAgain;         //if "second==0"，read again for avoid mistake
 078E F3CF              xjmp L187
 0790           L188:
 0790                   .dbline 163
 0790           ;       buf[1]=buf[1]&0x7f;             //get minute data
 0790 CA01              movw R24,R20
 0792 0196              adiw R24,1
 0794 FC01              movw R30,R24
 0796 8081              ldd R24,z+0
 0798 8F77              andi R24,127
 079A 8083              std z+0,R24
 079C                   .dbline 164
 079C           ;       buf[2]=buf[2]&0x3f;             //get hour data
 079C CA01              movw R24,R20
 079E 0296              adiw R24,2
 07A0 FC01              movw R30,R24
 07A2 8081              ldd R24,z+0
 07A4 8F73              andi R24,63
 07A6 8083              std z+0,R24
 07A8                   .dbline 166
 07A8           ; 
 07A8           ;       buf[0]=changeHexToInt(buf[0]);
 07A8 FA01              movw R30,R20
 07AA A080              ldd R10,z+0
 07AC BB24              clr R11
 07AE 10E1              ldi R17,16
 07B0 0A2D              mov R16,R10
 07B2 0E940000          xcall mod8u
 07B6 202E              mov R2,R16
 07B8 1A2D              mov R17,R10
 07BA 1295              swap R17
 07BC 1F70              andi R17,#0x0F
 07BE 0AE0              ldi R16,10
 07C0 0103              mulsu R16,R17
 07C2 302C              mov R3,R0
 07C4 320C              add R3,R2
 07C6 FA01              movw R30,R20
 07C8 3082              std z+0,R3
 07CA                   .dbline 167
 07CA           ;       buf[1]=changeHexToInt(buf[1]);
 07CA BF01              movw R22,R30
 07CC 6F5F              subi R22,255  ; offset = 1
 07CE 7F4F              sbci R23,255
 07D0 FB01              movw R30,R22
 07D2 A080              ldd R10,z+0
 07D4 BB24              clr R11
 07D6 10E1              ldi R17,16
 07D8 0A2D              mov R16,R10
 07DA 0E940000          xcall mod8u
 07DE 202E              mov R2,R16
 07E0 1A2D              mov R17,R10
 07E2 1295              swap R17
 07E4 1F70              andi R17,#0x0F
 07E6 0AE0              ldi R16,10
 07E8 0103              mulsu R16,R17
 07EA 302C              mov R3,R0
 07EC 320C              add R3,R2
 07EE FB01              movw R30,R22
 07F0 3082              std z+0,R3
 07F2                   .dbline 168
 07F2           ;       buf[2]=changeHexToInt(buf[2]);
 07F2 4E5F              subi R20,254  ; offset = 2
 07F4 5F4F              sbci R21,255
 07F6 FA01              movw R30,R20
 07F8 A080              ldd R10,z+0
 07FA BB24              clr R11
 07FC 10E1              ldi R17,16
 07FE 0A2D              mov R16,R10
 0800 0E940000          xcall mod8u
 0804 202E              mov R2,R16
 0806 1A2D              mov R17,R10
 0808 1295              swap R17
 080A 1F70              andi R17,#0x0F
 080C 0AE0              ldi R16,10
 080E 0103              mulsu R16,R17
 0810 302C              mov R3,R0
 0812 320C              add R3,R2
 0814 FA01              movw R30,R20
 0816 3082              std z+0,R3
 0818                   .dbline -2
 0818           L186:
 0818                   .dbline 0 ; func end
 0818 2196              adiw R28,1
 081A 0C940000          xjmp pop_xgsetF00C
 081E                   .dbsym r buf 20 pc
 081E                   .dbend
 081E                   .dbfunc e PCF8563_setTime _PCF8563_setTime fV
 081E           ;         second -> R10
 081E           ;         minute -> R12
 081E           ;           hour -> R14
                        .even
 081E           _PCF8563_setTime::
 081E 0E940000          xcall push_xgset00FC
 0822 C22E              mov R12,R18
 0824 E02E              mov R14,R16
 0826 AE80              ldd R10,y+6
 0828                   .dbline -1
 0828                   .dbline 179
 0828           ; }
 0828           ; /*--------------------------------------------------------------------
 0828           ; 函数名称：
 0828           ; 函数功能：设置PCF8563的时间
 0828           ; 注意事项：
 0828           ; 提示说明：
 0828           ; 输    入：
 0828           ; 返    回：
 0828           ; --------------------------------------------------------------------*/
 0828           ; void PCF8563_setTime(uint8 hour,uint8 minute,uint8 second)
 0828           ; {
 0828                   .dbline 180
 0828           ;       hour=changeIntToHex(hour);              //将数据的Dex格式转换为Hex格式
 0828 1AE0              ldi R17,10
 082A 0E2D              mov R16,R14
 082C 0E940000          xcall mod8u
 0830 202E              mov R2,R16
 0832 1AE0              ldi R17,10
 0834 0E2D              mov R16,R14
 0836 0E940000          xcall div8u
 083A 802F              mov R24,R16
 083C 8F70              andi R24,#0x0F
 083E 8295              swap R24
 0840 E82E              mov R14,R24
 0842 E20C              add R14,R2
 0844                   .dbline 181
 0844           ;       minute=changeIntToHex(minute);
 0844 1AE0              ldi R17,10
 0846 0C2D              mov R16,R12
 0848 0E940000          xcall mod8u
 084C 202E              mov R2,R16
 084E 1AE0              ldi R17,10
 0850 0C2D              mov R16,R12
 0852 0E940000          xcall div8u
 0856 802F              mov R24,R16
 0858 8F70              andi R24,#0x0F
 085A 8295              swap R24
 085C C82E              mov R12,R24
 085E C20C              add R12,R2
 0860                   .dbline 182
 0860           ;       second=changeIntToHex(second);
 0860 1AE0              ldi R17,10
 0862 0A2D              mov R16,R10
 0864 0E940000          xcall mod8u
 0868 202E              mov R2,R16
 086A 1AE0              ldi R17,10
 086C 0A2D              mov R16,R10
 086E 0E940000          xcall div8u
 0872 802F              mov R24,R16
 0874 8F70              andi R24,#0x0F
 0876 8295              swap R24
 0878 A82E              mov R10,R24
 087A A20C              add R10,R2
 087C                   .dbline 184
 087C           ; 
 087C           ;       WriteAByte(HOUR_DATA_BUF,hour);
 087C 2E2D              mov R18,R14
 087E 04E0              ldi R16,4
 0880 4CDF              xcall _WriteAByte
 0882                   .dbline 185
 0882           ;       WriteAByte(MINUTE_DATA_BUF,minute);
 0882 2C2D              mov R18,R12
 0884 03E0              ldi R16,3
 0886 49DF              xcall _WriteAByte
 0888                   .dbline 186
 0888           ;       WriteAByte(SECOND_DATA_BUF,second);
 0888 2A2D              mov R18,R10
 088A 02E0              ldi R16,2
 088C 46DF              xcall _WriteAByte
 088E                   .dbline -2
 088E           L190:
 088E                   .dbline 0 ; func end
 088E 0C940000          xjmp pop_xgset00FC
 0892                   .dbsym r second 10 c
 0892                   .dbsym r minute 12 c
 0892                   .dbsym r hour 14 c
 0892                   .dbend
 0892                   .dbfunc e PCF8563_init _PCF8563_init fV
                        .even
 0892           _PCF8563_init::
 0892                   .dbline -1
 0892                   .dbline 221
 0892           ; }
 0892           ; /*--------------------------------------------------------------------
 0892           ; 函数名称：
 0892           ; 函数功能：获取PCF8563的日期
 0892           ; 注意事项：
 0892           ; 提示说明：
 0892           ; 输    入：
 0892           ; 返    回：
 0892           ; --------------------------------------------------------------------*/
 0892           ; //void PCF8563_getDate()
 0892           ; //{
 0892           ; //
 0892           ; //}
 0892           ; /*--------------------------------------------------------------------
 0892           ; 函数名称：
 0892           ; 函数功能：设置PCF8563的日期
 0892           ; 注意事项：
 0892           ; 提示说明：
 0892           ; 输    入：
 0892           ; 返    回：
 0892           ; --------------------------------------------------------------------*/
 0892           ; //void PCF8563_setDate()
 0892           ; //{
 0892           ; //
 0892           ; //}
 0892           ; /*--------------------------------------------------------------------
 0892           ; 函数名称：
 0892           ; 函数功能：初始化PCF8563
 0892           ; 注意事项：
 0892           ; 提示说明：
 0892           ; 输    入：
 0892           ; 返    回：
 0892           ; --------------------------------------------------------------------*/
 0892           ; void PCF8563_init()
 0892           ; {
 0892                   .dbline 222
 0892           ;       WriteAByte(CTRL_BUF1,0x00);                     //basic setting
 0892 2227              clr R18
 0894 0027              clr R16
 0896 41DF              xcall _WriteAByte
 0898                   .dbline 223
 0898           ;       WriteAByte(CTRL_BUF2,0x12);                     //alarm enable
 0898 22E1              ldi R18,18
 089A 01E0              ldi R16,1
 089C                   .dbline -2
 089C           L191:
 089C                   .dbline 0 ; func end
 089C 3ECF              xjmp _WriteAByte
 089E                   .dbend
 089E                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563_LCD12864\PCF8563.C
 089E                   .dbfunc e errDisp _errDisp fV
                        .even
 089E           _errDisp::
 089E                   .dbline -1
 089E                   .dbline 64
 089E           ; /*********************************************************************
 089E           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 089E           ;                                                                           
 089E           ; 项目名称:   PCF8563示例程序
 089E           ;               
 089E           ; 目标系统:   “DVK501” && “M128 EX+”
 089E           ; 
 089E           ; 应用软件:   ICCAVR 6.31A                                             
 089E           ;                                                                               
 089E           ; 版    本:   V1.0 
 089E           ;                                                         
 089E           ; 圆版时间:   2009-7-1
 089E           ; 
 089E           ; 开发人员:   zz
 089E           ; 
 089E           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 089E           ;               
 089E           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 089E           ; *********************************************************************/
 089E           ; 
 089E           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 089E           ; ----------------------------------------------------------------------
 089E           ; 版本更新记录：
 089E           ; 
 089E           ; ----------------------------------------------------------------------
 089E           ; 实验内容：
 089E           ; 使用DVK501的LCD12864显示屏查看PCF8563反馈的时间
 089E           ; ----------------------------------------------------------------------
 089E           ; 硬件连接： 
 089E           ;                         DVK501                                 M128 EX+
 089E           ;                               B1          ---------     SDA
 089E           ;                               B2          ---------     SCL
 089E           ;                               
 089E           ;                               CS              ---------         VCC
 089E           ;                               PSB         ---------     GND
 089E           ;                               SID             ---------         PB2
 089E           ;                               CLK             ---------         PB1
 089E           ; ----------------------------------------------------------------------
 089E           ; 注意事项：
 089E           ; （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
 089E           ; （2）请详细阅读“使用必读”及相关资料。
 089E           ; ----------------------------------------------------------------------
 089E           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 089E           ; 
 089E           ; #include <iom128v.h>
 089E           ; #include "D:\ICC_H\LCD12864_ST7920_.H"
 089E           ; 
 089E           ; #define WR_DADR               0xA2
 089E           ; #define RD_DADR               0xA3
 089E           ; #include "D:\ICC_H\PCF8563.H"
 089E           ; 
 089E           ; #define DISP_DDR      DDRA
 089E           ; #define DISP_PORT     PORTA
 089E           ; 
 089E           ; /*--------------------------------------------------------------------
 089E           ; 函数全称：
 089E           ; 函数功能：
 089E           ; 注意事项：
 089E           ; 提示说明：
 089E           ; 输    入：
 089E           ; 返    回：
 089E           ; --------------------------------------------------------------------*/
 089E           ; void errDisp()                        //错误显示
 089E           ; {
 089E                   .dbline 65
 089E           ;       DISP_PORT = 0XAA;
 089E 8AEA              ldi R24,170
 08A0 8BBB              out 0x1b,R24
 08A2                   .dbline 66
 08A2           ;       delay50ms(2);
 08A2 02E0              ldi R16,2
 08A4 10E0              ldi R17,0
 08A6 6ADD              xcall _delay50ms
 08A8                   .dbline 67
 08A8           ;       DISP_PORT = 0X00;
 08A8 2224              clr R2
 08AA 2BBA              out 0x1b,R2
 08AC                   .dbline 68
 08AC           ;       delay50ms(2);
 08AC 02E0              ldi R16,2
 08AE 10E0              ldi R17,0
 08B0 65DD              xcall _delay50ms
 08B2                   .dbline 69
 08B2           ;       DISP_PORT = 0X55;
 08B2 85E5              ldi R24,85
 08B4 8BBB              out 0x1b,R24
 08B6                   .dbline 70
 08B6           ;       delay50ms(2);
 08B6 02E0              ldi R16,2
 08B8 10E0              ldi R17,0
 08BA 60DD              xcall _delay50ms
 08BC                   .dbline 71
 08BC           ;       DISP_PORT = 0X00;
 08BC 2224              clr R2
 08BE 2BBA              out 0x1b,R2
 08C0                   .dbline 72
 08C0           ;       delay50ms(2);
 08C0 02E0              ldi R16,2
 08C2 10E0              ldi R17,0
 08C4                   .dbline -2
 08C4           L192:
 08C4                   .dbline 0 ; func end
 08C4 5BCD              xjmp _delay50ms
 08C6                   .dbend
 08C6                   .dbfunc e twi_init _twi_init fV
                        .even
 08C6           _twi_init::
 08C6                   .dbline -1
 08C6                   .dbline 83
 08C6           ; }
 08C6           ; /*--------------------------------------------------------------------
 08C6           ; 函数全称：
 08C6           ; 函数功能：
 08C6           ; 注意事项：
 08C6           ; 提示说明：假设系统时钟为16M，则TWI波特率=CLK/(16+2*(TWBR)*4)=400K
 08C6           ; 输    入：
 08C6           ; 返    回：
 08C6           ; --------------------------------------------------------------------*/
 08C6           ; void twi_init()                       //TWI(I2C)初始化
 08C6           ; {
 08C6                   .dbline 84
 08C6           ;       TWBR = 0X03;            //设置TWI波特率  
 08C6 83E0              ldi R24,3
 08C8 80937000          sts 112,R24
 08CC                   .dbline 85
 08CC           ;       TWSR &= 0XFC;           //设置TWI预分频 为 1
 08CC 80917100          lds R24,113
 08D0 8C7F              andi R24,252
 08D2 80937100          sts 113,R24
 08D6                   .dbline -2
 08D6           L193:
 08D6                   .dbline 0 ; func end
 08D6 0895              ret
 08D8                   .dbend
 08D8                   .dbfunc e main _main fV
 08D8           ;       time_tmp -> R10
 08D8           ;           time -> y+5
                        .even
 08D8           _main::
 08D8 2897              sbiw R28,8
 08DA                   .dbline -1
 08DA                   .dbline 96
 08DA           ; }
 08DA           ; /*--------------------------------------------------------------------
 08DA           ; 函数全称：
 08DA           ; 函数功能：
 08DA           ; 注意事项：
 08DA           ; 提示说明：
 08DA           ; 输    入：
 08DA           ; 返    回：
 08DA           ; --------------------------------------------------------------------*/
 08DA           ; void main()
 08DA           ; {
 08DA                   .dbline 99
 08DA           ;       uint8 time[3],time_tmp;
 08DA           ;       
 08DA           ;       DDRF=0xFF;
 08DA 8FEF              ldi R24,255
 08DC 80936100          sts 97,R24
 08E0                   .dbline 100
 08E0           ;       PORTF|=0x01;
 08E0 80916200          lds R24,98
 08E4 8160              ori R24,1
 08E6 80936200          sts 98,R24
 08EA                   .dbline 102
 08EA           ; 
 08EA           ;       PCF8563_init();
 08EA D3DF              xcall _PCF8563_init
 08EC                   .dbline 103
 08EC           ;       PCF8563_setTime(1,2,3); 
 08EC 83E0              ldi R24,3
 08EE 8883              std y+0,R24
 08F0 22E0              ldi R18,2
 08F2 01E0              ldi R16,1
 08F4 94DF              xcall _PCF8563_setTime
 08F6                   .dbline 105
 08F6           ;       
 08F6           ;       lcd_init();
 08F6 FEDE              xcall _lcd_init
 08F8                   .dbline 106
 08F8           ;       lcd_clr();
 08F8 F7DE              xcall _lcd_clr
 08FA                   .dbline 107
 08FA           ;       lcd_puts(1,1,"PCF8563-LCD12864");
 08FA 80E0              ldi R24,<L195
 08FC 90E0              ldi R25,>L195
 08FE 9983              std y+1,R25
 0900 8883              std y+0,R24
 0902 21E0              ldi R18,1
 0904 01E0              ldi R16,1
 0906 ABDE              xcall _lcd_puts
 0908                   .dbline 108
 0908           ;       lcd_puts(2,1,"时间芯片测试");
 0908 80E0              ldi R24,<L196
 090A 90E0              ldi R25,>L196
 090C 9983              std y+1,R25
 090E 8883              std y+0,R24
 0910 21E0              ldi R18,1
 0912 02E0              ldi R16,2
 0914 A4DE              xcall _lcd_puts
 0916                   .dbline 109
 0916           ;       lcd_puts(3,1,"时间:");
 0916 80E0              ldi R24,<L197
 0918 90E0              ldi R25,>L197
 091A 9983              std y+1,R25
 091C 8883              std y+0,R24
 091E 21E0              ldi R18,1
 0920 03E0              ldi R16,3
 0922 9DDE              xcall _lcd_puts
 0924 53C0              xjmp L199
 0926           L198:
 0926                   .dbline 112
 0926           ; 
 0926           ;       while(1)
 0926           ;       {
 0926                   .dbline 113
 0926           ;                       PCF8563_getTime(time);
 0926 8E01              movw R16,R28
 0928 0B5F              subi R16,251  ; offset = 5
 092A 1F4F              sbci R17,255
 092C 20DF              xcall _PCF8563_getTime
 092E                   .dbline 115
 092E           ;                       
 092E           ;                       if(time[0]!=time_tmp)
 092E 2D80              ldd R2,y+5
 0930 2A14              cp R2,R10
 0932 09F4              brne X68
 0934 48C0              xjmp L201
 0936           X68:
 0936           X65:
 0936                   .dbline 116
 0936           ;                       {
 0936                   .dbline 118
 0936           ;                               
 0936           ;                               if(time[0]==0) lcd_puts(4,6,"0 ");
 0936 2220              tst R2
 0938 39F4              brne L203
 093A           X66:
 093A                   .dbline 118
 093A 80E0              ldi R24,<L205
 093C 90E0              ldi R25,>L205
 093E 9983              std y+1,R25
 0940 8883              std y+0,R24
 0942 26E0              ldi R18,6
 0944 04E0              ldi R16,4
 0946 8BDE              xcall _lcd_puts
 0948           L203:
 0948                   .dbline 120
 0948           ;                               
 0948           ;                               lcd_putd(4,6,time[0],2);
 0948 82E0              ldi R24,2
 094A 8C83              std y+4,R24
 094C 2D80              ldd R2,y+5
 094E 3324              clr R3
 0950 4424              clr R4
 0952 5524              clr R5
 0954 2882              std y+0,R2
 0956 3982              std y+1,R3
 0958 4A82              std y+2,R4
 095A 5B82              std y+3,R5
 095C 26E0              ldi R18,6
 095E 04E0              ldi R16,4
 0960 D5DD              xcall _lcd_putd
 0962                   .dbline 121
 0962           ;                               lcd_putd(4,2,time[2],2);
 0962 82E0              ldi R24,2
 0964 8C83              std y+4,R24
 0966 2F80              ldd R2,y+7
 0968 3324              clr R3
 096A 4424              clr R4
 096C 5524              clr R5
 096E 2882              std y+0,R2
 0970 3982              std y+1,R3
 0972 4A82              std y+2,R4
 0974 5B82              std y+3,R5
 0976 22E0              ldi R18,2
 0978 04E0              ldi R16,4
 097A C8DD              xcall _lcd_putd
 097C                   .dbline 122
 097C           ;                               lcd_putc(4,3,':');
 097C 8AE3              ldi R24,58
 097E 8883              std y+0,R24
 0980 23E0              ldi R18,3
 0982 04E0              ldi R16,4
 0984 78DD              xcall _lcd_putc
 0986                   .dbline 123
 0986           ;                               lcd_putd(4,4,time[1],2);
 0986 82E0              ldi R24,2
 0988 8C83              std y+4,R24
 098A 2E80              ldd R2,y+6
 098C 3324              clr R3
 098E 4424              clr R4
 0990 5524              clr R5
 0992 2882              std y+0,R2
 0994 3982              std y+1,R3
 0996 4A82              std y+2,R4
 0998 5B82              std y+3,R5
 099A 24E0              ldi R18,4
 099C 04E0              ldi R16,4
 099E B6DD              xcall _lcd_putd
 09A0                   .dbline 124
 09A0           ;                               lcd_putc(4,5,':');
 09A0 8AE3              ldi R24,58
 09A2 8883              std y+0,R24
 09A4 25E0              ldi R18,5
 09A6 04E0              ldi R16,4
 09A8 66DD              xcall _lcd_putc
 09AA                   .dbline 125
 09AA           ;                               lcd_putd(4,6,time[0],2);
 09AA 82E0              ldi R24,2
 09AC 8C83              std y+4,R24
 09AE 2D80              ldd R2,y+5
 09B0 3324              clr R3
 09B2 4424              clr R4
 09B4 5524              clr R5
 09B6 2882              std y+0,R2
 09B8 3982              std y+1,R3
 09BA 4A82              std y+2,R4
 09BC 5B82              std y+3,R5
 09BE 26E0              ldi R18,6
 09C0 04E0              ldi R16,4
 09C2 A4DD              xcall _lcd_putd
 09C4                   .dbline 126
 09C4           ;                               time_tmp=time[0];
 09C4 AD80              ldd R10,y+5
 09C6                   .dbline 127
 09C6           ;                       }
 09C6           L201:
 09C6                   .dbline 128
 09C6           ;                       delay50ms(5);
 09C6 05E0              ldi R16,5
 09C8 10E0              ldi R17,0
 09CA D8DC              xcall _delay50ms
 09CC                   .dbline 129
 09CC           ;       }
 09CC           L199:
 09CC                   .dbline 111
 09CC ACCF              xjmp L198
 09CE           X67:
 09CE                   .dbline -2
 09CE           L194:
 09CE                   .dbline 0 ; func end
 09CE 2896              adiw R28,8
 09D0 0895              ret
 09D2                   .dbsym r time_tmp 10 c
 09D2                   .dbsym l time 5 A[3:3]c
 09D2                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563_LCD12864\PCF8563.C
 0000           _dataElem::
 0000                   .blkb 6
 0006                   .dbfile D:\ICC_H\Software.H
 0006                   .dbsym e dataElem _dataElem A[6:6]c
                        .area data(ram, con, rel)
 0000                   .dbfile D:\ICC_H\Software.H
 0000           L205:
 0000                   .blkb 3
                        .area idata
 0000 302000            .byte 48,32,0
                        .area data(ram, con, rel)
 0003                   .dbfile D:\ICC_H\Software.H
 0003           L197:
 0003                   .blkb 6
                        .area idata
 0003 CAB1BCE43A00      .byte 202,177,188,228,58,0
                        .area data(ram, con, rel)
 0009                   .dbfile D:\ICC_H\Software.H
 0009           L196:
 0009                   .blkb 13
                        .area idata
 0009 CAB1BCE4D0BEC6ACB2E2CAD400        .byte 202,177,188,228,208,190,198,172,178,226,202,212,0
                        .area data(ram, con, rel)
 0016                   .dbfile D:\ICC_H\Software.H
 0016           L195:
 0016                   .blkb 17
                        .area idata
 0016 504346383536332D4C43443132383634  .byte 'P,'C,'F,56,53,54,51,45,'L,'C,'D,49,50,56,54,52
 0026 00                .byte 0
                        .area data(ram, con, rel)
 0027                   .dbfile D:\ICC_H\Software.H
 0027           ; }
