                        .module PCF8563.C
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\..\M128_E~1\PCF856~1\PCF8563\PCF8563.C
 0000                   .dbfile D:\ICC_H\Software.H
 0000                   .dbfunc e speaData _speaData fV
 0000           ;              y -> y+4
 0000           ;              j -> y+0
 0000           ;              i -> R10
 0000           ;            len -> R12
 0000           ;            dat -> y+16
                        .even
 0000           _speaData::
 0000 0E940000          xcall push_arg4
 0004 0E940000          xcall push_xgsetF03C
 0008 2897              sbiw R28,8
 000A CC88              ldd R12,y+20
 000C                   .dbline -1
 000C                   .dbline 116
 000C           ; /*********************************************************************
 000C           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 000C           ;                                                                       
 000C           ; 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
 000C           ;       
 000C           ; 目标系统:   基于AVR单片机
 000C           ;                                                                               
 000C           ; 应用软件:   ICCAVR
 000C           ;                                                                               
 000C           ; 版    本:   Version 1.0                                                       
 000C           ;                                                                               
 000C           ; 圆版时间:   2005-06-25
 000C           ;       
 000C           ; 开发人员:   SEE
 000C           ; 
 000C           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 000C           ;       
 000C           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 000C           ; *********************************************************************/
 000C           ; 
 000C           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 000C           ; ----------------------------------------------------------------------
 000C           ; 版本更新记录：
 000C           ; 
 000C           ; ----------------------------------------------------------------------
 000C           ; 入口参数说明：
 000C           ; 
 000C           ; ----------------------------------------------------------------------
 000C           ; 待定参数说明：
 000C           ; 
 000C           ; ----------------------------------------------------------------------        
 000C           ; 对外变量说明：
 000C           ;     
 000C           ; ----------------------------------------------------------------------
 000C           ; 对外函数说明：
 000C           ;    
 000C           ; ----------------------------------------------------------------------
 000C           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 000C           ; 
 000C           ; #ifndef Software_H
 000C           ; #define Software_H
 000C           ; 
 000C           ; #include <math.h>
 000C           ; #include <string.h>
 000C           ; 
 000C           ; /* 兼容一般程序员的常用写法 */
 000C           ; typedef unsigned char uchar;
 000C           ; typedef unsigned int  uint;
 000C           ; typedef unsigned long ulong;
 000C           ; typedef signed char           schar;
 000C           ; typedef signed int            sint;
 000C           ; typedef signed long           slong;
 000C           ; 
 000C           ; /* 为方便移植，建议使用下面写法 */
 000C           ; typedef unsigned char bool;
 000C           ; typedef unsigned char uint8;
 000C           ; typedef unsigned int  uint16;
 000C           ; typedef unsigned long   uint32;
 000C           ; typedef signed  char  sint8;
 000C           ; typedef signed        int             sint16;
 000C           ; typedef signed        long    sint32;
 000C           ; typedef signed  char  int8;
 000C           ; typedef signed  int           int16;
 000C           ; typedef signed  long  int32;
 000C           ; 
 000C           ; /* 下面写法一般不推荐 */
 000C           ; //typedef unsigned char ubyte;
 000C           ; //typedef unsigned int        uword;
 000C           ; //typedef unsigned long udword;
 000C           ; //typedef signed   char       sbyte;
 000C           ; //typedef signed   int        sword;
 000C           ; //typedef signed   long       sdword;
 000C           ; 
 000C           ; /* 一般程序定义的默认值 */
 000C           ; //#define NULL                        0
 000C           ; //#define EOF                 -1
 000C           ; //#define TRUE                1
 000C           ; //#define FALSE               0
 000C           ; //#define YES                 1
 000C           ; //#define NO                          0
 000C           ; //#define ON                  1
 000C           ; //#define OFF                 0
 000C           ; //#define ENABLE              1
 000C           ; //#define DISABLE             0
 000C           ; //#define CRR                 1
 000C           ; //#define ERR                 0
 000C           ; //#define RIGHT                       1
 000C           ; //#define WRONG                       0
 000C           ; //#define SUCCESS             1
 000C           ; //#define FAILURE             0
 000C           ; //#define PI                  3.1415926       //3.1415926535897932
 000C           ; 
 000C           ; /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
 000C           ; //#define _CALLOC(a)          ( (a *)calloc(n,sizeof(a)) )
 000C           ; //#define _MALLOC(a)          ( (a *)malloc(sizeof(a)) )
 000C           ; //#define _MIN(a,b)                   ( (a) < (b) ? (a) : (b) )
 000C           ; //#define _MAX(a,b)                   ( (a) > (b) ? (a) : (b) )
 000C           ; //#define _EXCHANGE(a,b)      { int t; t=a; a=b; b=t; }
 000C           ; //#define _TOLOWER(c)         ( (c)+32 )
 000C           ; //#define _TOUPPER(c)         ( (c)-32 )
 000C           ; 
 000C           ; //#ifndef BIT
 000C           ; //#define BIT(x)      ( 1<<(x) )
 000C           ; //#endif
 000C           ; 
 000C           ; /*--------------------------------------------------------------------
 000C           ; 函数全称：数据拆字
 000C           ; 函数功能：
 000C           ; 注意事项：D<=999999,C<=6
 000C           ; 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
 000C           ; 输    入：
 000C           ; 返    回：无
 000C           ; --------------------------------------------------------------------*/
 000C           ; uint8 dataElem[6];
 000C           ; void speaData(uint32 dat,sint8 len)
 000C           ; {
 000C                   .dbline 119
 000C           ;     uint8 i;
 000C           ;     uint32 j,y;
 000C           ;     for(i=0,j=1;i<len;i++)
 000C AA24              clr R10
 000E 81E0              ldi R24,1
 0010 8883              std y+0,R24
 0012 80E0              ldi R24,0
 0014 8983              std y+1,R24
 0016 8A83              std y+2,R24
 0018 8B83              std y+3,R24
 001A 3CC0              xjmp L5
 001C           L2:
 001C                   .dbline 120
 001C           ;     {
 001C                   .dbline 121
 001C           ;         y=dat/j;
 001C 2880              ldd R2,y+0
 001E 3980              ldd R3,y+1
 0020 4A80              ldd R4,y+2
 0022 5B80              ldd R5,y+3
 0024 0889              ldd R16,y+16
 0026 1989              ldd R17,y+17
 0028 2A89              ldd R18,y+18
 002A 3B89              ldd R19,y+19
 002C 5A92              st -y,R5
 002E 4A92              st -y,R4
 0030 3A92              st -y,R3
 0032 2A92              st -y,R2
 0034 0E940000          xcall div32u
 0038 0C83              std y+4,R16
 003A 1D83              std y+5,R17
 003C 2E83              std y+6,R18
 003E 3F83              std y+7,R19
 0040                   .dbline 122
 0040           ;         dataElem[i]=y%10;
 0040 4AE0              ldi R20,10
 0042 50E0              ldi R21,0
 0044 60E0              ldi R22,0
 0046 70E0              ldi R23,0
 0048 0C81              ldd R16,y+4
 004A 1D81              ldd R17,y+5
 004C 2E81              ldd R18,y+6
 004E 3F81              ldd R19,y+7
 0050 7A93              st -y,R23
 0052 6A93              st -y,R22
 0054 5A93              st -y,R21
 0056 4A93              st -y,R20
 0058 0E940000          xcall mod32u
 005C 80E0              ldi R24,<_dataElem
 005E 90E0              ldi R25,>_dataElem
 0060 EA2D              mov R30,R10
 0062 FF27              clr R31
 0064 E80F              add R30,R24
 0066 F91F              adc R31,R25
 0068 0083              std z+0,R16
 006A                   .dbline 123
 006A           ;         j*=10;
 006A 2880              ldd R2,y+0
 006C 3980              ldd R3,y+1
 006E 4A80              ldd R4,y+2
 0070 5B80              ldd R5,y+3
 0072 4AE0              ldi R20,10
 0074 50E0              ldi R21,0
 0076 60E0              ldi R22,0
 0078 70E0              ldi R23,0
 007A 5A92              st -y,R5
 007C 4A92              st -y,R4
 007E 3A92              st -y,R3
 0080 2A92              st -y,R2
 0082 8A01              movw R16,R20
 0084 9B01              movw R18,R22
 0086 0E940000          xcall empy32u
 008A 0883              std y+0,R16
 008C 1983              std y+1,R17
 008E 2A83              std y+2,R18
 0090 3B83              std y+3,R19
 0092                   .dbline 124
 0092           ;     }
 0092           L3:
 0092                   .dbline 119
 0092 A394              inc R10
 0094           L5:
 0094                   .dbline 119
 0094 2C2C              mov R2,R12
 0096 3324              clr R3
 0098 27FC              sbrc R2,7
 009A 3094              com R3
 009C 4A2C              mov R4,R10
 009E 5524              clr R5
 00A0 4214              cp R4,R2
 00A2 5304              cpc R5,R3
 00A4 0CF4              brge X1
 00A6 BACF              xjmp L2
 00A8           X1:
 00A8           X0:
 00A8                   .dbline -2
 00A8           L1:
 00A8                   .dbline 0 ; func end
 00A8 2896              adiw R28,8
 00AA 0E940000          xcall pop_xgsetF03C
 00AE 2496              adiw R28,4
 00B0 0895              ret
 00B2                   .dbsym l y 4 l
 00B2                   .dbsym l j 0 l
 00B2                   .dbsym r i 10 c
 00B2                   .dbsym r len 12 C
 00B2                   .dbsym l dat 16 l
 00B2                   .dbend
 00B2                   .dbfile D:\ICC_H\I2C.H
 00B2                   .dbfunc e I2C_Start _I2C_Start fc
                        .even
 00B2           _I2C_Start::
 00B2                   .dbline -1
 00B2                   .dbline 126
 00B2           ; /*********************************************************************
 00B2           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 00B2           ;                                                                       
 00B2           ; 目    的:   建立I2C操作库
 00B2           ;       
 00B2           ; 目标系统:   基于AVR单片机
 00B2           ;                                                                               
 00B2           ; 应用软件:   ICCAVR
 00B2           ;                                                                               
 00B2           ; 版    本:   Version 1.0                                                          
 00B2           ;                                                                               
 00B2           ; 圆版时间:   2005-06-25
 00B2           ;       
 00B2           ; 开发人员:   SEE
 00B2           ; 
 00B2           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 00B2           ;       
 00B2           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 00B2           ; *********************************************************************/
 00B2           ; 
 00B2           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 版本更新记录：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 入口参数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 待定参数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------        
 00B2           ; 对外变量说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 对外函数说明：
 00B2           ; 
 00B2           ; ----------------------------------------------------------------------
 00B2           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 00B2           ; 
 00B2           ; #ifndef I2C_H
 00B2           ; #define I2C_H
 00B2           ; 
 00B2           ; /* TWSR values (not bits) */
 00B2           ; /* Master */
 00B2           ; #define I2C_START                     0x08
 00B2           ; #define I2C_RESTART                   0x10
 00B2           ; 
 00B2           ; /* Master Transmitter */
 00B2           ; #define I2C_MT_SLA_ACK                0x18
 00B2           ; #define I2C_MT_SLA_NACK               0x20
 00B2           ; #define I2C_MT_DATA_ACK               0x28
 00B2           ; #define I2C_MT_DATA_NACK      0x30
 00B2           ; #define I2C_MT_ARB_LOST               0x38
 00B2           ; 
 00B2           ; /* Master Receiver */
 00B2           ; #define I2C_MR_ARB_LOST               0x38
 00B2           ; #define I2C_MR_SLA_ACK                0x40
 00B2           ; #define I2C_MR_SLA_NACK               0x48
 00B2           ; #define I2C_MR_DATA_ACK               0x50
 00B2           ; #define I2C_MR_DATA_NACK      0x58
 00B2           ; 
 00B2           ; /* Slave Transmitter */
 00B2           ; #define I2C_ST_SLA_ACK                        0xA8
 00B2           ; #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
 00B2           ; #define I2C_ST_DATA_ACK                       0xB8
 00B2           ; #define I2C_ST_DATA_NACK              0xC0
 00B2           ; #define I2C_ST_LAST_DATA              0xC8
 00B2           ; 
 00B2           ; /* Slave Receiver */
 00B2           ; #define I2C_SR_SLA_ACK                                0x60
 00B2           ; #define I2C_SR_ARB_LOST_SLA_ACK               0x68
 00B2           ; #define I2C_SR_GCALL_ACK                      0x70
 00B2           ; #define I2C_SR_ARB_LOST_GCALL_ACK     0x78
 00B2           ; #define I2C_SR_DATA_ACK                               0x80
 00B2           ; #define I2C_SR_DATA_NACK                      0x88
 00B2           ; #define I2C_SR_GCALL_DATA_ACK         0x90
 00B2           ; #define I2C_SR_GCALL_DATA_NACK                0x98
 00B2           ; #define I2C_SR_STOP                                   0xA0
 00B2           ; 
 00B2           ; /* Misc */
 00B2           ; #define I2C_NO_INFO                   0xF8
 00B2           ; #define I2C_BUS_ERROR         0x00
 00B2           ; 
 00B2           ; /*
 00B2           ;  * The lower 3 bits of TWSR are reserved on the ATmega163.
 00B2           ;  * The 2 LSB carry the prescaler bits on the newer ATmegas.
 00B2           ;  */
 00B2           ; #define I2C_STATUS_MASK       (_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
 00B2           ; #define I2C_STATUS            (TWSR & I2C_STATUS_MASK)
 00B2           ; 
 00B2           ; /*
 00B2           ;  * R/~W bit in SLA+R/W address field.
 00B2           ;  */
 00B2           ; #define I2C_READ              1
 00B2           ; #define I2C_WRITE             0
 00B2           ; 
 00B2           ; #define I2CStart()            (TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
 00B2           ; #define I2CStop()             (TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
 00B2           ; #define I2CWaitAck()  {while(!(TWCR&(1<<TWINT)));}
 00B2           ; #define I2CChkAck()   (TWSR&0xf8)                                     //check ack
 00B2           ; #define I2CSendAck()  (TWCR|=(1<<TWEA))
 00B2           ; #define I2CSendNoAck()        (TWCR&=~(1<<TWEA))
 00B2           ; #define I2CSendByte(x)        {TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
 00B2           ; #define I2CRcvNckByte()       (TWCR=(1<<TWINT)|(1<<TWEN))
 00B2           ; #define I2CRcvAckByte()       (TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
 00B2           ; 
 00B2           ; /* For Program */
 00B2           ; #define I2C_Stop()            I2CStop()
 00B2           ; #define I2C_SendAck() I2CSendAck()
 00B2           ; #define I2C_SendNoAck() I2CSendNoAck()
 00B2           ; #define I2C_WaitAck() I2CWaitAck()
 00B2           ; 
 00B2           ; /* I2C Config */
 00B2           ; #define I2C_ERR                       0
 00B2           ; #define I2C_CRR                       1
 00B2           ; 
 00B2           ; /*--------------------------------------------------------------------
 00B2           ; 函数名称：I2C Start
 00B2           ; 函数功能：
 00B2           ; 注意事项：
 00B2           ; 提示说明：
 00B2           ; 输    入：
 00B2           ; 返    回：
 00B2           ; --------------------------------------------------------------------*/
 00B2           ; bool I2C_Start()                                      
 00B2           ; {
 00B2                   .dbline 127
 00B2           ;       I2CStart();                                             
 00B2 84EA              ldi R24,164
 00B4 80937400          sts 116,R24
 00B8                   .dbline 128
 00B8           ;       I2CWaitAck();
 00B8           L7:
 00B8                   .dbline 128
 00B8           L8:
 00B8                   .dbline 128
 00B8 20907400          lds R2,116
 00BC 27FE              sbrs R2,7
 00BE FCCF              rjmp L7
 00C0           X2:
 00C0                   .dbline 128
 00C0                   .dbline 128
 00C0                   .dbline 129
 00C0           ;       if( I2CChkAck()!=I2C_START ) 
 00C0 80917100          lds R24,113
 00C4 887F              andi R24,248
 00C6 8830              cpi R24,8
 00C8 11F0              breq L10
 00CA           X3:
 00CA                   .dbline 130
 00CA           ;               return I2C_ERR;
 00CA 0027              clr R16
 00CC 01C0              xjmp L6
 00CE           L10:
 00CE                   .dbline 131
 00CE           ;       return I2C_CRR;
 00CE 01E0              ldi R16,1
 00D0                   .dbline -2
 00D0           L6:
 00D0                   .dbline 0 ; func end
 00D0 0895              ret
 00D2                   .dbend
 00D2                   .dbfunc e I2C_Restart _I2C_Restart fc
                        .even
 00D2           _I2C_Restart::
 00D2                   .dbline -1
 00D2                   .dbline 142
 00D2           ; }
 00D2           ; /*--------------------------------------------------------------------
 00D2           ; 函数名称：I2C ReStart
 00D2           ; 函数功能：
 00D2           ; 注意事项：
 00D2           ; 提示说明：
 00D2           ; 输    入：
 00D2           ; 返    回：
 00D2           ; --------------------------------------------------------------------*/
 00D2           ; bool I2C_Restart()                                    
 00D2           ; {
 00D2                   .dbline 143
 00D2           ;       I2CStart();                                             
 00D2 84EA              ldi R24,164
 00D4 80937400          sts 116,R24
 00D8                   .dbline 144
 00D8           ;       I2CWaitAck();
 00D8           L13:
 00D8                   .dbline 144
 00D8           L14:
 00D8                   .dbline 144
 00D8 20907400          lds R2,116
 00DC 27FE              sbrs R2,7
 00DE FCCF              rjmp L13
 00E0           X4:
 00E0                   .dbline 144
 00E0                   .dbline 144
 00E0                   .dbline 145
 00E0           ;       if( I2CChkAck()!=I2C_RESTART ) 
 00E0 80917100          lds R24,113
 00E4 887F              andi R24,248
 00E6 8031              cpi R24,16
 00E8 11F0              breq L16
 00EA           X5:
 00EA                   .dbline 146
 00EA           ;               return I2C_ERR;
 00EA 0027              clr R16
 00EC 01C0              xjmp L12
 00EE           L16:
 00EE                   .dbline 147
 00EE           ;       return I2C_CRR;
 00EE 01E0              ldi R16,1
 00F0                   .dbline -2
 00F0           L12:
 00F0                   .dbline 0 ; func end
 00F0 0895              ret
 00F2                   .dbend
 00F2                   .dbfunc e I2C_SendWrDAdr _I2C_SendWrDAdr fc
 00F2           ;         wrDAdr -> R16
                        .even
 00F2           _I2C_SendWrDAdr::
 00F2                   .dbline -1
 00F2                   .dbline 158
 00F2           ; }
 00F2           ; /*--------------------------------------------------------------------
 00F2           ; 函数名称：发送 7位 器件写地址: XXXX XXX0
 00F2           ; 函数功能：
 00F2           ; 注意事项：
 00F2           ; 提示说明：
 00F2           ; 输    入：
 00F2           ; 返    回：
 00F2           ; --------------------------------------------------------------------*/
 00F2           ; bool I2C_SendWrDAdr(uint8 wrDAdr)     
 00F2           ; {
 00F2                   .dbline 159
 00F2           ;       I2CSendByte(wrDAdr);                    //设置 器件写地址
 00F2                   .dbline 159
 00F2 00937300          sts 115,R16
 00F6                   .dbline 159
 00F6 84E8              ldi R24,132
 00F8 80937400          sts 116,R24
 00FC                   .dbline 159
 00FC                   .dbline 159
 00FC                   .dbline 160
 00FC           ;       I2CWaitAck();
 00FC           L19:
 00FC                   .dbline 160
 00FC           L20:
 00FC                   .dbline 160
 00FC 20907400          lds R2,116
 0100 27FE              sbrs R2,7
 0102 FCCF              rjmp L19
 0104           X6:
 0104                   .dbline 160
 0104                   .dbline 160
 0104                   .dbline 161
 0104           ;       if( I2CChkAck()!=I2C_MT_SLA_ACK )  
 0104 80917100          lds R24,113
 0108 887F              andi R24,248
 010A 8831              cpi R24,24
 010C 11F0              breq L22
 010E           X7:
 010E                   .dbline 162
 010E           ;               return I2C_ERR;
 010E 0027              clr R16
 0110 01C0              xjmp L18
 0112           L22:
 0112                   .dbline 163
 0112           ;       return I2C_CRR;         
 0112 01E0              ldi R16,1
 0114                   .dbline -2
 0114           L18:
 0114                   .dbline 0 ; func end
 0114 0895              ret
 0116                   .dbsym r wrDAdr 16 c
 0116                   .dbend
 0116                   .dbfunc e I2C_SendWrDAdr_ _I2C_SendWrDAdr_ fc
 0116           ;         wrDAdr -> R10,R11
                        .even
 0116           _I2C_SendWrDAdr_::
 0116 AA92              st -y,R10
 0118 BA92              st -y,R11
 011A 5801              movw R10,R16
 011C                   .dbline -1
 011C                   .dbline 174
 011C           ; }
 011C           ; /*--------------------------------------------------------------------
 011C           ; 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
 011C           ; 函数功能：
 011C           ; 注意事项：
 011C           ; 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
 011C           ; 输    入：
 011C           ; 返    回：
 011C           ; --------------------------------------------------------------------*/
 011C           ; bool I2C_SendWrDAdr_(uint16 wrDAdr)   
 011C           ; {
 011C                   .dbline 175
 011C           ;       if( wrDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 011C A0FE              sbrs R10,0
 011E 0EC0              rjmp L25
 0120           X8:
 0120                   .dbline 176
 0120           ;               if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )       //设置 （高位）器件写地址
 0120 0A2D              mov R16,R10
 0122 0695              lsr R16
 0124 0695              lsr R16
 0126 0695              lsr R16
 0128 0695              lsr R16
 012A 0695              lsr R16
 012C 0695              lsr R16
 012E 0695              lsr R16
 0130 0695              lsr R16
 0132 DFDF              xcall _I2C_SendWrDAdr
 0134 0023              tst R16
 0136 11F4              brne L27
 0138           X9:
 0138                   .dbline 177
 0138           ;                       return I2C_ERR;
 0138 0027              clr R16
 013A 07C0              xjmp L24
 013C           L27:
 013C           L25:
 013C                   .dbline 178
 013C           ;       if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )  //设置 （低位）器件写地址
 013C 0A2D              mov R16,R10
 013E D9DF              xcall _I2C_SendWrDAdr
 0140 0023              tst R16
 0142 11F4              brne L29
 0144           X10:
 0144                   .dbline 179
 0144           ;               return I2C_ERR;
 0144 0027              clr R16
 0146 01C0              xjmp L24
 0148           L29:
 0148                   .dbline 180
 0148           ;       return I2C_CRR;
 0148 01E0              ldi R16,1
 014A                   .dbline -2
 014A           L24:
 014A                   .dbline 0 ; func end
 014A B990              ld R11,y+
 014C A990              ld R10,y+
 014E 0895              ret
 0150                   .dbsym r wrDAdr 10 i
 0150                   .dbend
 0150                   .dbfunc e I2C_SendRdDAdr _I2C_SendRdDAdr fc
 0150           ;         rdDAdr -> R16
                        .even
 0150           _I2C_SendRdDAdr::
 0150                   .dbline -1
 0150                   .dbline 191
 0150           ; }
 0150           ; /*--------------------------------------------------------------------
 0150           ; 函数名称：发送 7位 器件读地址: XXXX XXX1
 0150           ; 函数功能：
 0150           ; 注意事项：
 0150           ; 提示说明：
 0150           ; 输    入：
 0150           ; 返    回：
 0150           ; --------------------------------------------------------------------*/
 0150           ; bool I2C_SendRdDAdr(uint8 rdDAdr)     
 0150           ; {
 0150                   .dbline 192
 0150           ;       I2CSendByte(rdDAdr);                    //设置 器件读地址
 0150                   .dbline 192
 0150 00937300          sts 115,R16
 0154                   .dbline 192
 0154 84E8              ldi R24,132
 0156 80937400          sts 116,R24
 015A                   .dbline 192
 015A                   .dbline 192
 015A                   .dbline 193
 015A           ;       I2CWaitAck();
 015A           L32:
 015A                   .dbline 193
 015A           L33:
 015A                   .dbline 193
 015A 20907400          lds R2,116
 015E 27FE              sbrs R2,7
 0160 FCCF              rjmp L32
 0162           X11:
 0162                   .dbline 193
 0162                   .dbline 193
 0162                   .dbline 194
 0162           ;       if( I2CChkAck()!=I2C_MR_SLA_ACK )  
 0162 80917100          lds R24,113
 0166 887F              andi R24,248
 0168 8034              cpi R24,64
 016A 11F0              breq L35
 016C           X12:
 016C                   .dbline 195
 016C           ;               return I2C_ERR;
 016C 0027              clr R16
 016E 01C0              xjmp L31
 0170           L35:
 0170                   .dbline 196
 0170           ;       return I2C_CRR; 
 0170 01E0              ldi R16,1
 0172                   .dbline -2
 0172           L31:
 0172                   .dbline 0 ; func end
 0172 0895              ret
 0174                   .dbsym r rdDAdr 16 c
 0174                   .dbend
 0174                   .dbfunc e I2C_SendRdDAdr_ _I2C_SendRdDAdr_ fc
 0174           ;         rdDAdr -> R10
                        .even
 0174           _I2C_SendRdDAdr_::
 0174 AA92              st -y,R10
 0176 A02E              mov R10,R16
 0178                   .dbline -1
 0178                   .dbline 207
 0178           ; }
 0178           ; /*--------------------------------------------------------------------
 0178           ; 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
 0178           ; 函数功能：
 0178           ; 注意事项：
 0178           ; 提示说明：
 0178           ; 输    入：
 0178           ; 返    回：
 0178           ; --------------------------------------------------------------------*/
 0178           ; bool I2C_SendRdDAdr_(uint8 rdDAdr)    
 0178           ; {
 0178                   .dbline 208
 0178           ;       if( rdDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 0178 A0FE              sbrs R10,0
 017A 0EC0              rjmp L38
 017C           X13:
 017C                   .dbline 209
 017C           ;               if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )       //设置 （高位）器件读地址
 017C 0A2D              mov R16,R10
 017E 0695              lsr R16
 0180 0695              lsr R16
 0182 0695              lsr R16
 0184 0695              lsr R16
 0186 0695              lsr R16
 0188 0695              lsr R16
 018A 0695              lsr R16
 018C 0695              lsr R16
 018E B1DF              xcall _I2C_SendWrDAdr
 0190 0023              tst R16
 0192 11F4              brne L40
 0194           X14:
 0194                   .dbline 210
 0194           ;                       return I2C_ERR;
 0194 0027              clr R16
 0196 07C0              xjmp L37
 0198           L40:
 0198           L38:
 0198                   .dbline 211
 0198           ;       if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )  //设置 （低位）器件读地址
 0198 0A2D              mov R16,R10
 019A ABDF              xcall _I2C_SendWrDAdr
 019C 0023              tst R16
 019E 11F4              brne L42
 01A0           X15:
 01A0                   .dbline 212
 01A0           ;               return I2C_ERR;
 01A0 0027              clr R16
 01A2 01C0              xjmp L37
 01A4           L42:
 01A4                   .dbline 213
 01A4           ;       return I2C_CRR;
 01A4 01E0              ldi R16,1
 01A6                   .dbline -2
 01A6           L37:
 01A6                   .dbline 0 ; func end
 01A6 A990              ld R10,y+
 01A8 0895              ret
 01AA                   .dbsym r rdDAdr 10 c
 01AA                   .dbend
 01AA                   .dbfunc e I2C_SendDat _I2C_SendDat fc
 01AA           ;      configDat -> R16
                        .even
 01AA           _I2C_SendDat::
 01AA                   .dbline -1
 01AA                   .dbline 224
 01AA           ; }
 01AA           ; /*--------------------------------------------------------------------
 01AA           ; 函数名称：I2C发送数据
 01AA           ; 函数功能：
 01AA           ; 注意事项：
 01AA           ; 提示说明：
 01AA           ; 输    入：
 01AA           ; 返    回：
 01AA           ; --------------------------------------------------------------------*/
 01AA           ; bool I2C_SendDat(uint8 configDat)     
 01AA           ; {
 01AA                   .dbline 225
 01AA           ;       I2CSendByte(configDat);                 
 01AA                   .dbline 225
 01AA 00937300          sts 115,R16
 01AE                   .dbline 225
 01AE 84E8              ldi R24,132
 01B0 80937400          sts 116,R24
 01B4                   .dbline 225
 01B4                   .dbline 225
 01B4                   .dbline 226
 01B4           ;       I2CWaitAck();
 01B4           L45:
 01B4                   .dbline 226
 01B4           L46:
 01B4                   .dbline 226
 01B4 20907400          lds R2,116
 01B8 27FE              sbrs R2,7
 01BA FCCF              rjmp L45
 01BC           X16:
 01BC                   .dbline 226
 01BC                   .dbline 226
 01BC                   .dbline 227
 01BC           ;       if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
 01BC 80917100          lds R24,113
 01C0 887F              andi R24,248
 01C2 8832              cpi R24,40
 01C4 11F0              breq L48
 01C6           X17:
 01C6                   .dbline 228
 01C6           ;               return I2C_ERR;
 01C6 0027              clr R16
 01C8 01C0              xjmp L44
 01CA           L48:
 01CA                   .dbline 229
 01CA           ;       return I2C_CRR; 
 01CA 01E0              ldi R16,1
 01CC                   .dbline -2
 01CC           L44:
 01CC                   .dbline 0 ; func end
 01CC 0895              ret
 01CE                   .dbsym r configDat 16 c
 01CE                   .dbend
 01CE                   .dbfunc e I2C_RcvNAckDat _I2C_RcvNAckDat fc
 01CE           ;         pRdDat -> R16,R17
                        .even
 01CE           _I2C_RcvNAckDat::
 01CE                   .dbline -1
 01CE                   .dbline 240
 01CE           ; }
 01CE           ; /*--------------------------------------------------------------------
 01CE           ; 函数名称：I2C接收数据且不产生应答
 01CE           ; 函数功能：
 01CE           ; 注意事项：
 01CE           ; 提示说明：
 01CE           ; 输    入：
 01CE           ; 返    回：
 01CE           ; --------------------------------------------------------------------*/
 01CE           ; bool I2C_RcvNAckDat(uint8 *pRdDat)    
 01CE           ; {
 01CE                   .dbline 241
 01CE           ;       I2CRcvNckByte();
 01CE 84E8              ldi R24,132
 01D0 80937400          sts 116,R24
 01D4                   .dbline 242
 01D4           ;       I2CWaitAck();
 01D4           L51:
 01D4                   .dbline 242
 01D4           L52:
 01D4                   .dbline 242
 01D4 20907400          lds R2,116
 01D8 27FE              sbrs R2,7
 01DA FCCF              rjmp L51
 01DC           X18:
 01DC                   .dbline 242
 01DC                   .dbline 242
 01DC                   .dbline 243
 01DC           ;       if( I2CChkAck()!=I2C_MR_DATA_NACK )
 01DC 80917100          lds R24,113
 01E0 887F              andi R24,248
 01E2 8835              cpi R24,88
 01E4 11F0              breq L54
 01E6           X19:
 01E6                   .dbline 244
 01E6           ;               return I2C_ERR;
 01E6 0027              clr R16
 01E8 05C0              xjmp L50
 01EA           L54:
 01EA                   .dbline 245
 01EA           ;       *pRdDat=TWDR;
 01EA 20907300          lds R2,115
 01EE F801              movw R30,R16
 01F0 2082              std z+0,R2
 01F2                   .dbline 246
 01F2           ;       return I2C_CRR;
 01F2 01E0              ldi R16,1
 01F4                   .dbline -2
 01F4           L50:
 01F4                   .dbline 0 ; func end
 01F4 0895              ret
 01F6                   .dbsym r pRdDat 16 pc
 01F6                   .dbend
 01F6                   .dbfunc e I2C_RcvAckDat _I2C_RcvAckDat fc
 01F6           ;         pRdDat -> R16,R17
                        .even
 01F6           _I2C_RcvAckDat::
 01F6                   .dbline -1
 01F6                   .dbline 257
 01F6           ; }
 01F6           ; /*--------------------------------------------------------------------
 01F6           ; 函数名称：I2C接收数据且产生应答
 01F6           ; 函数功能：
 01F6           ; 注意事项：
 01F6           ; 提示说明：
 01F6           ; 输    入：
 01F6           ; 返    回：
 01F6           ; --------------------------------------------------------------------*/
 01F6           ; bool I2C_RcvAckDat(uint8 *pRdDat)     
 01F6           ; {
 01F6                   .dbline 258
 01F6           ;       I2CRcvAckByte();                                        
 01F6 84EC              ldi R24,196
 01F8 80937400          sts 116,R24
 01FC                   .dbline 259
 01FC           ;       I2CWaitAck();
 01FC           L57:
 01FC                   .dbline 259
 01FC           L58:
 01FC                   .dbline 259
 01FC 20907400          lds R2,116
 0200 27FE              sbrs R2,7
 0202 FCCF              rjmp L57
 0204           X20:
 0204                   .dbline 259
 0204                   .dbline 259
 0204                   .dbline 260
 0204           ;       if( I2CChkAck()!=I2C_MR_DATA_ACK )
 0204 80917100          lds R24,113
 0208 887F              andi R24,248
 020A 8035              cpi R24,80
 020C 11F0              breq L60
 020E           X21:
 020E                   .dbline 261
 020E           ;               return I2C_ERR;
 020E 0027              clr R16
 0210 05C0              xjmp L56
 0212           L60:
 0212                   .dbline 262
 0212           ;       *pRdDat=TWDR;
 0212 20907300          lds R2,115
 0216 F801              movw R30,R16
 0218 2082              std z+0,R2
 021A                   .dbline 263
 021A           ;       return I2C_CRR;
 021A 01E0              ldi R16,1
 021C                   .dbline -2
 021C           L56:
 021C                   .dbline 0 ; func end
 021C 0895              ret
 021E                   .dbsym r pRdDat 16 pc
 021E                   .dbend
 021E                   .dbfunc e I2C_Write _I2C_Write fc
 021E           ;            dat -> R10
 021E           ;        wordAdr -> R12
 021E           ;         wrDAdr -> R14,R15
                        .even
 021E           _I2C_Write::
 021E 0E940000          xcall push_xgset00FC
 0222 C22E              mov R12,R18
 0224 7801              movw R14,R16
 0226 AE80              ldd R10,y+6
 0228                   .dbline -1
 0228                   .dbline 276
 0228           ; }
 0228           ; /*--------------------------------------------------------------------
 0228           ; 函数名称：I2C写器件，写一个数据
 0228           ; 函数功能：
 0228           ; 注意事项：
 0228           ; 提示说明：
 0228           ; 输    入：wrDAdr: write device-address 写器件地址
 0228           ;                wordAdr: word address 字地址
 0228           ;                dat: data 数据
 0228           ; 返    回：
 0228           ; --------------------------------------------------------------------*/
 0228           ; bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
 0228           ; {
 0228                   .dbline 277
 0228           ;       if( I2C_Start()==I2C_ERR )
 0228 44DF              xcall _I2C_Start
 022A 0023              tst R16
 022C 11F4              brne L63
 022E           X22:
 022E                   .dbline 278
 022E           ;               return I2C_ERR;
 022E 0027              clr R16
 0230 18C0              xjmp L62
 0232           L63:
 0232                   .dbline 280
 0232           ; 
 0232           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 0232 8701              movw R16,R14
 0234 70DF              xcall _I2C_SendWrDAdr_
 0236 0023              tst R16
 0238 11F4              brne L65
 023A           X23:
 023A                   .dbline 281
 023A           ;               return I2C_ERR;
 023A 0027              clr R16
 023C 12C0              xjmp L62
 023E           L65:
 023E                   .dbline 283
 023E           ; 
 023E           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 023E 0C2D              mov R16,R12
 0240 B4DF              xcall _I2C_SendDat
 0242 C02E              mov R12,R16
 0244 0023              tst R16
 0246 11F4              brne L67
 0248           X24:
 0248                   .dbline 284
 0248           ;               return I2C_ERR;
 0248 0027              clr R16
 024A 0BC0              xjmp L62
 024C           L67:
 024C                   .dbline 286
 024C           ; 
 024C           ;       if( I2C_SendDat(dat)==I2C_ERR )
 024C 0A2D              mov R16,R10
 024E ADDF              xcall _I2C_SendDat
 0250 A02E              mov R10,R16
 0252 0023              tst R16
 0254 11F4              brne L69
 0256           X25:
 0256                   .dbline 287
 0256           ;               return I2C_ERR;
 0256 0027              clr R16
 0258 04C0              xjmp L62
 025A           L69:
 025A                   .dbline 289
 025A           ; 
 025A           ;       I2C_Stop();
 025A 84E9              ldi R24,148
 025C 80937400          sts 116,R24
 0260                   .dbline 291
 0260           ; 
 0260           ;       return I2C_CRR;
 0260 01E0              ldi R16,1
 0262                   .dbline -2
 0262           L62:
 0262                   .dbline 0 ; func end
 0262 0C940000          xjmp pop_xgset00FC
 0266                   .dbsym r dat 10 c
 0266                   .dbsym r wordAdr 12 c
 0266                   .dbsym r wrDAdr 14 i
 0266                   .dbend
 0266                   .dbfunc e I2C_Read _I2C_Read fc
 0266           ;         pRdDat -> R10,R11
 0266           ;         rdDAdr -> R12
 0266           ;        wordAdr -> R14
 0266           ;         wrDAdr -> R20,R21
                        .even
 0266           _I2C_Read::
 0266 0E940000          xcall push_xgset30FC
 026A E22E              mov R14,R18
 026C A801              movw R20,R16
 026E C884              ldd R12,y+8
 0270 AA84              ldd R10,y+10
 0272 BB84              ldd R11,y+11
 0274                   .dbline -1
 0274                   .dbline 322
 0274           ; }
 0274           ; /*--------------------------------------------------------------------
 0274           ; 函数名称：I2C写器件，写N个数据
 0274           ; 函数功能：
 0274           ; 注意事项：
 0274           ; 提示说明：
 0274           ; 输    入：wrDAdr: write device-address 写器件地址
 0274           ;                wordAdr: word address 字地址
 0274           ;                *pWrDat: p->write data 写入数据指针
 0274           ;                num: number 写入数据个数
 0274           ; 返    回：
 0274           ; --------------------------------------------------------------------*/
 0274           ; //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
 0274           ; //                              uint8 *pWrDat,uint8 num)
 0274           ; //{
 0274           ; //
 0274           ; //} 
 0274           ; /*--------------------------------------------------------------------
 0274           ; 函数名称：I2C读器件，读一个数据
 0274           ; 函数功能：
 0274           ; 注意事项：
 0274           ; 提示说明：
 0274           ; 输    入：wrDAdr: write device-address 写器件地址
 0274           ;                wordAdr: word address 字地址
 0274           ;                rdDAdr: read device-address 读器件地址
 0274           ;                *pRdDat: p->read data 读取数据指针
 0274           ; 返    回：
 0274           ; --------------------------------------------------------------------*/
 0274           ; bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
 0274           ;                         uint8 rdDAdr,uint8 *pRdDat)
 0274           ; {
 0274                   .dbline 323
 0274           ;       if( I2C_Start()==I2C_ERR )
 0274 1EDF              xcall _I2C_Start
 0276 0023              tst R16
 0278 11F4              brne L72
 027A           X26:
 027A                   .dbline 324
 027A           ;               return I2C_ERR;
 027A 0027              clr R16
 027C 25C0              xjmp L71
 027E           L72:
 027E                   .dbline 326
 027E           ; 
 027E           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 027E 8A01              movw R16,R20
 0280 4ADF              xcall _I2C_SendWrDAdr_
 0282 0023              tst R16
 0284 11F4              brne L74
 0286           X27:
 0286                   .dbline 327
 0286           ;               return I2C_ERR;
 0286 0027              clr R16
 0288 1FC0              xjmp L71
 028A           L74:
 028A                   .dbline 329
 028A           ; 
 028A           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 028A 0E2D              mov R16,R14
 028C 8EDF              xcall _I2C_SendDat
 028E E02E              mov R14,R16
 0290 0023              tst R16
 0292 11F4              brne L76
 0294           X28:
 0294                   .dbline 330
 0294           ;               return I2C_ERR;
 0294 0027              clr R16
 0296 18C0              xjmp L71
 0298           L76:
 0298                   .dbline 332
 0298           ; 
 0298           ;       if( I2C_Restart()==I2C_ERR )
 0298 1CDF              xcall _I2C_Restart
 029A E02E              mov R14,R16
 029C 0023              tst R16
 029E 11F4              brne L78
 02A0           X29:
 02A0                   .dbline 333
 02A0           ;               return I2C_ERR;
 02A0 0027              clr R16
 02A2 12C0              xjmp L71
 02A4           L78:
 02A4                   .dbline 335
 02A4           ; 
 02A4           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 02A4 0C2D              mov R16,R12
 02A6 54DF              xcall _I2C_SendRdDAdr
 02A8 C02E              mov R12,R16
 02AA 0023              tst R16
 02AC 11F4              brne L80
 02AE           X30:
 02AE                   .dbline 336
 02AE           ;               return I2C_ERR;
 02AE 0027              clr R16
 02B0 0BC0              xjmp L71
 02B2           L80:
 02B2                   .dbline 338
 02B2           ; 
 02B2           ;       if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
 02B2 8501              movw R16,R10
 02B4 8CDF              xcall _I2C_RcvNAckDat
 02B6 A02E              mov R10,R16
 02B8 0023              tst R16
 02BA 11F4              brne L82
 02BC           X31:
 02BC                   .dbline 339
 02BC           ;               return I2C_ERR;
 02BC 0027              clr R16
 02BE 04C0              xjmp L71
 02C0           L82:
 02C0                   .dbline 341
 02C0           ; 
 02C0           ;       I2C_Stop();
 02C0 84E9              ldi R24,148
 02C2 80937400          sts 116,R24
 02C6                   .dbline 343
 02C6           ; 
 02C6           ;       return I2C_CRR;
 02C6 01E0              ldi R16,1
 02C8                   .dbline -2
 02C8           L71:
 02C8                   .dbline 0 ; func end
 02C8 0C940000          xjmp pop_xgset30FC
 02CC                   .dbsym r pRdDat 10 pc
 02CC                   .dbsym r rdDAdr 12 c
 02CC                   .dbsym r wordAdr 14 c
 02CC                   .dbsym r wrDAdr 20 i
 02CC                   .dbend
 02CC                   .dbfunc e I2C_Read_ _I2C_Read_ fc
 02CC           ;              i -> R12
 02CC           ;            num -> R20
 02CC           ;         pRdDat -> R10,R11
 02CC           ;         rdDAdr -> R12
 02CC           ;        wordAdr -> R14
 02CC           ;         wrDAdr -> R22,R23
                        .even
 02CC           _I2C_Read_::
 02CC 0E940000          xcall push_xgsetF0FC
 02D0 E22E              mov R14,R18
 02D2 B801              movw R22,R16
 02D4 CA84              ldd R12,y+10
 02D6 AC84              ldd R10,y+12
 02D8 BD84              ldd R11,y+13
 02DA 4E85              ldd R20,y+14
 02DC                   .dbline -1
 02DC                   .dbline 359
 02DC           ; }
 02DC           ; /*--------------------------------------------------------------------
 02DC           ; 函数名称：I2C读器件，读N个数据
 02DC           ; 函数功能：
 02DC           ; 注意事项：
 02DC           ; 提示说明：
 02DC           ; 输    入：wrDAdr: write device-address 写器件地址
 02DC           ;                wordAdr: word address 字地址
 02DC           ;                rdDAdr: read device-address 读器件地址
 02DC           ;                *pRdDat: p->read data 读取数据指针
 02DC           ;                num: number 读取数据个数
 02DC           ; 返    回：
 02DC           ; --------------------------------------------------------------------*/
 02DC           ; bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
 02DC           ;                          uint8 rdDAdr,uint8 *pRdDat,uint8 num)
 02DC           ; {
 02DC                   .dbline 362
 02DC           ;       uint8 i;
 02DC           ;       
 02DC           ;       if( I2C_Start()==I2C_ERR )
 02DC EADE              xcall _I2C_Start
 02DE 0023              tst R16
 02E0 11F4              brne L85
 02E2           X32:
 02E2                   .dbline 363
 02E2           ;               return I2C_ERR;
 02E2 0027              clr R16
 02E4 39C0              xjmp L84
 02E6           L85:
 02E6                   .dbline 365
 02E6           ; 
 02E6           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 02E6 8B01              movw R16,R22
 02E8 16DF              xcall _I2C_SendWrDAdr_
 02EA 0023              tst R16
 02EC 11F4              brne L87
 02EE           X33:
 02EE                   .dbline 366
 02EE           ;               return I2C_ERR;
 02EE 0027              clr R16
 02F0 33C0              xjmp L84
 02F2           L87:
 02F2                   .dbline 368
 02F2           ; 
 02F2           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 02F2 0E2D              mov R16,R14
 02F4 5ADF              xcall _I2C_SendDat
 02F6 E02E              mov R14,R16
 02F8 0023              tst R16
 02FA 11F4              brne L89
 02FC           X34:
 02FC                   .dbline 369
 02FC           ;               return I2C_ERR;
 02FC 0027              clr R16
 02FE 2CC0              xjmp L84
 0300           L89:
 0300                   .dbline 371
 0300           ; 
 0300           ;       if( I2C_Restart()==I2C_ERR )
 0300 E8DE              xcall _I2C_Restart
 0302 E02E              mov R14,R16
 0304 0023              tst R16
 0306 11F4              brne L91
 0308           X35:
 0308                   .dbline 372
 0308           ;               return I2C_ERR;
 0308 0027              clr R16
 030A 26C0              xjmp L84
 030C           L91:
 030C                   .dbline 374
 030C           ; 
 030C           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 030C 0C2D              mov R16,R12
 030E 20DF              xcall _I2C_SendRdDAdr
 0310 C02E              mov R12,R16
 0312 0023              tst R16
 0314 11F4              brne L93
 0316           X36:
 0316                   .dbline 375
 0316           ;               return I2C_ERR;
 0316 0027              clr R16
 0318 1FC0              xjmp L84
 031A           L93:
 031A                   .dbline 377
 031A           ; 
 031A           ;       for(i=0;i<num-1;i++)
 031A CC24              clr R12
 031C 0BC0              xjmp L98
 031E           L95:
 031E                   .dbline 378
 031E           ;               if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
 031E 0C2D              mov R16,R12
 0320 1127              clr R17
 0322 0A0D              add R16,R10
 0324 1B1D              adc R17,R11
 0326 67DF              xcall _I2C_RcvAckDat
 0328 E02E              mov R14,R16
 032A 0023              tst R16
 032C 11F4              brne L99
 032E           X37:
 032E                   .dbline 379
 032E           ;                       return I2C_ERR;
 032E 0027              clr R16
 0330 13C0              xjmp L84
 0332           L99:
 0332           L96:
 0332                   .dbline 377
 0332 C394              inc R12
 0334           L98:
 0334                   .dbline 377
 0334 842F              mov R24,R20
 0336 8150              subi R24,1
 0338 C816              cp R12,R24
 033A 88F3              brlo L95
 033C           X38:
 033C                   .dbline 381
 033C           ;       
 033C           ;       if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
 033C 0C2D              mov R16,R12
 033E 1127              clr R17
 0340 0A0D              add R16,R10
 0342 1B1D              adc R17,R11
 0344 44DF              xcall _I2C_RcvNAckDat
 0346 A02E              mov R10,R16
 0348 0023              tst R16
 034A 11F4              brne L101
 034C           X39:
 034C                   .dbline 382
 034C           ;                       return I2C_ERR;
 034C 0027              clr R16
 034E 04C0              xjmp L84
 0350           L101:
 0350                   .dbline 384
 0350           ; 
 0350           ;       I2C_Stop();
 0350 84E9              ldi R24,148
 0352 80937400          sts 116,R24
 0356                   .dbline 386
 0356           ;       
 0356           ;       return I2C_CRR;
 0356 01E0              ldi R16,1
 0358                   .dbline -2
 0358           L84:
 0358                   .dbline 0 ; func end
 0358 0C940000          xjmp pop_xgsetF0FC
 035C                   .dbsym r i 12 c
 035C                   .dbsym r num 20 c
 035C                   .dbsym r pRdDat 10 pc
 035C                   .dbsym r rdDAdr 12 c
 035C                   .dbsym r wordAdr 14 c
 035C                   .dbsym r wrDAdr 22 i
 035C                   .dbend
 035C                   .dbfile D:\ICC_H\Hardware.H
 035C                   .dbfunc e delay50us _delay50us fV
 035C           ;              j -> R20
 035C           ;              t -> R16,R17
                        .even
 035C           _delay50us::
 035C 4A93              st -y,R20
 035E                   .dbline -1
 035E                   .dbline 105
 035E           ; /*********************************************************************
 035E           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 035E           ;                                                                       
 035E           ; 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
 035E           ;                                       
 035E           ; 目标系统:   基于AVR单片机
 035E           ;                                                                               
 035E           ; 应用软件:   ICCAVR
 035E           ;                                                                               
 035E           ; 版    本:   Version 1.0                                                          
 035E           ;                                                                               
 035E           ; 圆版时间:   2005-06-25
 035E           ;       
 035E           ; 开发人员:   SEE
 035E           ; 
 035E           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 035E           ;       
 035E           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 035E           ; *********************************************************************/
 035E           ; 
 035E           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 035E           ; ----------------------------------------------------------------------
 035E           ; 版本更新记录：
 035E           ; 
 035E           ; ----------------------------------------------------------------------
 035E           ; 入口参数说明：
 035E           ; 
 035E           ; ----------------------------------------------------------------------
 035E           ; 待定参数说明：
 035E           ; 
 035E           ; ----------------------------------------------------------------------        
 035E           ; 对外变量说明：
 035E           ;     
 035E           ; ----------------------------------------------------------------------
 035E           ; 对外函数说明：
 035E           ;    
 035E           ; ----------------------------------------------------------------------
 035E           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 035E           ; 
 035E           ; #ifndef Hardware_H
 035E           ; #define Hardware_H
 035E           ; 
 035E           ; #include <math.h>
 035E           ; #include <string.h>
 035E           ; #include <stdio.h>
 035E           ; #include <macros.h>
 035E           ; #include <eeprom.h>
 035E           ; //#include <wdt.h>
 035E           ; 
 035E           ; /* TWI configs */
 035E           ; //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
 035E           ; #if NO_INCLUDE_I2C_H
 035E           ; ;
 035E           ; #else
 035E           ; #include "D:\ICC_H\I2C.H"     //i2c即AVR的"twi"
 035E           ; #endif
 035E           ; 
 035E           ; /* hard configs */
 035E           ; #ifndef flash
 035E           ;       #define flash   const
 035E           ; #endif
 035E           ; 
 035E           ; #ifndef code
 035E           ;       #define code    const
 035E           ; #endif
 035E           ; 
 035E           ; #ifndef NOP
 035E           ;       #define NOP()   asm("nop")
 035E           ; #endif
 035E           ; 
 035E           ; /* io configs */
 035E           ; #define sbi(io,bit)           (  io |=  (1<<bit) )    //example: sbi(PORTA,0);sbi(DDRA,0);
 035E           ; #define cbi(io,bit)           (  io &= ~(1<<bit) )    //example: cbi(PORTA,0);cbi(DDRA,0);
 035E           ; #define gbi(pin ,bit) ( pin &   (1<<bit) )    //example: gbi(PINA,0);
 035E           ; 
 035E           ; /* interrupt configs */
 035E           ; #define DIS_INT  asm("sei")
 035E           ; #define EN_INT   asm("cli")
 035E           ; 
 035E           ; /* wdt configs */
 035E           ; #define WDT()    asm("wdr")
 035E           ; 
 035E           ; /* bit operation */
 035E           ; //#ifndef BIT
 035E           ; //#define BIT(x)      ( 1<<(x) )
 035E           ; //#endif
 035E           ; 
 035E           ; /* USART configs for 4 Mhz crystal */
 035E           ; //#define BAUD9600                    25
 035E           ; //#define BAUD19000                   12
 035E           ; //#define UART_TRAN_ON()      UCR |=  0x08
 035E           ; //#define UART_TRAN_OFF()     UCR &= ~0x08
 035E           ; //#define UART_RCV_ON()               UCR |=  0x10
 035E           ; //#define UART_RCV_OFF()      UCR &= ~0x10
 035E           ; 
 035E           ; /*--------------------------------------------------------------------
 035E           ; 函数全称：50us 延时
 035E           ; 函数功能：当然是 50us延时 啦
 035E           ; 注意事项：基于7.3728M晶振，稍微有点误差
 035E           ; 提示说明：调用delay50us（20），得到1ms延时
 035E           ; 输    入：    
 035E           ; 返    回：无 
 035E           ; --------------------------------------------------------------------*/
 035E           ; void delay50us(sint16 t)
 035E           ; {
 035E                   .dbline 107
 035E           ;     uint8 j;          
 035E           ;     for(;t>0;t--)                     
 035E 07C0              xjmp L107
 0360           L104:
 0360                   .dbline 108
 0360           ;         for(j=0;j<70;j++)     
 0360 4427              clr R20
 0362 01C0              xjmp L111
 0364           L108:
 0364                   .dbline 109
 0364           ;             ;
 0364           L109:
 0364                   .dbline 108
 0364 4395              inc R20
 0366           L111:
 0366                   .dbline 108
 0366 4634              cpi R20,70
 0368 E8F3              brlo L108
 036A           X40:
 036A           L105:
 036A                   .dbline 107
 036A 0150              subi R16,1
 036C 1040              sbci R17,0
 036E           L107:
 036E                   .dbline 107
 036E 2224              clr R2
 0370 3324              clr R3
 0372 2016              cp R2,R16
 0374 3106              cpc R3,R17
 0376 A4F3              brlt L104
 0378           X41:
 0378                   .dbline -2
 0378           L103:
 0378                   .dbline 0 ; func end
 0378 4991              ld R20,y+
 037A 0895              ret
 037C                   .dbsym r j 20 c
 037C                   .dbsym r t 16 I
 037C                   .dbend
 037C                   .dbfunc e delay50ms _delay50ms fV
 037C           ;              i -> R20,R21
 037C           ;              t -> R16,R17
                        .even
 037C           _delay50ms::
 037C 4A93              st -y,R20
 037E 5A93              st -y,R21
 0380                   .dbline -1
 0380                   .dbline 120
 0380           ; }
 0380           ; /*--------------------------------------------------------------------
 0380           ; 函数全称：50ms 延时
 0380           ; 函数功能：当然是 50ms延时 啦
 0380           ; 注意事项：基于7.3728M晶振，稍微有点误差
 0380           ; 提示说明：调用delay50ms（20），得到1s延时 
 0380           ; 输    入：
 0380           ; 返    回：无
 0380           ; --------------------------------------------------------------------*/
 0380           ; void delay50ms(sint16 t)
 0380           ; {
 0380                   .dbline 122
 0380           ;       uint16 i; 
 0380           ;       for(;t>0;t--)
 0380 13C0              xjmp L116
 0382           L113:
 0382                   .dbline 123
 0382           ;               for(i=0;i<52642;i++)
 0382 4427              clr R20
 0384 5527              clr R21
 0386 02C0              xjmp L120
 0388           L117:
 0388                   .dbline 124
 0388           ;                       ; 
 0388           L118:
 0388                   .dbline 123
 0388 4F5F              subi R20,255  ; offset = 1
 038A 5F4F              sbci R21,255
 038C           L120:
 038C                   .dbline 123
 038C 82EA              ldi R24,162
 038E 9DEC              ldi R25,205
 0390 A0E0              ldi R26,0
 0392 B0E0              ldi R27,0
 0394 1A01              movw R2,R20
 0396 4424              clr R4
 0398 5524              clr R5
 039A 2816              cp R2,R24
 039C 3906              cpc R3,R25
 039E 4A06              cpc R4,R26
 03A0 5B06              cpc R5,R27
 03A2 94F3              brlt L117
 03A4           X42:
 03A4           L114:
 03A4                   .dbline 122
 03A4 0150              subi R16,1
 03A6 1040              sbci R17,0
 03A8           L116:
 03A8                   .dbline 122
 03A8 2224              clr R2
 03AA 3324              clr R3
 03AC 2016              cp R2,R16
 03AE 3106              cpc R3,R17
 03B0 44F3              brlt L113
 03B2           X43:
 03B2                   .dbline -2
 03B2           L112:
 03B2                   .dbline 0 ; func end
 03B2 5991              ld R21,y+
 03B4 4991              ld R20,y+
 03B6 0895              ret
 03B8                   .dbsym r i 20 i
 03B8                   .dbsym r t 16 I
 03B8                   .dbend
 03B8                   .dbfunc e delayus _delayus fV
 03B8           ;              i -> R20,R21
 03B8           ;              t -> R16,R17
                        .even
 03B8           _delayus::
 03B8 4A93              st -y,R20
 03BA 5A93              st -y,R21
 03BC                   .dbline -1
 03BC                   .dbline 129
 03BC           ; }
 03BC           ; 
 03BC           ; 
 03BC           ; void delayus(uint16 t)
 03BC           ; {
 03BC                   .dbline 131
 03BC           ;       uint16 i;
 03BC           ;       for(i=0;i<t;i++)
 03BC 4427              clr R20
 03BE 5527              clr R21
 03C0 02C0              xjmp L125
 03C2           L122:
 03C2                   .dbline 132
 03C2           ;               {
 03C2                   .dbline 135
 03C2           ;                       //asm("NOP\n");
 03C2           ;                       //asm("NOP\n");
 03C2           ;               }
 03C2           L123:
 03C2                   .dbline 131
 03C2 4F5F              subi R20,255  ; offset = 1
 03C4 5F4F              sbci R21,255
 03C6           L125:
 03C6                   .dbline 131
 03C6 4017              cp R20,R16
 03C8 5107              cpc R21,R17
 03CA D8F3              brlo L122
 03CC           X44:
 03CC                   .dbline -2
 03CC           L121:
 03CC                   .dbline 0 ; func end
 03CC 5991              ld R21,y+
 03CE 4991              ld R20,y+
 03D0 0895              ret
 03D2                   .dbsym r i 20 i
 03D2                   .dbsym r t 16 i
 03D2                   .dbend
 03D2                   .dbfile D:\ICC_H\PCF8563.H
 03D2                   .dbfunc e WriteAByte _WriteAByte fc
 03D2           ;            dat -> R12
 03D2           ;        wordAdr -> R10
                        .even
 03D2           _WriteAByte::
 03D2 AA92              st -y,R10
 03D4 CA92              st -y,R12
 03D6 C22E              mov R12,R18
 03D8 A02E              mov R10,R16
 03DA 2197              sbiw R28,1
 03DC                   .dbline -1
 03DC                   .dbline 89
 03DC           ; /*********************************************************************
 03DC           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 03DC           ;                                                                       
 03DC           ; 目    的:   建立PCF8563操作库
 03DC           ;       
 03DC           ; 目标系统:   基于AVR单片机
 03DC           ;                                                                               
 03DC           ; 应用软件:   ICCAVR
 03DC           ;                                                                               
 03DC           ; 版    本:   Version 1.0                                                
 03DC           ;                                                                               
 03DC           ; 圆版时间:   2005-06-25
 03DC           ;       
 03DC           ; 开发人员:   SEE
 03DC           ; 
 03DC           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 03DC           ;       
 03DC           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 03DC           ; *********************************************************************/
 03DC           ; 
 03DC           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 03DC           ; ----------------------------------------------------------------------
 03DC           ; 版本更新记录：
 03DC           ; 
 03DC           ; ----------------------------------------------------------------------
 03DC           ; 入口参数说明：
 03DC           ;       //#define WR_DADR       0xA2    //器件地址：A2 A1 A0 = 0 0 0
 03DC           ;       //#define RD_DADR       0xA3    //器件地址：A2 A1 A0 = 0 0 0
 03DC           ; 
 03DC           ; ----------------------------------------------------------------------
 03DC           ; 待定参数说明：
 03DC           ; 
 03DC           ; ----------------------------------------------------------------------        
 03DC           ; 对外变量说明：
 03DC           ; 
 03DC           ; ----------------------------------------------------------------------
 03DC           ; 对外函数说明：
 03DC           ; 
 03DC           ; ----------------------------------------------------------------------
 03DC           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 03DC           ; 
 03DC           ; #ifndef PCF8563_H
 03DC           ; #define PCF8563_H
 03DC           ; 
 03DC           ; #include "D:\ICC_H\CmmICC.H"
 03DC           ; #include "D:\ICC_H\I2C.H"
 03DC           ; 
 03DC           ; //器件地址：A0 A1 A2 = 0 0 0
 03DC           ; #ifndef WR_DADR 
 03DC           ;       #define WR_DADR         0xA2    //write device-address 
 03DC           ; #endif
 03DC           ; #ifndef RD_DADR 
 03DC           ;       #define RD_DADR         0xA3    //read device-address
 03DC           ; #endif
 03DC           ; 
 03DC           ; #define CTRL_BUF1             0x00
 03DC           ; #define CTRL_BUF2             0x01
 03DC           ; 
 03DC           ; #define SECOND_DATA_BUF       0x02
 03DC           ; #define MINUTE_DATA_BUF       0x03
 03DC           ; #define HOUR_DATA_BUF 0x04
 03DC           ; 
 03DC           ; #define DAY_DATA_BUF  0x05
 03DC           ; #define WEEK_DATA_BUF 0x06
 03DC           ; #define MONTH_DATA_BUF        0x07
 03DC           ; #define YEAR_DATA_BUF 0x08
 03DC           ; 
 03DC           ; #define MINUTE_AE_BUF 0x09
 03DC           ; #define HOUR_AE_BUF           0x0A
 03DC           ; #define DAY_AE_BUF            0x0B
 03DC           ; #define WEEK_AE_BUF           0x0C
 03DC           ; 
 03DC           ; #define CLK_FRQ_BUF           0x0D
 03DC           ; #define TIMER_CTRL_BUF        0x0E
 03DC           ; #define COUNT_VAL_BUF 0x0F
 03DC           ; 
 03DC           ; #define PCF8563_ERR           0
 03DC           ; #define PCF8563_CRR           1
 03DC           ; 
 03DC           ; /*--------------------------------------------------------------------
 03DC           ; 函数名称：
 03DC           ; 函数功能：写 1个 Byte 到相应的寄存器
 03DC           ; 注意事项：
 03DC           ; 提示说明：
 03DC           ; 输    入：
 03DC           ; 返    回：
 03DC           ; --------------------------------------------------------------------*/
 03DC           ; bool WriteAByte(uint8 wordAdr,uint8 dat)
 03DC           ; {
 03DC                   .dbline 90
 03DC           ;       if( I2C_Write(WR_DADR,wordAdr,dat)==I2C_ERR )
 03DC C882              std y+0,R12
 03DE 2A2D              mov R18,R10
 03E0 02EA              ldi R16,162
 03E2 10E0              ldi R17,0
 03E4 1CDF              xcall _I2C_Write
 03E6 0023              tst R16
 03E8 11F4              brne L127
 03EA           X45:
 03EA                   .dbline 91
 03EA           ;               return I2C_ERR;
 03EA 0027              clr R16
 03EC 01C0              xjmp L126
 03EE           L127:
 03EE                   .dbline 92
 03EE           ;       return I2C_CRR;
 03EE 01E0              ldi R16,1
 03F0                   .dbline -2
 03F0           L126:
 03F0                   .dbline 0 ; func end
 03F0 2196              adiw R28,1
 03F2 C990              ld R12,y+
 03F4 A990              ld R10,y+
 03F6 0895              ret
 03F8                   .dbsym r dat 12 c
 03F8                   .dbsym r wordAdr 10 c
 03F8                   .dbend
 03F8                   .dbfunc e ReadNByte _ReadNByte fc
 03F8           ;            num -> R14
 03F8           ;         pRdDat -> R12,R13
 03F8           ;        wordAdr -> R10
                        .even
 03F8           _ReadNByte::
 03F8 0E940000          xcall push_xgset00FC
 03FC 6901              movw R12,R18
 03FE A02E              mov R10,R16
 0400 2597              sbiw R28,5
 0402 EB84              ldd R14,y+11
 0404                   .dbline -1
 0404                   .dbline 143
 0404           ; }
 0404           ; /*--------------------------------------------------------------------
 0404           ; 函数名称：
 0404           ; 函数功能：写 N个 Byte 到相应的寄存器
 0404           ; 注意事项：
 0404           ; 提示说明：
 0404           ; 输    入：
 0404           ; 返    回：
 0404           ; --------------------------------------------------------------------*/
 0404           ; //void WriteNByte(uint8 wordAdr,uint8 num,uint8 *pWrDat)
 0404           ; //{
 0404           ; //
 0404           ; //}
 0404           ; /*--------------------------------------------------------------------
 0404           ; 函数名称：
 0404           ; 函数功能：读 1个 Byte 到相应的寄存器
 0404           ; 注意事项：
 0404           ; 提示说明：
 0404           ; 输    入：
 0404           ; 返    回：
 0404           ; --------------------------------------------------------------------*/
 0404           ; //void ReadAByte(uint8 wordAdr,uint8 *pRdDat) 
 0404           ; //{  
 0404           ; //    I2C_Start();
 0404           ; //
 0404           ; //    I2C_SendByte(WR_DADR);                  
 0404           ; //    I2C_WaitAck();
 0404           ; //
 0404           ; //    I2C_SendByte(wordAdr);                  
 0404           ; //    I2C_WaitAck();
 0404           ; //
 0404           ; //    I2C_Start();
 0404           ; //
 0404           ; //    I2C_SendByte(RD_DADR);                  
 0404           ; //    I2C_WaitAck();
 0404           ; //
 0404           ; //    I2C_RcvByte(pRdDat);
 0404           ; //    I2C_SendNoAck();
 0404           ; //
 0404           ; //    I2C_Stop();
 0404           ; //}
 0404           ; /*--------------------------------------------------------------------
 0404           ; 函数名称：
 0404           ; 函数功能：读 N个 Byte 到相应的寄存器
 0404           ; 注意事项：
 0404           ; 提示说明：
 0404           ; 输    入：
 0404           ; 返    回：
 0404           ; --------------------------------------------------------------------*/
 0404           ; bool ReadNByte(uint8 wordAdr,uint8 *pRdDat,uint8 num)
 0404           ; {  
 0404                   .dbline 144
 0404           ;       if( I2C_Read_(WR_DADR,wordAdr,RD_DADR,pRdDat,num)==I2C_ERR )
 0404 EC82              std y+4,R14
 0406 DB82              std y+3,R13
 0408 CA82              std y+2,R12
 040A 83EA              ldi R24,163
 040C 8883              std y+0,R24
 040E 2A2D              mov R18,R10
 0410 02EA              ldi R16,162
 0412 10E0              ldi R17,0
 0414 5BDF              xcall _I2C_Read_
 0416 0023              tst R16
 0418 11F4              brne L130
 041A           X46:
 041A                   .dbline 145
 041A           ;               return I2C_ERR;
 041A 0027              clr R16
 041C 01C0              xjmp L129
 041E           L130:
 041E                   .dbline 146
 041E           ;       return I2C_CRR;
 041E 01E0              ldi R16,1
 0420                   .dbline -2
 0420           L129:
 0420                   .dbline 0 ; func end
 0420 2596              adiw R28,5
 0422 0C940000          xjmp pop_xgset00FC
 0426                   .dbsym r num 14 c
 0426                   .dbsym r pRdDat 12 pc
 0426                   .dbsym r wordAdr 10 c
 0426                   .dbend
 0426                   .dbfunc e PCF8563_getTime _PCF8563_getTime fV
 0426           ;            buf -> R20,R21
                        .even
 0426           _PCF8563_getTime::
 0426 0E940000          xcall push_xgsetF00C
 042A A801              movw R20,R16
 042C 2197              sbiw R28,1
 042E                   .dbline -1
 042E                   .dbline 157
 042E           ; }
 042E           ; /*--------------------------------------------------------------------
 042E           ; 函数名称：
 042E           ; 函数功能：获取PCF8563的时间
 042E           ; 注意事项：
 042E           ; 提示说明：
 042E           ; 输    入：
 042E           ; 返    回：
 042E           ; --------------------------------------------------------------------*/
 042E           ; void PCF8563_getTime(uint8 *buf)
 042E           ; {
 042E           L133:
 042E                   .dbline 159
 042E           ; ReadAgain:    
 042E           ;       ReadNByte(SECOND_DATA_BUF,buf,3);
 042E 83E0              ldi R24,3
 0430 8883              std y+0,R24
 0432 9A01              movw R18,R20
 0434 02E0              ldi R16,2
 0436 E0DF              xcall _ReadNByte
 0438                   .dbline 160
 0438           ;       buf[0]=buf[0]&0x7f;             //get second data
 0438 FA01              movw R30,R20
 043A 8081              ldd R24,z+0
 043C 8F77              andi R24,127
 043E 8083              std z+0,R24
 0440                   .dbline 161
 0440           ;       if(buf[0]==0)
 0440 2080              ldd R2,z+0
 0442 2220              tst R2
 0444 09F4              brne L134
 0446           X47:
 0446                   .dbline 162
 0446           ;               goto ReadAgain;         //if "second==0"，read again for avoid mistake
 0446 F3CF              xjmp L133
 0448           L134:
 0448                   .dbline 163
 0448           ;       buf[1]=buf[1]&0x7f;             //get minute data
 0448 CA01              movw R24,R20
 044A 0196              adiw R24,1
 044C FC01              movw R30,R24
 044E 8081              ldd R24,z+0
 0450 8F77              andi R24,127
 0452 8083              std z+0,R24
 0454                   .dbline 164
 0454           ;       buf[2]=buf[2]&0x3f;             //get hour data
 0454 CA01              movw R24,R20
 0456 0296              adiw R24,2
 0458 FC01              movw R30,R24
 045A 8081              ldd R24,z+0
 045C 8F73              andi R24,63
 045E 8083              std z+0,R24
 0460                   .dbline 166
 0460           ; 
 0460           ;       buf[0]=changeHexToInt(buf[0]);
 0460 FA01              movw R30,R20
 0462 A080              ldd R10,z+0
 0464 BB24              clr R11
 0466 10E1              ldi R17,16
 0468 0A2D              mov R16,R10
 046A 0E940000          xcall mod8u
 046E 202E              mov R2,R16
 0470 1A2D              mov R17,R10
 0472 1295              swap R17
 0474 1F70              andi R17,#0x0F
 0476 0AE0              ldi R16,10
 0478 0103              mulsu R16,R17
 047A 302C              mov R3,R0
 047C 320C              add R3,R2
 047E FA01              movw R30,R20
 0480 3082              std z+0,R3
 0482                   .dbline 167
 0482           ;       buf[1]=changeHexToInt(buf[1]);
 0482 BF01              movw R22,R30
 0484 6F5F              subi R22,255  ; offset = 1
 0486 7F4F              sbci R23,255
 0488 FB01              movw R30,R22
 048A A080              ldd R10,z+0
 048C BB24              clr R11
 048E 10E1              ldi R17,16
 0490 0A2D              mov R16,R10
 0492 0E940000          xcall mod8u
 0496 202E              mov R2,R16
 0498 1A2D              mov R17,R10
 049A 1295              swap R17
 049C 1F70              andi R17,#0x0F
 049E 0AE0              ldi R16,10
 04A0 0103              mulsu R16,R17
 04A2 302C              mov R3,R0
 04A4 320C              add R3,R2
 04A6 FB01              movw R30,R22
 04A8 3082              std z+0,R3
 04AA                   .dbline 168
 04AA           ;       buf[2]=changeHexToInt(buf[2]);
 04AA 4E5F              subi R20,254  ; offset = 2
 04AC 5F4F              sbci R21,255
 04AE FA01              movw R30,R20
 04B0 A080              ldd R10,z+0
 04B2 BB24              clr R11
 04B4 10E1              ldi R17,16
 04B6 0A2D              mov R16,R10
 04B8 0E940000          xcall mod8u
 04BC 202E              mov R2,R16
 04BE 1A2D              mov R17,R10
 04C0 1295              swap R17
 04C2 1F70              andi R17,#0x0F
 04C4 0AE0              ldi R16,10
 04C6 0103              mulsu R16,R17
 04C8 302C              mov R3,R0
 04CA 320C              add R3,R2
 04CC FA01              movw R30,R20
 04CE 3082              std z+0,R3
 04D0                   .dbline -2
 04D0           L132:
 04D0                   .dbline 0 ; func end
 04D0 2196              adiw R28,1
 04D2 0C940000          xjmp pop_xgsetF00C
 04D6                   .dbsym r buf 20 pc
 04D6                   .dbend
 04D6                   .dbfunc e PCF8563_setTime _PCF8563_setTime fV
 04D6           ;         second -> R10
 04D6           ;         minute -> R12
 04D6           ;           hour -> R14
                        .even
 04D6           _PCF8563_setTime::
 04D6 0E940000          xcall push_xgset00FC
 04DA C22E              mov R12,R18
 04DC E02E              mov R14,R16
 04DE AE80              ldd R10,y+6
 04E0                   .dbline -1
 04E0                   .dbline 179
 04E0           ; }
 04E0           ; /*--------------------------------------------------------------------
 04E0           ; 函数名称：
 04E0           ; 函数功能：设置PCF8563的时间
 04E0           ; 注意事项：
 04E0           ; 提示说明：
 04E0           ; 输    入：
 04E0           ; 返    回：
 04E0           ; --------------------------------------------------------------------*/
 04E0           ; void PCF8563_setTime(uint8 hour,uint8 minute,uint8 second)
 04E0           ; {
 04E0                   .dbline 180
 04E0           ;       hour=changeIntToHex(hour);              //将数据的Dex格式转换为Hex格式
 04E0 1AE0              ldi R17,10
 04E2 0E2D              mov R16,R14
 04E4 0E940000          xcall mod8u
 04E8 202E              mov R2,R16
 04EA 1AE0              ldi R17,10
 04EC 0E2D              mov R16,R14
 04EE 0E940000          xcall div8u
 04F2 802F              mov R24,R16
 04F4 8F70              andi R24,#0x0F
 04F6 8295              swap R24
 04F8 E82E              mov R14,R24
 04FA E20C              add R14,R2
 04FC                   .dbline 181
 04FC           ;       minute=changeIntToHex(minute);
 04FC 1AE0              ldi R17,10
 04FE 0C2D              mov R16,R12
 0500 0E940000          xcall mod8u
 0504 202E              mov R2,R16
 0506 1AE0              ldi R17,10
 0508 0C2D              mov R16,R12
 050A 0E940000          xcall div8u
 050E 802F              mov R24,R16
 0510 8F70              andi R24,#0x0F
 0512 8295              swap R24
 0514 C82E              mov R12,R24
 0516 C20C              add R12,R2
 0518                   .dbline 182
 0518           ;       second=changeIntToHex(second);
 0518 1AE0              ldi R17,10
 051A 0A2D              mov R16,R10
 051C 0E940000          xcall mod8u
 0520 202E              mov R2,R16
 0522 1AE0              ldi R17,10
 0524 0A2D              mov R16,R10
 0526 0E940000          xcall div8u
 052A 802F              mov R24,R16
 052C 8F70              andi R24,#0x0F
 052E 8295              swap R24
 0530 A82E              mov R10,R24
 0532 A20C              add R10,R2
 0534                   .dbline 184
 0534           ; 
 0534           ;       WriteAByte(HOUR_DATA_BUF,hour);
 0534 2E2D              mov R18,R14
 0536 04E0              ldi R16,4
 0538 4CDF              xcall _WriteAByte
 053A                   .dbline 185
 053A           ;       WriteAByte(MINUTE_DATA_BUF,minute);
 053A 2C2D              mov R18,R12
 053C 03E0              ldi R16,3
 053E 49DF              xcall _WriteAByte
 0540                   .dbline 186
 0540           ;       WriteAByte(SECOND_DATA_BUF,second);
 0540 2A2D              mov R18,R10
 0542 02E0              ldi R16,2
 0544 46DF              xcall _WriteAByte
 0546                   .dbline -2
 0546           L136:
 0546                   .dbline 0 ; func end
 0546 0C940000          xjmp pop_xgset00FC
 054A                   .dbsym r second 10 c
 054A                   .dbsym r minute 12 c
 054A                   .dbsym r hour 14 c
 054A                   .dbend
 054A                   .dbfunc e PCF8563_init _PCF8563_init fV
                        .even
 054A           _PCF8563_init::
 054A                   .dbline -1
 054A                   .dbline 221
 054A           ; }
 054A           ; /*--------------------------------------------------------------------
 054A           ; 函数名称：
 054A           ; 函数功能：获取PCF8563的日期
 054A           ; 注意事项：
 054A           ; 提示说明：
 054A           ; 输    入：
 054A           ; 返    回：
 054A           ; --------------------------------------------------------------------*/
 054A           ; //void PCF8563_getDate()
 054A           ; //{
 054A           ; //
 054A           ; //}
 054A           ; /*--------------------------------------------------------------------
 054A           ; 函数名称：
 054A           ; 函数功能：设置PCF8563的日期
 054A           ; 注意事项：
 054A           ; 提示说明：
 054A           ; 输    入：
 054A           ; 返    回：
 054A           ; --------------------------------------------------------------------*/
 054A           ; //void PCF8563_setDate()
 054A           ; //{
 054A           ; //
 054A           ; //}
 054A           ; /*--------------------------------------------------------------------
 054A           ; 函数名称：
 054A           ; 函数功能：初始化PCF8563
 054A           ; 注意事项：
 054A           ; 提示说明：
 054A           ; 输    入：
 054A           ; 返    回：
 054A           ; --------------------------------------------------------------------*/
 054A           ; void PCF8563_init()
 054A           ; {
 054A                   .dbline 222
 054A           ;       WriteAByte(CTRL_BUF1,0x00);                     //basic setting
 054A 2227              clr R18
 054C 0027              clr R16
 054E 41DF              xcall _WriteAByte
 0550                   .dbline 223
 0550           ;       WriteAByte(CTRL_BUF2,0x12);                     //alarm enable
 0550 22E1              ldi R18,18
 0552 01E0              ldi R16,1
 0554                   .dbline -2
 0554           L137:
 0554                   .dbline 0 ; func end
 0554 3ECF              xjmp _WriteAByte
 0556                   .dbend
 0556                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563\PCF8563.C
 0556                   .dbfunc e errDisp _errDisp fV
                        .even
 0556           _errDisp::
 0556                   .dbline -1
 0556                   .dbline 60
 0556           ; /*********************************************************************
 0556           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0556           ;                                                                           
 0556           ; 项目名称:   PCF8563示例程序
 0556           ;               
 0556           ; 目标系统:   “DVK501” && “M128 EX+”
 0556           ; 
 0556           ; 应用软件:   ICCAVR 6.31A                                             
 0556           ;                                                                               
 0556           ; 版    本:   V1.0 
 0556           ;                                                         
 0556           ; 圆版时间:   2009-7-1
 0556           ; 
 0556           ; 开发人员:   zz
 0556           ; 
 0556           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0556           ;               
 0556           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0556           ; *********************************************************************/
 0556           ; 
 0556           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0556           ; ----------------------------------------------------------------------
 0556           ; 版本更新记录：
 0556           ; 
 0556           ; ----------------------------------------------------------------------
 0556           ; 实验内容：
 0556           ; 使用DVK501上的LED，观察PCF8563反馈的时间
 0556           ; ----------------------------------------------------------------------
 0556           ; 硬件连接： 
 0556           ;                         DVK501                                 M128 EX+
 0556           ;                               PA7:0   ---------         LED7:0
 0556           ;                               B1              ---------         SDA
 0556           ;                               B2          ---------     SCL
 0556           ; 
 0556           ; ----------------------------------------------------------------------
 0556           ; 注意事项：
 0556           ; （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
 0556           ; （2）请详细阅读“使用必读”及相关资料。
 0556           ; ----------------------------------------------------------------------
 0556           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 0556           ; 
 0556           ; #include <iom128v.h>
 0556           ; 
 0556           ; #define WR_DADR               0xA2
 0556           ; #define RD_DADR               0xA3
 0556           ; #include "D:\ICC_H\PCF8563.H"
 0556           ; 
 0556           ; #define DISP_DDR      DDRA
 0556           ; #define DISP_PORT     PORTA
 0556           ; 
 0556           ; /*--------------------------------------------------------------------
 0556           ; 函数全称：
 0556           ; 函数功能：
 0556           ; 注意事项：
 0556           ; 提示说明：
 0556           ; 输    入：
 0556           ; 返    回：
 0556           ; --------------------------------------------------------------------*/
 0556           ; void errDisp()                        //错误显示
 0556           ; {
 0556                   .dbline 61
 0556           ;       DISP_PORT = 0XAA;
 0556 8AEA              ldi R24,170
 0558 8BBB              out 0x1b,R24
 055A                   .dbline 62
 055A           ;       delay50ms(2);
 055A 02E0              ldi R16,2
 055C 10E0              ldi R17,0
 055E 0EDF              xcall _delay50ms
 0560                   .dbline 63
 0560           ;       DISP_PORT = 0X00;
 0560 2224              clr R2
 0562 2BBA              out 0x1b,R2
 0564                   .dbline 64
 0564           ;       delay50ms(2);
 0564 02E0              ldi R16,2
 0566 10E0              ldi R17,0
 0568 09DF              xcall _delay50ms
 056A                   .dbline 65
 056A           ;       DISP_PORT = 0X55;
 056A 85E5              ldi R24,85
 056C 8BBB              out 0x1b,R24
 056E                   .dbline 66
 056E           ;       delay50ms(2);
 056E 02E0              ldi R16,2
 0570 10E0              ldi R17,0
 0572 04DF              xcall _delay50ms
 0574                   .dbline 67
 0574           ;       DISP_PORT = 0X00;
 0574 2224              clr R2
 0576 2BBA              out 0x1b,R2
 0578                   .dbline 68
 0578           ;       delay50ms(2);
 0578 02E0              ldi R16,2
 057A 10E0              ldi R17,0
 057C                   .dbline -2
 057C           L138:
 057C                   .dbline 0 ; func end
 057C FFCE              xjmp _delay50ms
 057E                   .dbend
 057E                   .dbfunc e twi_init _twi_init fV
                        .even
 057E           _twi_init::
 057E                   .dbline -1
 057E                   .dbline 79
 057E           ; }
 057E           ; /*--------------------------------------------------------------------
 057E           ; 函数全称：
 057E           ; 函数功能：
 057E           ; 注意事项：
 057E           ; 提示说明：假设系统时钟为16M，则TWI波特率=CLK/(16+2*(TWBR)*4)=400K
 057E           ; 输    入：
 057E           ; 返    回：
 057E           ; --------------------------------------------------------------------*/
 057E           ; void twi_init()                       //TWI(I2C)初始化
 057E           ; {
 057E                   .dbline 80
 057E           ;       TWBR = 0X03;            //设置TWI波特率  
 057E 83E0              ldi R24,3
 0580 80937000          sts 112,R24
 0584                   .dbline 81
 0584           ;       TWSR &= 0XFC;           //设置TWI预分频 为 1
 0584 80917100          lds R24,113
 0588 8C7F              andi R24,252
 058A 80937100          sts 113,R24
 058E                   .dbline -2
 058E           L139:
 058E                   .dbline 0 ; func end
 058E 0895              ret
 0590                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563\PCF8563.C
 0000           L141:
 0000                   .blkb 2
                        .area idata
 0000 0001              .byte 0,1
                        .area data(ram, con, rel)
 0002                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563\PCF8563.C
 0002                   .blkb 1
                        .area idata
 0002 02                .byte 2
                        .area data(ram, con, rel)
 0003                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563\PCF8563.C
                        .area text(rom, con, rel)
 0590                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563\PCF8563.C
 0590                   .dbfunc e main _main fV
 0590           ;           time -> y+1
                        .even
 0590           _main::
 0590 2497              sbiw R28,4
 0592                   .dbline -1
 0592                   .dbline 92
 0592           ; }
 0592           ; /*--------------------------------------------------------------------
 0592           ; 函数全称：
 0592           ; 函数功能：
 0592           ; 注意事项：
 0592           ; 提示说明：
 0592           ; 输    入：
 0592           ; 返    回：
 0592           ; --------------------------------------------------------------------*/
 0592           ; void main()
 0592           ; {
 0592                   .dbline 93
 0592           ;       uint8 time[3]={0,1,2};
 0592 80E0              ldi R24,<L141
 0594 90E0              ldi R25,>L141
 0596 FE01              movw R30,R28
 0598 3196              adiw R30,1
 059A 03E0              ldi R16,3
 059C 10E0              ldi R17,0
 059E FA93              st -y,R31
 05A0 EA93              st -y,R30
 05A2 9A93              st -y,R25
 05A4 8A93              st -y,R24
 05A6 0E940000          xcall asgnblk
 05AA                   .dbline 95
 05AA           ;       
 05AA           ;       DISP_DDR = 0XFF;
 05AA 8FEF              ldi R24,255
 05AC 8ABB              out 0x1a,R24
 05AE                   .dbline 96
 05AE           ;       twi_init();     
 05AE E7DF              xcall _twi_init
 05B0                   .dbline 97
 05B0           ;       PCF8563_init(); 
 05B0 CCDF              xcall _PCF8563_init
 05B2                   .dbline 98
 05B2           ;       PCF8563_setTime(9,32,7); 
 05B2 87E0              ldi R24,7
 05B4 8883              std y+0,R24
 05B6 20E2              ldi R18,32
 05B8 09E0              ldi R16,9
 05BA 8DDF              xcall _PCF8563_setTime
 05BC 06C0              xjmp L143
 05BE           L142:
 05BE                   .dbline 101
 05BE           ;       
 05BE           ;       while(1)
 05BE           ;       {       
 05BE                   .dbline 102
 05BE           ;               PCF8563_getTime(time);
 05BE 8E01              movw R16,R28
 05C0 0F5F              subi R16,255  ; offset = 1
 05C2 1F4F              sbci R17,255
 05C4 30DF              xcall _PCF8563_getTime
 05C6                   .dbline 103
 05C6           ;               DISP_PORT = time[0];
 05C6 2980              ldd R2,y+1
 05C8 2BBA              out 0x1b,R2
 05CA                   .dbline 104
 05CA           ;       }
 05CA           L143:
 05CA                   .dbline 100
 05CA F9CF              xjmp L142
 05CC           X48:
 05CC                   .dbline -2
 05CC           L140:
 05CC                   .dbline 0 ; func end
 05CC 2496              adiw R28,4
 05CE 0895              ret
 05D0                   .dbsym l time 1 A[3:3]c
 05D0                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\PCF856~1\PCF8563\PCF8563.C
 0000           _dataElem::
 0000                   .blkb 6
 0006                   .dbfile D:\ICC_H\Software.H
 0006                   .dbsym e dataElem _dataElem A[6:6]c
 0006           ; }
