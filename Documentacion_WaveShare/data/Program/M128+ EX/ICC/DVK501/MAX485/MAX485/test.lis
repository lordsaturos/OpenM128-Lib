                        .module test.c
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\..\M128_E~1\MAX485~1\MAX485\test.c
 0000                   .dbfile D:\ICC_H\Software.H
 0000                   .dbfunc e speaData _speaData fV
 0000           ;              y -> y+4
 0000           ;              j -> y+0
 0000           ;              i -> R10
 0000           ;            len -> R12
 0000           ;            dat -> y+16
                        .even
 0000           _speaData::
 0000 00D0              rcall push_arg4
 0002 00D0              rcall push_xgsetF03C
 0004 2897              sbiw R28,8
 0006 CC88              ldd R12,y+20
 0008                   .dbline -1
 0008                   .dbline 116
 0008           ; /*********************************************************************
 0008           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0008           ;                                                                       
 0008           ; 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
 0008           ;       
 0008           ; 目标系统:   基于AVR单片机
 0008           ;                                                                               
 0008           ; 应用软件:   ICCAVR
 0008           ;                                                                               
 0008           ; 版    本:   Version 1.0                                                       
 0008           ;                                                                               
 0008           ; 圆版时间:   2005-06-25
 0008           ;       
 0008           ; 开发人员:   SEE
 0008           ; 
 0008           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0008           ;       
 0008           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0008           ; *********************************************************************/
 0008           ; 
 0008           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0008           ; ----------------------------------------------------------------------
 0008           ; 版本更新记录：
 0008           ; 
 0008           ; ----------------------------------------------------------------------
 0008           ; 入口参数说明：
 0008           ; 
 0008           ; ----------------------------------------------------------------------
 0008           ; 待定参数说明：
 0008           ; 
 0008           ; ----------------------------------------------------------------------        
 0008           ; 对外变量说明：
 0008           ;     
 0008           ; ----------------------------------------------------------------------
 0008           ; 对外函数说明：
 0008           ;    
 0008           ; ----------------------------------------------------------------------
 0008           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 0008           ; 
 0008           ; #ifndef Software_H
 0008           ; #define Software_H
 0008           ; 
 0008           ; #include <math.h>
 0008           ; #include <string.h>
 0008           ; 
 0008           ; /* 兼容一般程序员的常用写法 */
 0008           ; typedef unsigned char uchar;
 0008           ; typedef unsigned int  uint;
 0008           ; typedef unsigned long ulong;
 0008           ; typedef signed char           schar;
 0008           ; typedef signed int            sint;
 0008           ; typedef signed long           slong;
 0008           ; 
 0008           ; /* 为方便移植，建议使用下面写法 */
 0008           ; typedef unsigned char bool;
 0008           ; typedef unsigned char uint8;
 0008           ; typedef unsigned int  uint16;
 0008           ; typedef unsigned long   uint32;
 0008           ; typedef signed  char  sint8;
 0008           ; typedef signed        int             sint16;
 0008           ; typedef signed        long    sint32;
 0008           ; typedef signed  char  int8;
 0008           ; typedef signed  int           int16;
 0008           ; typedef signed  long  int32;
 0008           ; 
 0008           ; /* 下面写法一般不推荐 */
 0008           ; //typedef unsigned char ubyte;
 0008           ; //typedef unsigned int        uword;
 0008           ; //typedef unsigned long udword;
 0008           ; //typedef signed   char       sbyte;
 0008           ; //typedef signed   int        sword;
 0008           ; //typedef signed   long       sdword;
 0008           ; 
 0008           ; /* 一般程序定义的默认值 */
 0008           ; //#define NULL                        0
 0008           ; //#define EOF                 -1
 0008           ; //#define TRUE                1
 0008           ; //#define FALSE               0
 0008           ; //#define YES                 1
 0008           ; //#define NO                          0
 0008           ; //#define ON                  1
 0008           ; //#define OFF                 0
 0008           ; //#define ENABLE              1
 0008           ; //#define DISABLE             0
 0008           ; //#define CRR                 1
 0008           ; //#define ERR                 0
 0008           ; //#define RIGHT                       1
 0008           ; //#define WRONG                       0
 0008           ; //#define SUCCESS             1
 0008           ; //#define FAILURE             0
 0008           ; //#define PI                  3.1415926       //3.1415926535897932
 0008           ; 
 0008           ; /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
 0008           ; //#define _CALLOC(a)          ( (a *)calloc(n,sizeof(a)) )
 0008           ; //#define _MALLOC(a)          ( (a *)malloc(sizeof(a)) )
 0008           ; //#define _MIN(a,b)                   ( (a) < (b) ? (a) : (b) )
 0008           ; //#define _MAX(a,b)                   ( (a) > (b) ? (a) : (b) )
 0008           ; //#define _EXCHANGE(a,b)      { int t; t=a; a=b; b=t; }
 0008           ; //#define _TOLOWER(c)         ( (c)+32 )
 0008           ; //#define _TOUPPER(c)         ( (c)-32 )
 0008           ; 
 0008           ; //#ifndef BIT
 0008           ; //#define BIT(x)      ( 1<<(x) )
 0008           ; //#endif
 0008           ; 
 0008           ; /*--------------------------------------------------------------------
 0008           ; 函数全称：数据拆字
 0008           ; 函数功能：
 0008           ; 注意事项：D<=999999,C<=6
 0008           ; 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
 0008           ; 输    入：
 0008           ; 返    回：无
 0008           ; --------------------------------------------------------------------*/
 0008           ; uint8 dataElem[6];
 0008           ; void speaData(uint32 dat,sint8 len)
 0008           ; {
 0008                   .dbline 119
 0008           ;     uint8 i;
 0008           ;     uint32 j,y;
 0008           ;     for(i=0,j=1;i<len;i++)
 0008 AA24              clr R10
 000A 81E0              ldi R24,1
 000C 8883              std y+0,R24
 000E 80E0              ldi R24,0
 0010 8983              std y+1,R24
 0012 8A83              std y+2,R24
 0014 8B83              std y+3,R24
 0016 39C0              rjmp L5
 0018           L2:
 0018                   .dbline 120
 0018           ;     {
 0018                   .dbline 121
 0018           ;         y=dat/j;
 0018 2880              ldd R2,y+0
 001A 3980              ldd R3,y+1
 001C 4A80              ldd R4,y+2
 001E 5B80              ldd R5,y+3
 0020 0889              ldd R16,y+16
 0022 1989              ldd R17,y+17
 0024 2A89              ldd R18,y+18
 0026 3B89              ldd R19,y+19
 0028 5A92              st -y,R5
 002A 4A92              st -y,R4
 002C 3A92              st -y,R3
 002E 2A92              st -y,R2
 0030 00D0              rcall div32u
 0032 0C83              std y+4,R16
 0034 1D83              std y+5,R17
 0036 2E83              std y+6,R18
 0038 3F83              std y+7,R19
 003A                   .dbline 122
 003A           ;         dataElem[i]=y%10;
 003A 4AE0              ldi R20,10
 003C 50E0              ldi R21,0
 003E 60E0              ldi R22,0
 0040 70E0              ldi R23,0
 0042 0C81              ldd R16,y+4
 0044 1D81              ldd R17,y+5
 0046 2E81              ldd R18,y+6
 0048 3F81              ldd R19,y+7
 004A 7A93              st -y,R23
 004C 6A93              st -y,R22
 004E 5A93              st -y,R21
 0050 4A93              st -y,R20
 0052 00D0              rcall mod32u
 0054 80E0              ldi R24,<_dataElem
 0056 90E0              ldi R25,>_dataElem
 0058 EA2D              mov R30,R10
 005A FF27              clr R31
 005C E80F              add R30,R24
 005E F91F              adc R31,R25
 0060 0083              std z+0,R16
 0062                   .dbline 123
 0062           ;         j*=10;
 0062 2880              ldd R2,y+0
 0064 3980              ldd R3,y+1
 0066 4A80              ldd R4,y+2
 0068 5B80              ldd R5,y+3
 006A 4AE0              ldi R20,10
 006C 50E0              ldi R21,0
 006E 60E0              ldi R22,0
 0070 70E0              ldi R23,0
 0072 5A92              st -y,R5
 0074 4A92              st -y,R4
 0076 3A92              st -y,R3
 0078 2A92              st -y,R2
 007A 8A01              movw R16,R20
 007C 9B01              movw R18,R22
 007E 00D0              rcall empy32u
 0080 0883              std y+0,R16
 0082 1983              std y+1,R17
 0084 2A83              std y+2,R18
 0086 3B83              std y+3,R19
 0088                   .dbline 124
 0088           ;     }
 0088           L3:
 0088                   .dbline 119
 0088 A394              inc R10
 008A           L5:
 008A                   .dbline 119
 008A 2C2C              mov R2,R12
 008C 3324              clr R3
 008E 27FC              sbrc R2,7
 0090 3094              com R3
 0092 4A2C              mov R4,R10
 0094 5524              clr R5
 0096 4214              cp R4,R2
 0098 5304              cpc R5,R3
 009A 0CF4              brge X1
 009C BDCF              rjmp L2
 009E           X1:
 009E           X0:
 009E                   .dbline -2
 009E           L1:
 009E                   .dbline 0 ; func end
 009E 2896              adiw R28,8
 00A0 00D0              rcall pop_xgsetF03C
 00A2 2496              adiw R28,4
 00A4 0895              ret
 00A6                   .dbsym l y 4 l
 00A6                   .dbsym l j 0 l
 00A6                   .dbsym r i 10 c
 00A6                   .dbsym r len 12 C
 00A6                   .dbsym l dat 16 l
 00A6                   .dbend
 00A6                   .dbfile D:\ICC_H\I2C.H
 00A6                   .dbfunc e I2C_Start _I2C_Start fc
                        .even
 00A6           _I2C_Start::
 00A6                   .dbline -1
 00A6                   .dbline 126
 00A6           ; /*********************************************************************
 00A6           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 00A6           ;                                                                       
 00A6           ; 目    的:   建立I2C操作库
 00A6           ;       
 00A6           ; 目标系统:   基于AVR单片机
 00A6           ;                                                                               
 00A6           ; 应用软件:   ICCAVR
 00A6           ;                                                                               
 00A6           ; 版    本:   Version 1.0                                                          
 00A6           ;                                                                               
 00A6           ; 圆版时间:   2005-06-25
 00A6           ;       
 00A6           ; 开发人员:   SEE
 00A6           ; 
 00A6           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 00A6           ;       
 00A6           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 00A6           ; *********************************************************************/
 00A6           ; 
 00A6           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 版本更新记录：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 入口参数说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 待定参数说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------        
 00A6           ; 对外变量说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 对外函数说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 00A6           ; 
 00A6           ; #ifndef I2C_H
 00A6           ; #define I2C_H
 00A6           ; 
 00A6           ; /* TWSR values (not bits) */
 00A6           ; /* Master */
 00A6           ; #define I2C_START                     0x08
 00A6           ; #define I2C_RESTART                   0x10
 00A6           ; 
 00A6           ; /* Master Transmitter */
 00A6           ; #define I2C_MT_SLA_ACK                0x18
 00A6           ; #define I2C_MT_SLA_NACK               0x20
 00A6           ; #define I2C_MT_DATA_ACK               0x28
 00A6           ; #define I2C_MT_DATA_NACK      0x30
 00A6           ; #define I2C_MT_ARB_LOST               0x38
 00A6           ; 
 00A6           ; /* Master Receiver */
 00A6           ; #define I2C_MR_ARB_LOST               0x38
 00A6           ; #define I2C_MR_SLA_ACK                0x40
 00A6           ; #define I2C_MR_SLA_NACK               0x48
 00A6           ; #define I2C_MR_DATA_ACK               0x50
 00A6           ; #define I2C_MR_DATA_NACK      0x58
 00A6           ; 
 00A6           ; /* Slave Transmitter */
 00A6           ; #define I2C_ST_SLA_ACK                        0xA8
 00A6           ; #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
 00A6           ; #define I2C_ST_DATA_ACK                       0xB8
 00A6           ; #define I2C_ST_DATA_NACK              0xC0
 00A6           ; #define I2C_ST_LAST_DATA              0xC8
 00A6           ; 
 00A6           ; /* Slave Receiver */
 00A6           ; #define I2C_SR_SLA_ACK                                0x60
 00A6           ; #define I2C_SR_ARB_LOST_SLA_ACK               0x68
 00A6           ; #define I2C_SR_GCALL_ACK                      0x70
 00A6           ; #define I2C_SR_ARB_LOST_GCALL_ACK     0x78
 00A6           ; #define I2C_SR_DATA_ACK                               0x80
 00A6           ; #define I2C_SR_DATA_NACK                      0x88
 00A6           ; #define I2C_SR_GCALL_DATA_ACK         0x90
 00A6           ; #define I2C_SR_GCALL_DATA_NACK                0x98
 00A6           ; #define I2C_SR_STOP                                   0xA0
 00A6           ; 
 00A6           ; /* Misc */
 00A6           ; #define I2C_NO_INFO                   0xF8
 00A6           ; #define I2C_BUS_ERROR         0x00
 00A6           ; 
 00A6           ; /*
 00A6           ;  * The lower 3 bits of TWSR are reserved on the ATmega163.
 00A6           ;  * The 2 LSB carry the prescaler bits on the newer ATmegas.
 00A6           ;  */
 00A6           ; #define I2C_STATUS_MASK       (_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
 00A6           ; #define I2C_STATUS            (TWSR & I2C_STATUS_MASK)
 00A6           ; 
 00A6           ; /*
 00A6           ;  * R/~W bit in SLA+R/W address field.
 00A6           ;  */
 00A6           ; #define I2C_READ              1
 00A6           ; #define I2C_WRITE             0
 00A6           ; 
 00A6           ; #define I2CStart()            (TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
 00A6           ; #define I2CStop()             (TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
 00A6           ; #define I2CWaitAck()  {while(!(TWCR&(1<<TWINT)));}
 00A6           ; #define I2CChkAck()   (TWSR&0xf8)                                     //check ack
 00A6           ; #define I2CSendAck()  (TWCR|=(1<<TWEA))
 00A6           ; #define I2CSendNoAck()        (TWCR&=~(1<<TWEA))
 00A6           ; #define I2CSendByte(x)        {TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
 00A6           ; #define I2CRcvNckByte()       (TWCR=(1<<TWINT)|(1<<TWEN))
 00A6           ; #define I2CRcvAckByte()       (TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
 00A6           ; 
 00A6           ; /* For Program */
 00A6           ; #define I2C_Stop()            I2CStop()
 00A6           ; #define I2C_SendAck() I2CSendAck()
 00A6           ; #define I2C_SendNoAck() I2CSendNoAck()
 00A6           ; #define I2C_WaitAck() I2CWaitAck()
 00A6           ; 
 00A6           ; /* I2C Config */
 00A6           ; #define I2C_ERR                       0
 00A6           ; #define I2C_CRR                       1
 00A6           ; 
 00A6           ; /*--------------------------------------------------------------------
 00A6           ; 函数名称：I2C Start
 00A6           ; 函数功能：
 00A6           ; 注意事项：
 00A6           ; 提示说明：
 00A6           ; 输    入：
 00A6           ; 返    回：
 00A6           ; --------------------------------------------------------------------*/
 00A6           ; bool I2C_Start()                                      
 00A6           ; {
 00A6                   .dbline 127
 00A6           ;       I2CStart();                                             
 00A6 84EA              ldi R24,164
 00A8 80937400          sts 116,R24
 00AC                   .dbline 128
 00AC           ;       I2CWaitAck();
 00AC           L7:
 00AC                   .dbline 128
 00AC           L8:
 00AC                   .dbline 128
 00AC 20907400          lds R2,116
 00B0 27FE              sbrs R2,7
 00B2 FCCF              rjmp L7
 00B4           X2:
 00B4                   .dbline 128
 00B4                   .dbline 128
 00B4                   .dbline 129
 00B4           ;       if( I2CChkAck()!=I2C_START ) 
 00B4 80917100          lds R24,113
 00B8 887F              andi R24,248
 00BA 8830              cpi R24,8
 00BC 11F0              breq L10
 00BE           X3:
 00BE                   .dbline 130
 00BE           ;               return I2C_ERR;
 00BE 0027              clr R16
 00C0 01C0              rjmp L6
 00C2           L10:
 00C2                   .dbline 131
 00C2           ;       return I2C_CRR;
 00C2 01E0              ldi R16,1
 00C4                   .dbline -2
 00C4           L6:
 00C4                   .dbline 0 ; func end
 00C4 0895              ret
 00C6                   .dbend
 00C6                   .dbfunc e I2C_Restart _I2C_Restart fc
                        .even
 00C6           _I2C_Restart::
 00C6                   .dbline -1
 00C6                   .dbline 142
 00C6           ; }
 00C6           ; /*--------------------------------------------------------------------
 00C6           ; 函数名称：I2C ReStart
 00C6           ; 函数功能：
 00C6           ; 注意事项：
 00C6           ; 提示说明：
 00C6           ; 输    入：
 00C6           ; 返    回：
 00C6           ; --------------------------------------------------------------------*/
 00C6           ; bool I2C_Restart()                                    
 00C6           ; {
 00C6                   .dbline 143
 00C6           ;       I2CStart();                                             
 00C6 84EA              ldi R24,164
 00C8 80937400          sts 116,R24
 00CC                   .dbline 144
 00CC           ;       I2CWaitAck();
 00CC           L13:
 00CC                   .dbline 144
 00CC           L14:
 00CC                   .dbline 144
 00CC 20907400          lds R2,116
 00D0 27FE              sbrs R2,7
 00D2 FCCF              rjmp L13
 00D4           X4:
 00D4                   .dbline 144
 00D4                   .dbline 144
 00D4                   .dbline 145
 00D4           ;       if( I2CChkAck()!=I2C_RESTART ) 
 00D4 80917100          lds R24,113
 00D8 887F              andi R24,248
 00DA 8031              cpi R24,16
 00DC 11F0              breq L16
 00DE           X5:
 00DE                   .dbline 146
 00DE           ;               return I2C_ERR;
 00DE 0027              clr R16
 00E0 01C0              rjmp L12
 00E2           L16:
 00E2                   .dbline 147
 00E2           ;       return I2C_CRR;
 00E2 01E0              ldi R16,1
 00E4                   .dbline -2
 00E4           L12:
 00E4                   .dbline 0 ; func end
 00E4 0895              ret
 00E6                   .dbend
 00E6                   .dbfunc e I2C_SendWrDAdr _I2C_SendWrDAdr fc
 00E6           ;         wrDAdr -> R16
                        .even
 00E6           _I2C_SendWrDAdr::
 00E6                   .dbline -1
 00E6                   .dbline 158
 00E6           ; }
 00E6           ; /*--------------------------------------------------------------------
 00E6           ; 函数名称：发送 7位 器件写地址: XXXX XXX0
 00E6           ; 函数功能：
 00E6           ; 注意事项：
 00E6           ; 提示说明：
 00E6           ; 输    入：
 00E6           ; 返    回：
 00E6           ; --------------------------------------------------------------------*/
 00E6           ; bool I2C_SendWrDAdr(uint8 wrDAdr)     
 00E6           ; {
 00E6                   .dbline 159
 00E6           ;       I2CSendByte(wrDAdr);                    //设置 器件写地址
 00E6                   .dbline 159
 00E6 00937300          sts 115,R16
 00EA                   .dbline 159
 00EA 84E8              ldi R24,132
 00EC 80937400          sts 116,R24
 00F0                   .dbline 159
 00F0                   .dbline 159
 00F0                   .dbline 160
 00F0           ;       I2CWaitAck();
 00F0           L19:
 00F0                   .dbline 160
 00F0           L20:
 00F0                   .dbline 160
 00F0 20907400          lds R2,116
 00F4 27FE              sbrs R2,7
 00F6 FCCF              rjmp L19
 00F8           X6:
 00F8                   .dbline 160
 00F8                   .dbline 160
 00F8                   .dbline 161
 00F8           ;       if( I2CChkAck()!=I2C_MT_SLA_ACK )  
 00F8 80917100          lds R24,113
 00FC 887F              andi R24,248
 00FE 8831              cpi R24,24
 0100 11F0              breq L22
 0102           X7:
 0102                   .dbline 162
 0102           ;               return I2C_ERR;
 0102 0027              clr R16
 0104 01C0              rjmp L18
 0106           L22:
 0106                   .dbline 163
 0106           ;       return I2C_CRR;         
 0106 01E0              ldi R16,1
 0108                   .dbline -2
 0108           L18:
 0108                   .dbline 0 ; func end
 0108 0895              ret
 010A                   .dbsym r wrDAdr 16 c
 010A                   .dbend
 010A                   .dbfunc e I2C_SendWrDAdr_ _I2C_SendWrDAdr_ fc
 010A           ;         wrDAdr -> R10,R11
                        .even
 010A           _I2C_SendWrDAdr_::
 010A AA92              st -y,R10
 010C BA92              st -y,R11
 010E 5801              movw R10,R16
 0110                   .dbline -1
 0110                   .dbline 174
 0110           ; }
 0110           ; /*--------------------------------------------------------------------
 0110           ; 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
 0110           ; 函数功能：
 0110           ; 注意事项：
 0110           ; 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
 0110           ; 输    入：
 0110           ; 返    回：
 0110           ; --------------------------------------------------------------------*/
 0110           ; bool I2C_SendWrDAdr_(uint16 wrDAdr)   
 0110           ; {
 0110                   .dbline 175
 0110           ;       if( wrDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 0110 A0FE              sbrs R10,0
 0112 0EC0              rjmp L25
 0114           X8:
 0114                   .dbline 176
 0114           ;               if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )       //设置 （高位）器件写地址
 0114 0A2D              mov R16,R10
 0116 0695              lsr R16
 0118 0695              lsr R16
 011A 0695              lsr R16
 011C 0695              lsr R16
 011E 0695              lsr R16
 0120 0695              lsr R16
 0122 0695              lsr R16
 0124 0695              lsr R16
 0126 DFDF              rcall _I2C_SendWrDAdr
 0128 0023              tst R16
 012A 11F4              brne L27
 012C           X9:
 012C                   .dbline 177
 012C           ;                       return I2C_ERR;
 012C 0027              clr R16
 012E 07C0              rjmp L24
 0130           L27:
 0130           L25:
 0130                   .dbline 178
 0130           ;       if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )  //设置 （低位）器件写地址
 0130 0A2D              mov R16,R10
 0132 D9DF              rcall _I2C_SendWrDAdr
 0134 0023              tst R16
 0136 11F4              brne L29
 0138           X10:
 0138                   .dbline 179
 0138           ;               return I2C_ERR;
 0138 0027              clr R16
 013A 01C0              rjmp L24
 013C           L29:
 013C                   .dbline 180
 013C           ;       return I2C_CRR;
 013C 01E0              ldi R16,1
 013E                   .dbline -2
 013E           L24:
 013E                   .dbline 0 ; func end
 013E B990              ld R11,y+
 0140 A990              ld R10,y+
 0142 0895              ret
 0144                   .dbsym r wrDAdr 10 i
 0144                   .dbend
 0144                   .dbfunc e I2C_SendRdDAdr _I2C_SendRdDAdr fc
 0144           ;         rdDAdr -> R16
                        .even
 0144           _I2C_SendRdDAdr::
 0144                   .dbline -1
 0144                   .dbline 191
 0144           ; }
 0144           ; /*--------------------------------------------------------------------
 0144           ; 函数名称：发送 7位 器件读地址: XXXX XXX1
 0144           ; 函数功能：
 0144           ; 注意事项：
 0144           ; 提示说明：
 0144           ; 输    入：
 0144           ; 返    回：
 0144           ; --------------------------------------------------------------------*/
 0144           ; bool I2C_SendRdDAdr(uint8 rdDAdr)     
 0144           ; {
 0144                   .dbline 192
 0144           ;       I2CSendByte(rdDAdr);                    //设置 器件读地址
 0144                   .dbline 192
 0144 00937300          sts 115,R16
 0148                   .dbline 192
 0148 84E8              ldi R24,132
 014A 80937400          sts 116,R24
 014E                   .dbline 192
 014E                   .dbline 192
 014E                   .dbline 193
 014E           ;       I2CWaitAck();
 014E           L32:
 014E                   .dbline 193
 014E           L33:
 014E                   .dbline 193
 014E 20907400          lds R2,116
 0152 27FE              sbrs R2,7
 0154 FCCF              rjmp L32
 0156           X11:
 0156                   .dbline 193
 0156                   .dbline 193
 0156                   .dbline 194
 0156           ;       if( I2CChkAck()!=I2C_MR_SLA_ACK )  
 0156 80917100          lds R24,113
 015A 887F              andi R24,248
 015C 8034              cpi R24,64
 015E 11F0              breq L35
 0160           X12:
 0160                   .dbline 195
 0160           ;               return I2C_ERR;
 0160 0027              clr R16
 0162 01C0              rjmp L31
 0164           L35:
 0164                   .dbline 196
 0164           ;       return I2C_CRR; 
 0164 01E0              ldi R16,1
 0166                   .dbline -2
 0166           L31:
 0166                   .dbline 0 ; func end
 0166 0895              ret
 0168                   .dbsym r rdDAdr 16 c
 0168                   .dbend
 0168                   .dbfunc e I2C_SendRdDAdr_ _I2C_SendRdDAdr_ fc
 0168           ;         rdDAdr -> R10
                        .even
 0168           _I2C_SendRdDAdr_::
 0168 AA92              st -y,R10
 016A A02E              mov R10,R16
 016C                   .dbline -1
 016C                   .dbline 207
 016C           ; }
 016C           ; /*--------------------------------------------------------------------
 016C           ; 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
 016C           ; 函数功能：
 016C           ; 注意事项：
 016C           ; 提示说明：
 016C           ; 输    入：
 016C           ; 返    回：
 016C           ; --------------------------------------------------------------------*/
 016C           ; bool I2C_SendRdDAdr_(uint8 rdDAdr)    
 016C           ; {
 016C                   .dbline 208
 016C           ;       if( rdDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 016C A0FE              sbrs R10,0
 016E 0EC0              rjmp L38
 0170           X13:
 0170                   .dbline 209
 0170           ;               if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )       //设置 （高位）器件读地址
 0170 0A2D              mov R16,R10
 0172 0695              lsr R16
 0174 0695              lsr R16
 0176 0695              lsr R16
 0178 0695              lsr R16
 017A 0695              lsr R16
 017C 0695              lsr R16
 017E 0695              lsr R16
 0180 0695              lsr R16
 0182 B1DF              rcall _I2C_SendWrDAdr
 0184 0023              tst R16
 0186 11F4              brne L40
 0188           X14:
 0188                   .dbline 210
 0188           ;                       return I2C_ERR;
 0188 0027              clr R16
 018A 07C0              rjmp L37
 018C           L40:
 018C           L38:
 018C                   .dbline 211
 018C           ;       if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )  //设置 （低位）器件读地址
 018C 0A2D              mov R16,R10
 018E ABDF              rcall _I2C_SendWrDAdr
 0190 0023              tst R16
 0192 11F4              brne L42
 0194           X15:
 0194                   .dbline 212
 0194           ;               return I2C_ERR;
 0194 0027              clr R16
 0196 01C0              rjmp L37
 0198           L42:
 0198                   .dbline 213
 0198           ;       return I2C_CRR;
 0198 01E0              ldi R16,1
 019A                   .dbline -2
 019A           L37:
 019A                   .dbline 0 ; func end
 019A A990              ld R10,y+
 019C 0895              ret
 019E                   .dbsym r rdDAdr 10 c
 019E                   .dbend
 019E                   .dbfunc e I2C_SendDat _I2C_SendDat fc
 019E           ;      configDat -> R16
                        .even
 019E           _I2C_SendDat::
 019E                   .dbline -1
 019E                   .dbline 224
 019E           ; }
 019E           ; /*--------------------------------------------------------------------
 019E           ; 函数名称：I2C发送数据
 019E           ; 函数功能：
 019E           ; 注意事项：
 019E           ; 提示说明：
 019E           ; 输    入：
 019E           ; 返    回：
 019E           ; --------------------------------------------------------------------*/
 019E           ; bool I2C_SendDat(uint8 configDat)     
 019E           ; {
 019E                   .dbline 225
 019E           ;       I2CSendByte(configDat);                 
 019E                   .dbline 225
 019E 00937300          sts 115,R16
 01A2                   .dbline 225
 01A2 84E8              ldi R24,132
 01A4 80937400          sts 116,R24
 01A8                   .dbline 225
 01A8                   .dbline 225
 01A8                   .dbline 226
 01A8           ;       I2CWaitAck();
 01A8           L45:
 01A8                   .dbline 226
 01A8           L46:
 01A8                   .dbline 226
 01A8 20907400          lds R2,116
 01AC 27FE              sbrs R2,7
 01AE FCCF              rjmp L45
 01B0           X16:
 01B0                   .dbline 226
 01B0                   .dbline 226
 01B0                   .dbline 227
 01B0           ;       if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
 01B0 80917100          lds R24,113
 01B4 887F              andi R24,248
 01B6 8832              cpi R24,40
 01B8 11F0              breq L48
 01BA           X17:
 01BA                   .dbline 228
 01BA           ;               return I2C_ERR;
 01BA 0027              clr R16
 01BC 01C0              rjmp L44
 01BE           L48:
 01BE                   .dbline 229
 01BE           ;       return I2C_CRR; 
 01BE 01E0              ldi R16,1
 01C0                   .dbline -2
 01C0           L44:
 01C0                   .dbline 0 ; func end
 01C0 0895              ret
 01C2                   .dbsym r configDat 16 c
 01C2                   .dbend
 01C2                   .dbfunc e I2C_RcvNAckDat _I2C_RcvNAckDat fc
 01C2           ;         pRdDat -> R16,R17
                        .even
 01C2           _I2C_RcvNAckDat::
 01C2                   .dbline -1
 01C2                   .dbline 240
 01C2           ; }
 01C2           ; /*--------------------------------------------------------------------
 01C2           ; 函数名称：I2C接收数据且不产生应答
 01C2           ; 函数功能：
 01C2           ; 注意事项：
 01C2           ; 提示说明：
 01C2           ; 输    入：
 01C2           ; 返    回：
 01C2           ; --------------------------------------------------------------------*/
 01C2           ; bool I2C_RcvNAckDat(uint8 *pRdDat)    
 01C2           ; {
 01C2                   .dbline 241
 01C2           ;       I2CRcvNckByte();
 01C2 84E8              ldi R24,132
 01C4 80937400          sts 116,R24
 01C8                   .dbline 242
 01C8           ;       I2CWaitAck();
 01C8           L51:
 01C8                   .dbline 242
 01C8           L52:
 01C8                   .dbline 242
 01C8 20907400          lds R2,116
 01CC 27FE              sbrs R2,7
 01CE FCCF              rjmp L51
 01D0           X18:
 01D0                   .dbline 242
 01D0                   .dbline 242
 01D0                   .dbline 243
 01D0           ;       if( I2CChkAck()!=I2C_MR_DATA_NACK )
 01D0 80917100          lds R24,113
 01D4 887F              andi R24,248
 01D6 8835              cpi R24,88
 01D8 11F0              breq L54
 01DA           X19:
 01DA                   .dbline 244
 01DA           ;               return I2C_ERR;
 01DA 0027              clr R16
 01DC 05C0              rjmp L50
 01DE           L54:
 01DE                   .dbline 245
 01DE           ;       *pRdDat=TWDR;
 01DE 20907300          lds R2,115
 01E2 F801              movw R30,R16
 01E4 2082              std z+0,R2
 01E6                   .dbline 246
 01E6           ;       return I2C_CRR;
 01E6 01E0              ldi R16,1
 01E8                   .dbline -2
 01E8           L50:
 01E8                   .dbline 0 ; func end
 01E8 0895              ret
 01EA                   .dbsym r pRdDat 16 pc
 01EA                   .dbend
 01EA                   .dbfunc e I2C_RcvAckDat _I2C_RcvAckDat fc
 01EA           ;         pRdDat -> R16,R17
                        .even
 01EA           _I2C_RcvAckDat::
 01EA                   .dbline -1
 01EA                   .dbline 257
 01EA           ; }
 01EA           ; /*--------------------------------------------------------------------
 01EA           ; 函数名称：I2C接收数据且产生应答
 01EA           ; 函数功能：
 01EA           ; 注意事项：
 01EA           ; 提示说明：
 01EA           ; 输    入：
 01EA           ; 返    回：
 01EA           ; --------------------------------------------------------------------*/
 01EA           ; bool I2C_RcvAckDat(uint8 *pRdDat)     
 01EA           ; {
 01EA                   .dbline 258
 01EA           ;       I2CRcvAckByte();                                        
 01EA 84EC              ldi R24,196
 01EC 80937400          sts 116,R24
 01F0                   .dbline 259
 01F0           ;       I2CWaitAck();
 01F0           L57:
 01F0                   .dbline 259
 01F0           L58:
 01F0                   .dbline 259
 01F0 20907400          lds R2,116
 01F4 27FE              sbrs R2,7
 01F6 FCCF              rjmp L57
 01F8           X20:
 01F8                   .dbline 259
 01F8                   .dbline 259
 01F8                   .dbline 260
 01F8           ;       if( I2CChkAck()!=I2C_MR_DATA_ACK )
 01F8 80917100          lds R24,113
 01FC 887F              andi R24,248
 01FE 8035              cpi R24,80
 0200 11F0              breq L60
 0202           X21:
 0202                   .dbline 261
 0202           ;               return I2C_ERR;
 0202 0027              clr R16
 0204 05C0              rjmp L56
 0206           L60:
 0206                   .dbline 262
 0206           ;       *pRdDat=TWDR;
 0206 20907300          lds R2,115
 020A F801              movw R30,R16
 020C 2082              std z+0,R2
 020E                   .dbline 263
 020E           ;       return I2C_CRR;
 020E 01E0              ldi R16,1
 0210                   .dbline -2
 0210           L56:
 0210                   .dbline 0 ; func end
 0210 0895              ret
 0212                   .dbsym r pRdDat 16 pc
 0212                   .dbend
 0212                   .dbfunc e I2C_Write _I2C_Write fc
 0212           ;            dat -> R10
 0212           ;        wordAdr -> R12
 0212           ;         wrDAdr -> R14,R15
                        .even
 0212           _I2C_Write::
 0212 00D0              rcall push_xgset00FC
 0214 C22E              mov R12,R18
 0216 7801              movw R14,R16
 0218 AE80              ldd R10,y+6
 021A                   .dbline -1
 021A                   .dbline 276
 021A           ; }
 021A           ; /*--------------------------------------------------------------------
 021A           ; 函数名称：I2C写器件，写一个数据
 021A           ; 函数功能：
 021A           ; 注意事项：
 021A           ; 提示说明：
 021A           ; 输    入：wrDAdr: write device-address 写器件地址
 021A           ;                wordAdr: word address 字地址
 021A           ;                dat: data 数据
 021A           ; 返    回：
 021A           ; --------------------------------------------------------------------*/
 021A           ; bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
 021A           ; {
 021A                   .dbline 277
 021A           ;       if( I2C_Start()==I2C_ERR )
 021A 45DF              rcall _I2C_Start
 021C 0023              tst R16
 021E 11F4              brne L63
 0220           X22:
 0220                   .dbline 278
 0220           ;               return I2C_ERR;
 0220 0027              clr R16
 0222 18C0              rjmp L62
 0224           L63:
 0224                   .dbline 280
 0224           ; 
 0224           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 0224 8701              movw R16,R14
 0226 71DF              rcall _I2C_SendWrDAdr_
 0228 0023              tst R16
 022A 11F4              brne L65
 022C           X23:
 022C                   .dbline 281
 022C           ;               return I2C_ERR;
 022C 0027              clr R16
 022E 12C0              rjmp L62
 0230           L65:
 0230                   .dbline 283
 0230           ; 
 0230           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 0230 0C2D              mov R16,R12
 0232 B5DF              rcall _I2C_SendDat
 0234 C02E              mov R12,R16
 0236 0023              tst R16
 0238 11F4              brne L67
 023A           X24:
 023A                   .dbline 284
 023A           ;               return I2C_ERR;
 023A 0027              clr R16
 023C 0BC0              rjmp L62
 023E           L67:
 023E                   .dbline 286
 023E           ; 
 023E           ;       if( I2C_SendDat(dat)==I2C_ERR )
 023E 0A2D              mov R16,R10
 0240 AEDF              rcall _I2C_SendDat
 0242 A02E              mov R10,R16
 0244 0023              tst R16
 0246 11F4              brne L69
 0248           X25:
 0248                   .dbline 287
 0248           ;               return I2C_ERR;
 0248 0027              clr R16
 024A 04C0              rjmp L62
 024C           L69:
 024C                   .dbline 289
 024C           ; 
 024C           ;       I2C_Stop();
 024C 84E9              ldi R24,148
 024E 80937400          sts 116,R24
 0252                   .dbline 291
 0252           ; 
 0252           ;       return I2C_CRR;
 0252 01E0              ldi R16,1
 0254                   .dbline -2
 0254           L62:
 0254                   .dbline 0 ; func end
 0254 00C0              rjmp pop_xgset00FC
 0256                   .dbsym r dat 10 c
 0256                   .dbsym r wordAdr 12 c
 0256                   .dbsym r wrDAdr 14 i
 0256                   .dbend
 0256                   .dbfunc e I2C_Read _I2C_Read fc
 0256           ;         pRdDat -> R10,R11
 0256           ;         rdDAdr -> R12
 0256           ;        wordAdr -> R14
 0256           ;         wrDAdr -> R20,R21
                        .even
 0256           _I2C_Read::
 0256 00D0              rcall push_xgset30FC
 0258 E22E              mov R14,R18
 025A A801              movw R20,R16
 025C C884              ldd R12,y+8
 025E AA84              ldd R10,y+10
 0260 BB84              ldd R11,y+11
 0262                   .dbline -1
 0262                   .dbline 322
 0262           ; }
 0262           ; /*--------------------------------------------------------------------
 0262           ; 函数名称：I2C写器件，写N个数据
 0262           ; 函数功能：
 0262           ; 注意事项：
 0262           ; 提示说明：
 0262           ; 输    入：wrDAdr: write device-address 写器件地址
 0262           ;                wordAdr: word address 字地址
 0262           ;                *pWrDat: p->write data 写入数据指针
 0262           ;                num: number 写入数据个数
 0262           ; 返    回：
 0262           ; --------------------------------------------------------------------*/
 0262           ; //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
 0262           ; //                              uint8 *pWrDat,uint8 num)
 0262           ; //{
 0262           ; //
 0262           ; //} 
 0262           ; /*--------------------------------------------------------------------
 0262           ; 函数名称：I2C读器件，读一个数据
 0262           ; 函数功能：
 0262           ; 注意事项：
 0262           ; 提示说明：
 0262           ; 输    入：wrDAdr: write device-address 写器件地址
 0262           ;                wordAdr: word address 字地址
 0262           ;                rdDAdr: read device-address 读器件地址
 0262           ;                *pRdDat: p->read data 读取数据指针
 0262           ; 返    回：
 0262           ; --------------------------------------------------------------------*/
 0262           ; bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
 0262           ;                         uint8 rdDAdr,uint8 *pRdDat)
 0262           ; {
 0262                   .dbline 323
 0262           ;       if( I2C_Start()==I2C_ERR )
 0262 21DF              rcall _I2C_Start
 0264 0023              tst R16
 0266 11F4              brne L72
 0268           X26:
 0268                   .dbline 324
 0268           ;               return I2C_ERR;
 0268 0027              clr R16
 026A 25C0              rjmp L71
 026C           L72:
 026C                   .dbline 326
 026C           ; 
 026C           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 026C 8A01              movw R16,R20
 026E 4DDF              rcall _I2C_SendWrDAdr_
 0270 0023              tst R16
 0272 11F4              brne L74
 0274           X27:
 0274                   .dbline 327
 0274           ;               return I2C_ERR;
 0274 0027              clr R16
 0276 1FC0              rjmp L71
 0278           L74:
 0278                   .dbline 329
 0278           ; 
 0278           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 0278 0E2D              mov R16,R14
 027A 91DF              rcall _I2C_SendDat
 027C E02E              mov R14,R16
 027E 0023              tst R16
 0280 11F4              brne L76
 0282           X28:
 0282                   .dbline 330
 0282           ;               return I2C_ERR;
 0282 0027              clr R16
 0284 18C0              rjmp L71
 0286           L76:
 0286                   .dbline 332
 0286           ; 
 0286           ;       if( I2C_Restart()==I2C_ERR )
 0286 1FDF              rcall _I2C_Restart
 0288 E02E              mov R14,R16
 028A 0023              tst R16
 028C 11F4              brne L78
 028E           X29:
 028E                   .dbline 333
 028E           ;               return I2C_ERR;
 028E 0027              clr R16
 0290 12C0              rjmp L71
 0292           L78:
 0292                   .dbline 335
 0292           ; 
 0292           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 0292 0C2D              mov R16,R12
 0294 57DF              rcall _I2C_SendRdDAdr
 0296 C02E              mov R12,R16
 0298 0023              tst R16
 029A 11F4              brne L80
 029C           X30:
 029C                   .dbline 336
 029C           ;               return I2C_ERR;
 029C 0027              clr R16
 029E 0BC0              rjmp L71
 02A0           L80:
 02A0                   .dbline 338
 02A0           ; 
 02A0           ;       if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
 02A0 8501              movw R16,R10
 02A2 8FDF              rcall _I2C_RcvNAckDat
 02A4 A02E              mov R10,R16
 02A6 0023              tst R16
 02A8 11F4              brne L82
 02AA           X31:
 02AA                   .dbline 339
 02AA           ;               return I2C_ERR;
 02AA 0027              clr R16
 02AC 04C0              rjmp L71
 02AE           L82:
 02AE                   .dbline 341
 02AE           ; 
 02AE           ;       I2C_Stop();
 02AE 84E9              ldi R24,148
 02B0 80937400          sts 116,R24
 02B4                   .dbline 343
 02B4           ; 
 02B4           ;       return I2C_CRR;
 02B4 01E0              ldi R16,1
 02B6                   .dbline -2
 02B6           L71:
 02B6                   .dbline 0 ; func end
 02B6 00C0              rjmp pop_xgset30FC
 02B8                   .dbsym r pRdDat 10 pc
 02B8                   .dbsym r rdDAdr 12 c
 02B8                   .dbsym r wordAdr 14 c
 02B8                   .dbsym r wrDAdr 20 i
 02B8                   .dbend
 02B8                   .dbfunc e I2C_Read_ _I2C_Read_ fc
 02B8           ;              i -> R12
 02B8           ;            num -> R20
 02B8           ;         pRdDat -> R10,R11
 02B8           ;         rdDAdr -> R12
 02B8           ;        wordAdr -> R14
 02B8           ;         wrDAdr -> R22,R23
                        .even
 02B8           _I2C_Read_::
 02B8 00D0              rcall push_xgsetF0FC
 02BA E22E              mov R14,R18
 02BC B801              movw R22,R16
 02BE CA84              ldd R12,y+10
 02C0 AC84              ldd R10,y+12
 02C2 BD84              ldd R11,y+13
 02C4 4E85              ldd R20,y+14
 02C6                   .dbline -1
 02C6                   .dbline 359
 02C6           ; }
 02C6           ; /*--------------------------------------------------------------------
 02C6           ; 函数名称：I2C读器件，读N个数据
 02C6           ; 函数功能：
 02C6           ; 注意事项：
 02C6           ; 提示说明：
 02C6           ; 输    入：wrDAdr: write device-address 写器件地址
 02C6           ;                wordAdr: word address 字地址
 02C6           ;                rdDAdr: read device-address 读器件地址
 02C6           ;                *pRdDat: p->read data 读取数据指针
 02C6           ;                num: number 读取数据个数
 02C6           ; 返    回：
 02C6           ; --------------------------------------------------------------------*/
 02C6           ; bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
 02C6           ;                          uint8 rdDAdr,uint8 *pRdDat,uint8 num)
 02C6           ; {
 02C6                   .dbline 362
 02C6           ;       uint8 i;
 02C6           ;       
 02C6           ;       if( I2C_Start()==I2C_ERR )
 02C6 EFDE              rcall _I2C_Start
 02C8 0023              tst R16
 02CA 11F4              brne L85
 02CC           X32:
 02CC                   .dbline 363
 02CC           ;               return I2C_ERR;
 02CC 0027              clr R16
 02CE 39C0              rjmp L84
 02D0           L85:
 02D0                   .dbline 365
 02D0           ; 
 02D0           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 02D0 8B01              movw R16,R22
 02D2 1BDF              rcall _I2C_SendWrDAdr_
 02D4 0023              tst R16
 02D6 11F4              brne L87
 02D8           X33:
 02D8                   .dbline 366
 02D8           ;               return I2C_ERR;
 02D8 0027              clr R16
 02DA 33C0              rjmp L84
 02DC           L87:
 02DC                   .dbline 368
 02DC           ; 
 02DC           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 02DC 0E2D              mov R16,R14
 02DE 5FDF              rcall _I2C_SendDat
 02E0 E02E              mov R14,R16
 02E2 0023              tst R16
 02E4 11F4              brne L89
 02E6           X34:
 02E6                   .dbline 369
 02E6           ;               return I2C_ERR;
 02E6 0027              clr R16
 02E8 2CC0              rjmp L84
 02EA           L89:
 02EA                   .dbline 371
 02EA           ; 
 02EA           ;       if( I2C_Restart()==I2C_ERR )
 02EA EDDE              rcall _I2C_Restart
 02EC E02E              mov R14,R16
 02EE 0023              tst R16
 02F0 11F4              brne L91
 02F2           X35:
 02F2                   .dbline 372
 02F2           ;               return I2C_ERR;
 02F2 0027              clr R16
 02F4 26C0              rjmp L84
 02F6           L91:
 02F6                   .dbline 374
 02F6           ; 
 02F6           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 02F6 0C2D              mov R16,R12
 02F8 25DF              rcall _I2C_SendRdDAdr
 02FA C02E              mov R12,R16
 02FC 0023              tst R16
 02FE 11F4              brne L93
 0300           X36:
 0300                   .dbline 375
 0300           ;               return I2C_ERR;
 0300 0027              clr R16
 0302 1FC0              rjmp L84
 0304           L93:
 0304                   .dbline 377
 0304           ; 
 0304           ;       for(i=0;i<num-1;i++)
 0304 CC24              clr R12
 0306 0BC0              rjmp L98
 0308           L95:
 0308                   .dbline 378
 0308           ;               if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
 0308 0C2D              mov R16,R12
 030A 1127              clr R17
 030C 0A0D              add R16,R10
 030E 1B1D              adc R17,R11
 0310 6CDF              rcall _I2C_RcvAckDat
 0312 E02E              mov R14,R16
 0314 0023              tst R16
 0316 11F4              brne L99
 0318           X37:
 0318                   .dbline 379
 0318           ;                       return I2C_ERR;
 0318 0027              clr R16
 031A 13C0              rjmp L84
 031C           L99:
 031C           L96:
 031C                   .dbline 377
 031C C394              inc R12
 031E           L98:
 031E                   .dbline 377
 031E 842F              mov R24,R20
 0320 8150              subi R24,1
 0322 C816              cp R12,R24
 0324 88F3              brlo L95
 0326           X38:
 0326                   .dbline 381
 0326           ;       
 0326           ;       if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
 0326 0C2D              mov R16,R12
 0328 1127              clr R17
 032A 0A0D              add R16,R10
 032C 1B1D              adc R17,R11
 032E 49DF              rcall _I2C_RcvNAckDat
 0330 A02E              mov R10,R16
 0332 0023              tst R16
 0334 11F4              brne L101
 0336           X39:
 0336                   .dbline 382
 0336           ;                       return I2C_ERR;
 0336 0027              clr R16
 0338 04C0              rjmp L84
 033A           L101:
 033A                   .dbline 384
 033A           ; 
 033A           ;       I2C_Stop();
 033A 84E9              ldi R24,148
 033C 80937400          sts 116,R24
 0340                   .dbline 386
 0340           ;       
 0340           ;       return I2C_CRR;
 0340 01E0              ldi R16,1
 0342                   .dbline -2
 0342           L84:
 0342                   .dbline 0 ; func end
 0342 00C0              rjmp pop_xgsetF0FC
 0344                   .dbsym r i 12 c
 0344                   .dbsym r num 20 c
 0344                   .dbsym r pRdDat 10 pc
 0344                   .dbsym r rdDAdr 12 c
 0344                   .dbsym r wordAdr 14 c
 0344                   .dbsym r wrDAdr 22 i
 0344                   .dbend
 0344                   .dbfile D:\ICC_H\Hardware.H
 0344                   .dbfunc e delay50us _delay50us fV
 0344           ;              j -> R20
 0344           ;              t -> R16,R17
                        .even
 0344           _delay50us::
 0344 4A93              st -y,R20
 0346                   .dbline -1
 0346                   .dbline 105
 0346           ; /*********************************************************************
 0346           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0346           ;                                                                       
 0346           ; 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
 0346           ;                                       
 0346           ; 目标系统:   基于AVR单片机
 0346           ;                                                                               
 0346           ; 应用软件:   ICCAVR
 0346           ;                                                                               
 0346           ; 版    本:   Version 1.0                                                          
 0346           ;                                                                               
 0346           ; 圆版时间:   2005-06-25
 0346           ;       
 0346           ; 开发人员:   SEE
 0346           ; 
 0346           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0346           ;       
 0346           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0346           ; *********************************************************************/
 0346           ; 
 0346           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0346           ; ----------------------------------------------------------------------
 0346           ; 版本更新记录：
 0346           ; 
 0346           ; ----------------------------------------------------------------------
 0346           ; 入口参数说明：
 0346           ; 
 0346           ; ----------------------------------------------------------------------
 0346           ; 待定参数说明：
 0346           ; 
 0346           ; ----------------------------------------------------------------------        
 0346           ; 对外变量说明：
 0346           ;     
 0346           ; ----------------------------------------------------------------------
 0346           ; 对外函数说明：
 0346           ;    
 0346           ; ----------------------------------------------------------------------
 0346           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 0346           ; 
 0346           ; #ifndef Hardware_H
 0346           ; #define Hardware_H
 0346           ; 
 0346           ; #include <math.h>
 0346           ; #include <string.h>
 0346           ; #include <stdio.h>
 0346           ; #include <macros.h>
 0346           ; #include <eeprom.h>
 0346           ; //#include <wdt.h>
 0346           ; 
 0346           ; /* TWI configs */
 0346           ; //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
 0346           ; #if NO_INCLUDE_I2C_H
 0346           ; ;
 0346           ; #else
 0346           ; #include "D:\ICC_H\I2C.H"     //i2c即AVR的"twi"
 0346           ; #endif
 0346           ; 
 0346           ; /* hard configs */
 0346           ; #ifndef flash
 0346           ;       #define flash   const
 0346           ; #endif
 0346           ; 
 0346           ; #ifndef code
 0346           ;       #define code    const
 0346           ; #endif
 0346           ; 
 0346           ; #ifndef NOP
 0346           ;       #define NOP()   asm("nop")
 0346           ; #endif
 0346           ; 
 0346           ; /* io configs */
 0346           ; #define sbi(io,bit)           (  io |=  (1<<bit) )    //example: sbi(PORTA,0);sbi(DDRA,0);
 0346           ; #define cbi(io,bit)           (  io &= ~(1<<bit) )    //example: cbi(PORTA,0);cbi(DDRA,0);
 0346           ; #define gbi(pin ,bit) ( pin &   (1<<bit) )    //example: gbi(PINA,0);
 0346           ; 
 0346           ; /* interrupt configs */
 0346           ; #define DIS_INT  asm("sei")
 0346           ; #define EN_INT   asm("cli")
 0346           ; 
 0346           ; /* wdt configs */
 0346           ; #define WDT()    asm("wdr")
 0346           ; 
 0346           ; /* bit operation */
 0346           ; //#ifndef BIT
 0346           ; //#define BIT(x)      ( 1<<(x) )
 0346           ; //#endif
 0346           ; 
 0346           ; /* USART configs for 4 Mhz crystal */
 0346           ; //#define BAUD9600                    25
 0346           ; //#define BAUD19000                   12
 0346           ; //#define UART_TRAN_ON()      UCR |=  0x08
 0346           ; //#define UART_TRAN_OFF()     UCR &= ~0x08
 0346           ; //#define UART_RCV_ON()               UCR |=  0x10
 0346           ; //#define UART_RCV_OFF()      UCR &= ~0x10
 0346           ; 
 0346           ; /*--------------------------------------------------------------------
 0346           ; 函数全称：50us 延时
 0346           ; 函数功能：当然是 50us延时 啦
 0346           ; 注意事项：基于7.3728M晶振，稍微有点误差
 0346           ; 提示说明：调用delay50us（20），得到1ms延时
 0346           ; 输    入：    
 0346           ; 返    回：无 
 0346           ; --------------------------------------------------------------------*/
 0346           ; void delay50us(sint16 t)
 0346           ; {
 0346                   .dbline 107
 0346           ;     uint8 j;          
 0346           ;     for(;t>0;t--)                     
 0346 07C0              rjmp L107
 0348           L104:
 0348                   .dbline 108
 0348           ;         for(j=0;j<70;j++)     
 0348 4427              clr R20
 034A 01C0              rjmp L111
 034C           L108:
 034C                   .dbline 109
 034C           ;             ;
 034C           L109:
 034C                   .dbline 108
 034C 4395              inc R20
 034E           L111:
 034E                   .dbline 108
 034E 4634              cpi R20,70
 0350 E8F3              brlo L108
 0352           X40:
 0352           L105:
 0352                   .dbline 107
 0352 0150              subi R16,1
 0354 1040              sbci R17,0
 0356           L107:
 0356                   .dbline 107
 0356 2224              clr R2
 0358 3324              clr R3
 035A 2016              cp R2,R16
 035C 3106              cpc R3,R17
 035E A4F3              brlt L104
 0360           X41:
 0360                   .dbline -2
 0360           L103:
 0360                   .dbline 0 ; func end
 0360 4991              ld R20,y+
 0362 0895              ret
 0364                   .dbsym r j 20 c
 0364                   .dbsym r t 16 I
 0364                   .dbend
 0364                   .dbfunc e delay50ms _delay50ms fV
 0364           ;              i -> R20,R21
 0364           ;              t -> R16,R17
                        .even
 0364           _delay50ms::
 0364 4A93              st -y,R20
 0366 5A93              st -y,R21
 0368                   .dbline -1
 0368                   .dbline 120
 0368           ; }
 0368           ; /*--------------------------------------------------------------------
 0368           ; 函数全称：50ms 延时
 0368           ; 函数功能：当然是 50ms延时 啦
 0368           ; 注意事项：基于7.3728M晶振，稍微有点误差
 0368           ; 提示说明：调用delay50ms（20），得到1s延时 
 0368           ; 输    入：
 0368           ; 返    回：无
 0368           ; --------------------------------------------------------------------*/
 0368           ; void delay50ms(sint16 t)
 0368           ; {
 0368                   .dbline 122
 0368           ;       uint16 i; 
 0368           ;       for(;t>0;t--)
 0368 13C0              rjmp L116
 036A           L113:
 036A                   .dbline 123
 036A           ;               for(i=0;i<52642;i++)
 036A 4427              clr R20
 036C 5527              clr R21
 036E 02C0              rjmp L120
 0370           L117:
 0370                   .dbline 124
 0370           ;                       ; 
 0370           L118:
 0370                   .dbline 123
 0370 4F5F              subi R20,255  ; offset = 1
 0372 5F4F              sbci R21,255
 0374           L120:
 0374                   .dbline 123
 0374 82EA              ldi R24,162
 0376 9DEC              ldi R25,205
 0378 A0E0              ldi R26,0
 037A B0E0              ldi R27,0
 037C 1A01              movw R2,R20
 037E 4424              clr R4
 0380 5524              clr R5
 0382 2816              cp R2,R24
 0384 3906              cpc R3,R25
 0386 4A06              cpc R4,R26
 0388 5B06              cpc R5,R27
 038A 94F3              brlt L117
 038C           X42:
 038C           L114:
 038C                   .dbline 122
 038C 0150              subi R16,1
 038E 1040              sbci R17,0
 0390           L116:
 0390                   .dbline 122
 0390 2224              clr R2
 0392 3324              clr R3
 0394 2016              cp R2,R16
 0396 3106              cpc R3,R17
 0398 44F3              brlt L113
 039A           X43:
 039A                   .dbline -2
 039A           L112:
 039A                   .dbline 0 ; func end
 039A 5991              ld R21,y+
 039C 4991              ld R20,y+
 039E 0895              ret
 03A0                   .dbsym r i 20 i
 03A0                   .dbsym r t 16 I
 03A0                   .dbend
 03A0                   .dbfunc e delayus _delayus fV
 03A0           ;              i -> R20,R21
 03A0           ;              t -> R16,R17
                        .even
 03A0           _delayus::
 03A0 4A93              st -y,R20
 03A2 5A93              st -y,R21
 03A4                   .dbline -1
 03A4                   .dbline 129
 03A4           ; }
 03A4           ; 
 03A4           ; 
 03A4           ; void delayus(uint16 t)
 03A4           ; {
 03A4                   .dbline 131
 03A4           ;       uint16 i;
 03A4           ;       for(i=0;i<t;i++)
 03A4 4427              clr R20
 03A6 5527              clr R21
 03A8 02C0              rjmp L125
 03AA           L122:
 03AA                   .dbline 132
 03AA           ;               {
 03AA                   .dbline 135
 03AA           ;                       //asm("NOP\n");
 03AA           ;                       //asm("NOP\n");
 03AA           ;               }
 03AA           L123:
 03AA                   .dbline 131
 03AA 4F5F              subi R20,255  ; offset = 1
 03AC 5F4F              sbci R21,255
 03AE           L125:
 03AE                   .dbline 131
 03AE 4017              cp R20,R16
 03B0 5107              cpc R21,R17
 03B2 D8F3              brlo L122
 03B4           X44:
 03B4                   .dbline -2
 03B4           L121:
 03B4                   .dbline 0 ; func end
 03B4 5991              ld R21,y+
 03B6 4991              ld R20,y+
 03B8 0895              ret
 03BA                   .dbsym r i 20 i
 03BA                   .dbsym r t 16 i
 03BA                   .dbend
 03BA                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\MAX485~1\MAX485\test.c
 03BA                   .dbfunc e UART_init _UART_init fV
                        .even
 03BA           _UART_init::
 03BA                   .dbline -1
 03BA                   .dbline 55
 03BA           ; /*********************************************************************
 03BA           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 03BA           ;                                                                       
 03BA           ; 目    的:   MAX485示例程序
 03BA           ;       
 03BA           ; 目标系统:   基于AVR单片机
 03BA           ;                                                                               
 03BA           ; 应用软件:   ICCAVR
 03BA           ;                                                                               
 03BA           ; 版    本:   Version 1.0                                                          
 03BA           ;                                                                               
 03BA           ; 圆版时间:   2009-03-31
 03BA           ;       
 03BA           ; 开发人员:   zz
 03BA           ; 
 03BA           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 03BA           ;       
 03BA           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 03BA           ; *********************************************************************/
 03BA           ; 
 03BA           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 03BA           ; ----------------------------------------------------------------------
 03BA           ; 版本更新记录：
 03BA           ; 
 03BA           ; ----------------------------------------------------------------------
 03BA           ; 实验内容：
 03BA           ; 先把写数据并显示在MX485自发自收试验
 03BA           ; ----------------------------------------------------------------------
 03BA           ; 硬件连接：
 03BA           ;                         DVK501                                 DVK501
 03BA           ;                               U1:A         ---------    U2:A
 03BA           ;                               U1:B            ---------         U2:B
 03BA           ;                               U1:EN           ---------         VCC
 03BA           ;                               U2:EN           ---------         GND
 03BA           ;       
 03BA           ;                         STK128+                       STK128+
 03BA           ;                          PA   ---------                LED0~7
 03BA           ; 
 03BA           ;                          DVK501                                 STK128+
 03BA           ;                               VCC             ---------         VCC
 03BA           ;                               GND             ---------         GND
 03BA           ;                               U1:DI   ---------         PE1(TXD0)
 03BA           ;                               U2:RO   ---------         PE0(RXD0)
 03BA           ;                               
 03BA           ; ----------------------------------------------------------------------
 03BA           ; 注意事项： 
 03BA           ; （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
 03BA           ; （2）请详细阅读“使用必读”及相关资料。
 03BA           ; ----------------------------------------------------------------------
 03BA           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 03BA           ; 
 03BA           ; #include <iom128v.h>
 03BA           ; #include "D:\ICC_H\CmmICC.H"
 03BA           ; void UART_init(void)
 03BA           ; {
 03BA                   .dbline 62
 03BA           ; // USART0 initialization
 03BA           ; // Communication Parameters: 8 Data, 1 Stop, No Parity
 03BA           ; // USART0 Receiver: On
 03BA           ; // USART0 Transmitter: On
 03BA           ; // USART0 Mode: Asynchronous
 03BA           ; // USART0 Baud Rate: 9600
 03BA           ; UCSR0A=0x00;
 03BA 2224              clr R2
 03BC 2BB8              out 0xb,R2
 03BE                   .dbline 63
 03BE           ; UCSR0B=0x18;
 03BE 88E1              ldi R24,24
 03C0 8AB9              out 0xa,R24
 03C2                   .dbline 64
 03C2           ; UCSR0C=0x06;
 03C2 86E0              ldi R24,6
 03C4 80939500          sts 149,R24
 03C8                   .dbline 65
 03C8           ; UBRR0H=0x00;
 03C8 20929000          sts 144,R2
 03CC                   .dbline 66
 03CC           ; UBRR0L=0x2F;
 03CC 8FE2              ldi R24,47
 03CE 89B9              out 0x9,R24
 03D0                   .dbline -2
 03D0           L126:
 03D0                   .dbline 0 ; func end
 03D0 0895              ret
 03D2                   .dbend
 03D2                   .dbfunc e uart_putchar0 _uart_putchar0 fV
 03D2           ;              c -> R16
                        .even
 03D2           _uart_putchar0::
 03D2                   .dbline -1
 03D2                   .dbline 72
 03D2           ; }
 03D2           ; 
 03D2           ; 
 03D2           ; //从RS232发送一个字节 
 03D2           ; void uart_putchar0(char c) 
 03D2           ; { 
 03D2           L128:
 03D2                   .dbline 73
 03D2           ;     while(!(UCSR0A & 0x20));
 03D2           L129:
 03D2                   .dbline 73
 03D2 5D9B              sbis 0xb,5
 03D4 FECF              rjmp L128
 03D6           X45:
 03D6                   .dbline 74
 03D6           ;     UDR0 = c; 
 03D6 0CB9              out 0xc,R16
 03D8                   .dbline -2
 03D8           L127:
 03D8                   .dbline 0 ; func end
 03D8 0895              ret
 03DA                   .dbsym r c 16 c
 03DA                   .dbend
 03DA                   .dbfunc e uart_getchar0 _uart_getchar0 fi
 03DA           ;            res -> R16
 03DA           ;         status -> R18
                        .even
 03DA           _uart_getchar0::
 03DA                   .dbline -1
 03DA                   .dbline 78
 03DA           ; } 
 03DA           ; //从RS232接收一个字节 
 03DA           ; unsigned int uart_getchar0(void) 
 03DA           ; { 
 03DA                   .dbline 80
 03DA           ;     unsigned char status,res; 
 03DA           ;     if(!(UCSR0A & 0x80)) return -1;        //no data to be received 
 03DA 5F99              sbic 0xb,7
 03DC 03C0              rjmp L132
 03DE           X46:
 03DE                   .dbline 80
 03DE 0FEF              ldi R16,65535
 03E0 1FEF              ldi R17,255
 03E2 09C0              rjmp L131
 03E4           L132:
 03E4                   .dbline 81
 03E4           ;     status = UCSR0A; 
 03E4 2BB1              in R18,0xb
 03E6                   .dbline 82
 03E6           ;     res = UDR0; 
 03E6 0CB1              in R16,0xc
 03E8                   .dbline 83
 03E8           ;     if (status & 0x1c) return -1;        // If error, return -1 
 03E8 822F              mov R24,R18
 03EA 8C71              andi R24,28
 03EC 19F0              breq L134
 03EE           X47:
 03EE                   .dbline 83
 03EE 0FEF              ldi R16,65535
 03F0 1FEF              ldi R17,255
 03F2 01C0              rjmp L131
 03F4           L134:
 03F4                   .dbline 84
 03F4           ;     return res; 
 03F4 1127              clr R17
 03F6                   .dbline -2
 03F6           L131:
 03F6                   .dbline 0 ; func end
 03F6 0895              ret
 03F8                   .dbsym r res 16 c
 03F8                   .dbsym r status 18 c
 03F8                   .dbend
 03F8                   .dbfunc e uart_waitchar0 _uart_waitchar0 fc
 03F8           ;              c -> R10,R11
                        .even
 03F8           _uart_waitchar0::
 03F8 AA92              st -y,R10
 03FA BA92              st -y,R11
 03FC                   .dbline -1
 03FC                   .dbline 88
 03FC           ; } 
 03FC           ; //等待从RS232接收一个有效的字节 
 03FC           ; unsigned char uart_waitchar0(void) 
 03FC           ; { 
 03FC           L137:
 03FC                   .dbline 90
 03FC           ;     unsigned int c; 
 03FC           ;     while((c=uart_getchar0())==-1); 
 03FC           L138:
 03FC                   .dbline 90
 03FC EEDF              rcall _uart_getchar0
 03FE 5801              movw R10,R16
 0400 0F3F              cpi R16,255
 0402 EFEF              ldi R30,255
 0404 1E07              cpc R17,R30
 0406 D1F3              breq L137
 0408           X48:
 0408                   .dbline 91
 0408           ;     return (unsigned char)c; 
 0408                   .dbline -2
 0408           L136:
 0408                   .dbline 0 ; func end
 0408 B990              ld R11,y+
 040A A990              ld R10,y+
 040C 0895              ret
 040E                   .dbsym r c 10 i
 040E                   .dbend
 040E                   .dbfunc e main _main fV
                        .even
 040E           _main::
 040E                   .dbline -1
 040E                   .dbline 95
 040E           ; } 
 040E           ; 
 040E           ; void main(void)
 040E           ; {
 040E                   .dbline 96
 040E           ;       DDRA=0xFF;
 040E 8FEF              ldi R24,255
 0410 8ABB              out 0x1a,R24
 0412                   .dbline 97
 0412           ;       UART_init();
 0412 D3DF              rcall _UART_init
 0414                   .dbline 98
 0414           ;       uart_putchar0(0x55);
 0414 05E5              ldi R16,85
 0416 DDDF              rcall _uart_putchar0
 0418                   .dbline 100
 0418           ;       
 0418           ;       PORTA=uart_waitchar0();
 0418 EFDF              rcall _uart_waitchar0
 041A 0BBB              out 0x1b,R16
 041C           L141:
 041C                   .dbline 101
 041C           ;       while(1);
 041C           L142:
 041C                   .dbline 101
 041C FFCF              rjmp L141
 041E           X49:
 041E                   .dbline -2
 041E           L140:
 041E                   .dbline 0 ; func end
 041E 0895              ret
 0420                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile E:\吴泽备份\DVK501光盘内容\M128_E~1\MAX485~1\MAX485\test.c
 0000           _dataElem::
 0000                   .blkb 6
 0006                   .dbfile D:\ICC_H\Software.H
 0006                   .dbsym e dataElem _dataElem A[6:6]c
 0006           ; }
