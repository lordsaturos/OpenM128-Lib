Interrupt Vectors
    00000 940C 0039 JMP	__text_start|__start

Program Code (text area)
__text_start|__start:
    00039 E5CF      LDI	R28,0x5F
    0003A E0D4      LDI	R29,4
    0003B BFCD      OUT	0x3D,R28
    0003C BFDE      OUT	0x3E,R29
    0003D 51C0      SUBI	R28,0x10
    0003E 40D0      SBCI	R29,0
    0003F EA0A      LDI	R16,0xAA
    00040 8308      ST	Y,R16
    00041 2400      CLR	R0
    00042 E7ED      LDI	R30,0x7D
    00043 E0F0      LDI	R31,0
    00044 E010      LDI	R17,0
    00045 38E3      CPI	R30,0x83
    00046 07F1      CPC	R31,R17
    00047 F011      BEQ	0x004A
    00048 9201      ST	Z+,R0
    00049 CFFB      RJMP	0x0045
    0004A 8300      ST	Z,R16
    0004B E5E4      LDI	R30,0x54
    0004C E0F0      LDI	R31,0
    0004D E6A0      LDI	R26,0x60
    0004E E0B0      LDI	R27,0
    0004F E010      LDI	R17,0
    00050 E000      LDI	R16,0
    00051 BF0B      OUT	0x3B,R16
    00052 37E1      CPI	R30,0x71
    00053 07F1      CPC	R31,R17
    00054 F021      BEQ	0x0059
    00055 95C8      LPM
    00056 9631      ADIW	R30,1
    00057 920D      ST	X+,R0
    00058 CFF9      RJMP	0x0052
    00059 940E 03CB CALL	_main
_exit:
    0005B CFFF      RJMP	_exit
_speaData:
  y                    --> Y,+4
  j                    --> Y,+0
  i                    --> R10
  len                  --> R12
  dat                  --> Y,+16
    0005C 940E 03DF CALL	push_arg4
    0005E 940E 04C4 CALL	push_xgsetF03C
    00060 9728      SBIW	R28,0x8
    00061 88CC      LDD	R12,Y+20
FILE: D:\ICC_H\Software.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                       
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Software_H
(0041) #define Software_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) 
(0046) /* 兼容一般程序员的常用写法 */
(0047) typedef unsigned char	uchar;
(0048) typedef unsigned int	uint;
(0049) typedef unsigned long	ulong;
(0050) typedef signed char		schar;
(0051) typedef signed int		sint;
(0052) typedef signed long		slong;
(0053) 
(0054) /* 为方便移植，建议使用下面写法 */
(0055) typedef unsigned char	bool;
(0056) typedef unsigned char	uint8;
(0057) typedef unsigned int	uint16;
(0058) typedef unsigned long   uint32;
(0059) typedef signed  char	sint8;
(0060) typedef signed	int		sint16;
(0061) typedef signed	long	sint32;
(0062) typedef signed  char	int8;
(0063) typedef signed  int		int16;
(0064) typedef signed  long	int32;
(0065) 
(0066) /* 下面写法一般不推荐 */
(0067) //typedef unsigned char ubyte;
(0068) //typedef unsigned int	uword;
(0069) //typedef unsigned long udword;
(0070) //typedef signed   char	sbyte;
(0071) //typedef signed   int	sword;
(0072) //typedef signed   long	sdword;
(0073) 
(0074) /* 一般程序定义的默认值 */
(0075) //#define NULL			0
(0076) //#define EOF			-1
(0077) //#define TRUE   		1
(0078) //#define FALSE  		0
(0079) //#define YES   		1
(0080) //#define NO  			0
(0081) //#define ON			1
(0082) //#define OFF			0
(0083) //#define ENABLE   		1
(0084) //#define DISABLE		0
(0085) //#define CRR			1
(0086) //#define ERR			0
(0087) //#define RIGHT			1
(0088) //#define WRONG			0
(0089) //#define SUCCESS		1
(0090) //#define FAILURE		0
(0091) //#define PI			3.1415926	//3.1415926535897932
(0092) 
(0093) /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
(0094) //#define _CALLOC(a)		( (a *)calloc(n,sizeof(a)) )
(0095) //#define _MALLOC(a)		( (a *)malloc(sizeof(a)) )
(0096) //#define _MIN(a,b)			( (a) < (b) ? (a) : (b) )
(0097) //#define _MAX(a,b)			( (a) > (b) ? (a) : (b) )
(0098) //#define _EXCHANGE(a,b)	{ int t; t=a; a=b; b=t; }
(0099) //#define _TOLOWER(c)		( (c)+32 )
(0100) //#define _TOUPPER(c)		( (c)-32 )
(0101) 
(0102) //#ifndef BIT
(0103) //#define BIT(x)	( 1<<(x) )
(0104) //#endif
(0105) 
(0106) /*--------------------------------------------------------------------
(0107) 函数全称：数据拆字
(0108) 函数功能：
(0109) 注意事项：D<=999999,C<=6
(0110) 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
(0111) 输    入：
(0112) 返    回：无
(0113) --------------------------------------------------------------------*/
(0114) uint8 dataElem[6];
(0115) void speaData(uint32 dat,sint8 len)
(0116) {
(0117)     uint8 i;
(0118)     uint32 j,y;
(0119)     for(i=0,j=1;i<len;i++)
    00062 24AA      CLR	R10
    00063 E081      LDI	R24,1
    00064 8388      ST	Y,R24
    00065 E080      LDI	R24,0
    00066 8389      STD	Y+1,R24
    00067 838A      STD	Y+2,R24
    00068 838B      STD	Y+3,R24
    00069 C03C      RJMP	0x00A6
(0120)     {
(0121)         y=dat/j;
    0006A 8028      LD	R2,Y
    0006B 8039      LDD	R3,Y+1
    0006C 804A      LDD	R4,Y+2
    0006D 805B      LDD	R5,Y+3
    0006E 8908      LDD	R16,Y+16
    0006F 8919      LDD	R17,Y+17
    00070 892A      LDD	R18,Y+18
    00071 893B      LDD	R19,Y+19
    00072 925A      ST	-Y,R5
    00073 924A      ST	-Y,R4
    00074 923A      ST	-Y,R3
    00075 922A      ST	-Y,R2
    00076 940E 03E4 CALL	div32u
    00078 830C      STD	Y+4,R16
    00079 831D      STD	Y+5,R17
    0007A 832E      STD	Y+6,R18
    0007B 833F      STD	Y+7,R19
(0122)         dataElem[i]=y%10;
    0007C E04A      LDI	R20,0xA
    0007D E050      LDI	R21,0
    0007E E060      LDI	R22,0
    0007F E070      LDI	R23,0
    00080 810C      LDD	R16,Y+4
    00081 811D      LDD	R17,Y+5
    00082 812E      LDD	R18,Y+6
    00083 813F      LDD	R19,Y+7
    00084 937A      ST	-Y,R23
    00085 936A      ST	-Y,R22
    00086 935A      ST	-Y,R21
    00087 934A      ST	-Y,R20
    00088 940E 03E6 CALL	mod32u
    0008A E78D      LDI	R24,0x7D
    0008B E090      LDI	R25,0
    0008C 2DEA      MOV	R30,R10
    0008D 27FF      CLR	R31
    0008E 0FE8      ADD	R30,R24
    0008F 1FF9      ADC	R31,R25
    00090 8300      ST	Z,R16
(0123)         j*=10;
    00091 8028      LD	R2,Y
    00092 8039      LDD	R3,Y+1
    00093 804A      LDD	R4,Y+2
    00094 805B      LDD	R5,Y+3
    00095 E04A      LDI	R20,0xA
    00096 E050      LDI	R21,0
    00097 E060      LDI	R22,0
    00098 E070      LDI	R23,0
    00099 925A      ST	-Y,R5
    0009A 924A      ST	-Y,R4
    0009B 923A      ST	-Y,R3
    0009C 922A      ST	-Y,R2
    0009D 018A      MOVW	R16,R20
    0009E 019B      MOVW	R18,R22
    0009F 940E 044E CALL	empy32u|empy32s
    000A1 8308      ST	Y,R16
    000A2 8319      STD	Y+1,R17
    000A3 832A      STD	Y+2,R18
    000A4 833B      STD	Y+3,R19
    000A5 94A3      INC	R10
    000A6 2C2C      MOV	R2,R12
    000A7 2433      CLR	R3
    000A8 FC27      SBRC	R2,7
    000A9 9430      COM	R3
    000AA 2C4A      MOV	R4,R10
    000AB 2455      CLR	R5
    000AC 1442      CP	R4,R2
    000AD 0453      CPC	R5,R3
    000AE F40C      BGE	0x00B0
    000AF CFBA      RJMP	0x006A
    000B0 9628      ADIW	R28,0x8
    000B1 940E 04CD CALL	pop_xgsetF03C
    000B3 9624      ADIW	R28,4
    000B4 9508      RET
FILE: D:\ICC_H\I2C.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立I2C操作库
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033) 
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036) 
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef I2C_H
(0041) #define I2C_H
(0042) 
(0043) /* TWSR values (not bits) */
(0044) /* Master */
(0045) #define I2C_START			0x08
(0046) #define I2C_RESTART			0x10
(0047) 
(0048) /* Master Transmitter */
(0049) #define I2C_MT_SLA_ACK		0x18
(0050) #define I2C_MT_SLA_NACK		0x20
(0051) #define I2C_MT_DATA_ACK		0x28
(0052) #define I2C_MT_DATA_NACK	0x30
(0053) #define I2C_MT_ARB_LOST		0x38
(0054) 
(0055) /* Master Receiver */
(0056) #define I2C_MR_ARB_LOST		0x38
(0057) #define I2C_MR_SLA_ACK		0x40
(0058) #define I2C_MR_SLA_NACK		0x48
(0059) #define I2C_MR_DATA_ACK		0x50
(0060) #define I2C_MR_DATA_NACK	0x58
(0061) 
(0062) /* Slave Transmitter */
(0063) #define I2C_ST_SLA_ACK			0xA8
(0064) #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
(0065) #define I2C_ST_DATA_ACK			0xB8
(0066) #define I2C_ST_DATA_NACK		0xC0
(0067) #define I2C_ST_LAST_DATA		0xC8
(0068) 
(0069) /* Slave Receiver */
(0070) #define I2C_SR_SLA_ACK				0x60
(0071) #define I2C_SR_ARB_LOST_SLA_ACK		0x68
(0072) #define I2C_SR_GCALL_ACK			0x70
(0073) #define I2C_SR_ARB_LOST_GCALL_ACK	0x78
(0074) #define I2C_SR_DATA_ACK				0x80
(0075) #define I2C_SR_DATA_NACK			0x88
(0076) #define I2C_SR_GCALL_DATA_ACK		0x90
(0077) #define I2C_SR_GCALL_DATA_NACK		0x98
(0078) #define I2C_SR_STOP					0xA0
(0079) 
(0080) /* Misc */
(0081) #define I2C_NO_INFO			0xF8
(0082) #define I2C_BUS_ERROR		0x00
(0083) 
(0084) /*
(0085)  * The lower 3 bits of TWSR are reserved on the ATmega163.
(0086)  * The 2 LSB carry the prescaler bits on the newer ATmegas.
(0087)  */
(0088) #define I2C_STATUS_MASK	(_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
(0089) #define I2C_STATUS		(TWSR & I2C_STATUS_MASK)
(0090) 
(0091) /*
(0092)  * R/~W bit in SLA+R/W address field.
(0093)  */
(0094) #define I2C_READ		1
(0095) #define I2C_WRITE		0
(0096) 
(0097) #define I2CStart()    	(TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
(0098) #define I2CStop()     	(TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
(0099) #define I2CWaitAck()	{while(!(TWCR&(1<<TWINT)));}
(0100) #define I2CChkAck() 	(TWSR&0xf8)					//check ack
(0101) #define I2CSendAck()	(TWCR|=(1<<TWEA))
(0102) #define I2CSendNoAck()	(TWCR&=~(1<<TWEA))
(0103) #define I2CSendByte(x)	{TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
(0104) #define I2CRcvNckByte()	(TWCR=(1<<TWINT)|(1<<TWEN))
(0105) #define I2CRcvAckByte()	(TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
(0106) 
(0107) /* For Program */
(0108) #define I2C_Stop()		I2CStop()
(0109) #define I2C_SendAck()	I2CSendAck()
(0110) #define I2C_SendNoAck() I2CSendNoAck()
(0111) #define I2C_WaitAck()	I2CWaitAck()
(0112) 
(0113) /* I2C Config */
(0114) #define I2C_ERR			0
(0115) #define I2C_CRR			1
(0116) 
(0117) /*--------------------------------------------------------------------
(0118) 函数名称：I2C Start
(0119) 函数功能：
(0120) 注意事项：
(0121) 提示说明：
(0122) 输    入：
(0123) 返    回：
(0124) --------------------------------------------------------------------*/
(0125) bool I2C_Start()					
(0126) {
(0127) 	I2CStart();						
_I2C_Start:
    000B5 EA84      LDI	R24,0xA4
    000B6 BF86      OUT	0x36,R24
(0128) 	I2CWaitAck();
    000B7 B626      IN	R2,0x36
    000B8 FE27      SBRS	R2,7
    000B9 CFFD      RJMP	0x00B7
(0129) 	if( I2CChkAck()!=I2C_START ) 
    000BA B181      IN	R24,0x01
    000BB 7F88      ANDI	R24,0xF8
    000BC 3088      CPI	R24,0x8
    000BD F011      BEQ	0x00C0
(0130) 		return I2C_ERR;
    000BE 2700      CLR	R16
    000BF C001      RJMP	0x00C1
(0131) 	return I2C_CRR;
    000C0 E001      LDI	R16,1
    000C1 9508      RET
(0132) }
(0133) /*--------------------------------------------------------------------
(0134) 函数名称：I2C ReStart
(0135) 函数功能：
(0136) 注意事项：
(0137) 提示说明：
(0138) 输    入：
(0139) 返    回：
(0140) --------------------------------------------------------------------*/
(0141) bool I2C_Restart()					
(0142) {
(0143) 	I2CStart();						
_I2C_Restart:
    000C2 EA84      LDI	R24,0xA4
    000C3 BF86      OUT	0x36,R24
(0144) 	I2CWaitAck();
    000C4 B626      IN	R2,0x36
    000C5 FE27      SBRS	R2,7
    000C6 CFFD      RJMP	0x00C4
(0145) 	if( I2CChkAck()!=I2C_RESTART ) 
    000C7 B181      IN	R24,0x01
    000C8 7F88      ANDI	R24,0xF8
    000C9 3180      CPI	R24,0x10
    000CA F011      BEQ	0x00CD
(0146) 		return I2C_ERR;
    000CB 2700      CLR	R16
    000CC C001      RJMP	0x00CE
(0147) 	return I2C_CRR;
    000CD E001      LDI	R16,1
    000CE 9508      RET
(0148) }
(0149) /*--------------------------------------------------------------------
(0150) 函数名称：发送 7位 器件写地址: XXXX XXX0
(0151) 函数功能：
(0152) 注意事项：
(0153) 提示说明：
(0154) 输    入：
(0155) 返    回：
(0156) --------------------------------------------------------------------*/
(0157) bool I2C_SendWrDAdr(uint8 wrDAdr)	
(0158) {
(0159) 	I2CSendByte(wrDAdr);			//设置 器件写地址
_I2C_SendWrDAdr:
  wrDAdr               --> R16
    000CF B903      OUT	0x03,R16
    000D0 E884      LDI	R24,0x84
    000D1 BF86      OUT	0x36,R24
(0160) 	I2CWaitAck();
    000D2 B626      IN	R2,0x36
    000D3 FE27      SBRS	R2,7
    000D4 CFFD      RJMP	0x00D2
(0161) 	if( I2CChkAck()!=I2C_MT_SLA_ACK )  
    000D5 B181      IN	R24,0x01
    000D6 7F88      ANDI	R24,0xF8
    000D7 3188      CPI	R24,0x18
    000D8 F011      BEQ	0x00DB
(0162) 		return I2C_ERR;
    000D9 2700      CLR	R16
    000DA C001      RJMP	0x00DC
(0163) 	return I2C_CRR;		
    000DB E001      LDI	R16,1
    000DC 9508      RET
_I2C_SendWrDAdr_:
  wrDAdr               --> R10
    000DD 92AA      ST	-Y,R10
    000DE 92BA      ST	-Y,R11
    000DF 0158      MOVW	R10,R16
(0164) }
(0165) /*--------------------------------------------------------------------
(0166) 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
(0167) 函数功能：
(0168) 注意事项：
(0169) 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
(0170) 输    入：
(0171) 返    回：
(0172) --------------------------------------------------------------------*/
(0173) bool I2C_SendWrDAdr_(uint16 wrDAdr)	
(0174) {
(0175) 	if( wrDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    000E0 FEA0      SBRS	R10,0
    000E1 C00E      RJMP	0x00F0
(0176) 		if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )	//设置 （高位）器件写地址
    000E2 2D0A      MOV	R16,R10
    000E3 9506      LSR	R16
    000E4 9506      LSR	R16
    000E5 9506      LSR	R16
    000E6 9506      LSR	R16
    000E7 9506      LSR	R16
    000E8 9506      LSR	R16
    000E9 9506      LSR	R16
    000EA 9506      LSR	R16
    000EB DFE3      RCALL	_I2C_SendWrDAdr
    000EC 2300      TST	R16
    000ED F411      BNE	0x00F0
(0177) 			return I2C_ERR;
    000EE 2700      CLR	R16
    000EF C007      RJMP	0x00F7
(0178) 	if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )	//设置 （低位）器件写地址
    000F0 2D0A      MOV	R16,R10
    000F1 DFDD      RCALL	_I2C_SendWrDAdr
    000F2 2300      TST	R16
    000F3 F411      BNE	0x00F6
(0179) 		return I2C_ERR;
    000F4 2700      CLR	R16
    000F5 C001      RJMP	0x00F7
(0180) 	return I2C_CRR;
    000F6 E001      LDI	R16,1
    000F7 90B9      LD	R11,Y+
    000F8 90A9      LD	R10,Y+
    000F9 9508      RET
(0181) }
(0182) /*--------------------------------------------------------------------
(0183) 函数名称：发送 7位 器件读地址: XXXX XXX1
(0184) 函数功能：
(0185) 注意事项：
(0186) 提示说明：
(0187) 输    入：
(0188) 返    回：
(0189) --------------------------------------------------------------------*/
(0190) bool I2C_SendRdDAdr(uint8 rdDAdr)	
(0191) {
(0192) 	I2CSendByte(rdDAdr);			//设置 器件读地址
_I2C_SendRdDAdr:
  rdDAdr               --> R16
    000FA B903      OUT	0x03,R16
    000FB E884      LDI	R24,0x84
    000FC BF86      OUT	0x36,R24
(0193) 	I2CWaitAck();
    000FD B626      IN	R2,0x36
    000FE FE27      SBRS	R2,7
    000FF CFFD      RJMP	0x00FD
(0194) 	if( I2CChkAck()!=I2C_MR_SLA_ACK )  
    00100 B181      IN	R24,0x01
    00101 7F88      ANDI	R24,0xF8
    00102 3480      CPI	R24,0x40
    00103 F011      BEQ	0x0106
(0195) 		return I2C_ERR;
    00104 2700      CLR	R16
    00105 C001      RJMP	0x0107
(0196) 	return I2C_CRR;	
    00106 E001      LDI	R16,1
    00107 9508      RET
_I2C_SendRdDAdr_:
  rdDAdr               --> R10
    00108 92AA      ST	-Y,R10
    00109 2EA0      MOV	R10,R16
(0197) }
(0198) /*--------------------------------------------------------------------
(0199) 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
(0200) 函数功能：
(0201) 注意事项：
(0202) 提示说明：
(0203) 输    入：
(0204) 返    回：
(0205) --------------------------------------------------------------------*/
(0206) bool I2C_SendRdDAdr_(uint8 rdDAdr)	
(0207) {
(0208) 	if( rdDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    0010A FEA0      SBRS	R10,0
    0010B C00E      RJMP	0x011A
(0209) 		if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )	//设置 （高位）器件读地址
    0010C 2D0A      MOV	R16,R10
    0010D 9506      LSR	R16
    0010E 9506      LSR	R16
    0010F 9506      LSR	R16
    00110 9506      LSR	R16
    00111 9506      LSR	R16
    00112 9506      LSR	R16
    00113 9506      LSR	R16
    00114 9506      LSR	R16
    00115 DFB9      RCALL	_I2C_SendWrDAdr
    00116 2300      TST	R16
    00117 F411      BNE	0x011A
(0210) 			return I2C_ERR;
    00118 2700      CLR	R16
    00119 C007      RJMP	0x0121
(0211) 	if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )	//设置 （低位）器件读地址
    0011A 2D0A      MOV	R16,R10
    0011B DFB3      RCALL	_I2C_SendWrDAdr
    0011C 2300      TST	R16
    0011D F411      BNE	0x0120
(0212) 		return I2C_ERR;
    0011E 2700      CLR	R16
    0011F C001      RJMP	0x0121
(0213) 	return I2C_CRR;
    00120 E001      LDI	R16,1
    00121 90A9      LD	R10,Y+
    00122 9508      RET
(0214) }
(0215) /*--------------------------------------------------------------------
(0216) 函数名称：I2C发送数据
(0217) 函数功能：
(0218) 注意事项：
(0219) 提示说明：
(0220) 输    入：
(0221) 返    回：
(0222) --------------------------------------------------------------------*/
(0223) bool I2C_SendDat(uint8 configDat)	
(0224) {
(0225) 	I2CSendByte(configDat);			
_I2C_SendDat:
  configDat            --> R16
    00123 B903      OUT	0x03,R16
    00124 E884      LDI	R24,0x84
    00125 BF86      OUT	0x36,R24
(0226) 	I2CWaitAck();
    00126 B626      IN	R2,0x36
    00127 FE27      SBRS	R2,7
    00128 CFFD      RJMP	0x0126
(0227) 	if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
    00129 B181      IN	R24,0x01
    0012A 7F88      ANDI	R24,0xF8
    0012B 3288      CPI	R24,0x28
    0012C F011      BEQ	0x012F
(0228) 		return I2C_ERR;
    0012D 2700      CLR	R16
    0012E C001      RJMP	0x0130
(0229) 	return I2C_CRR;	
    0012F E001      LDI	R16,1
    00130 9508      RET
(0230) }
(0231) /*--------------------------------------------------------------------
(0232) 函数名称：I2C接收数据且不产生应答
(0233) 函数功能：
(0234) 注意事项：
(0235) 提示说明：
(0236) 输    入：
(0237) 返    回：
(0238) --------------------------------------------------------------------*/
(0239) bool I2C_RcvNAckDat(uint8 *pRdDat)	
(0240) {
(0241) 	I2CRcvNckByte();
_I2C_RcvNAckDat:
  pRdDat               --> R16
    00131 E884      LDI	R24,0x84
    00132 BF86      OUT	0x36,R24
(0242) 	I2CWaitAck();
    00133 B626      IN	R2,0x36
    00134 FE27      SBRS	R2,7
    00135 CFFD      RJMP	0x0133
(0243) 	if( I2CChkAck()!=I2C_MR_DATA_NACK )
    00136 B181      IN	R24,0x01
    00137 7F88      ANDI	R24,0xF8
    00138 3588      CPI	R24,0x58
    00139 F011      BEQ	0x013C
(0244) 		return I2C_ERR;
    0013A 2700      CLR	R16
    0013B C004      RJMP	0x0140
(0245) 	*pRdDat=TWDR;
    0013C B023      IN	R2,0x03
    0013D 01F8      MOVW	R30,R16
    0013E 8220      ST	Z,R2
(0246) 	return I2C_CRR;
    0013F E001      LDI	R16,1
    00140 9508      RET
(0247) }
(0248) /*--------------------------------------------------------------------
(0249) 函数名称：I2C接收数据且产生应答
(0250) 函数功能：
(0251) 注意事项：
(0252) 提示说明：
(0253) 输    入：
(0254) 返    回：
(0255) --------------------------------------------------------------------*/
(0256) bool I2C_RcvAckDat(uint8 *pRdDat)	
(0257) {
(0258) 	I2CRcvAckByte();					
_I2C_RcvAckDat:
  pRdDat               --> R16
    00141 EC84      LDI	R24,0xC4
    00142 BF86      OUT	0x36,R24
(0259) 	I2CWaitAck();
    00143 B626      IN	R2,0x36
    00144 FE27      SBRS	R2,7
    00145 CFFD      RJMP	0x0143
(0260) 	if( I2CChkAck()!=I2C_MR_DATA_ACK )
    00146 B181      IN	R24,0x01
    00147 7F88      ANDI	R24,0xF8
    00148 3580      CPI	R24,0x50
    00149 F011      BEQ	0x014C
(0261) 		return I2C_ERR;
    0014A 2700      CLR	R16
    0014B C004      RJMP	0x0150
(0262) 	*pRdDat=TWDR;
    0014C B023      IN	R2,0x03
    0014D 01F8      MOVW	R30,R16
    0014E 8220      ST	Z,R2
(0263) 	return I2C_CRR;
    0014F E001      LDI	R16,1
    00150 9508      RET
_I2C_Write:
  dat                  --> R10
  wordAdr              --> R12
  wrDAdr               --> R14
    00151 940E 04A1 CALL	push_xgset00FC
    00153 2EC2      MOV	R12,R18
    00154 0178      MOVW	R14,R16
    00155 80AE      LDD	R10,Y+6
(0264) }
(0265) /*--------------------------------------------------------------------
(0266) 函数名称：I2C写器件，写一个数据
(0267) 函数功能：
(0268) 注意事项：
(0269) 提示说明：
(0270) 输    入：wrDAdr: write device-address 写器件地址
(0271) 		 wordAdr: word address 字地址
(0272) 		 dat: data 数据
(0273) 返    回：
(0274) --------------------------------------------------------------------*/
(0275) bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
(0276) {
(0277) 	if( I2C_Start()==I2C_ERR )
    00156 DF5E      RCALL	_I2C_Start
    00157 2300      TST	R16
    00158 F411      BNE	0x015B
(0278) 		return I2C_ERR;
    00159 2700      CLR	R16
    0015A C017      RJMP	0x0172
(0279) 
(0280) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    0015B 0187      MOVW	R16,R14
    0015C DF80      RCALL	_I2C_SendWrDAdr_
    0015D 2300      TST	R16
    0015E F411      BNE	0x0161
(0281) 		return I2C_ERR;
    0015F 2700      CLR	R16
    00160 C011      RJMP	0x0172
(0282) 
(0283) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    00161 2D0C      MOV	R16,R12
    00162 DFC0      RCALL	_I2C_SendDat
    00163 2EC0      MOV	R12,R16
    00164 2300      TST	R16
    00165 F411      BNE	0x0168
(0284) 		return I2C_ERR;
    00166 2700      CLR	R16
    00167 C00A      RJMP	0x0172
(0285) 
(0286) 	if( I2C_SendDat(dat)==I2C_ERR )
    00168 2D0A      MOV	R16,R10
    00169 DFB9      RCALL	_I2C_SendDat
    0016A 2EA0      MOV	R10,R16
    0016B 2300      TST	R16
    0016C F411      BNE	0x016F
(0287) 		return I2C_ERR;
    0016D 2700      CLR	R16
    0016E C003      RJMP	0x0172
(0288) 
(0289) 	I2C_Stop();
    0016F E984      LDI	R24,0x94
    00170 BF86      OUT	0x36,R24
(0290) 
(0291) 	return I2C_CRR;
    00171 E001      LDI	R16,1
    00172 940C 0482 JMP	pop_xgset00FC
_I2C_Read:
  pRdDat               --> R10
  rdDAdr               --> R12
  wordAdr              --> R14
  wrDAdr               --> R20
    00174 940E 049F CALL	push_xgset30FC
    00176 2EE2      MOV	R14,R18
    00177 01A8      MOVW	R20,R16
    00178 84C8      LDD	R12,Y+8
    00179 84AA      LDD	R10,Y+10
    0017A 84BB      LDD	R11,Y+11
(0292) }
(0293) /*--------------------------------------------------------------------
(0294) 函数名称：I2C写器件，写N个数据
(0295) 函数功能：
(0296) 注意事项：
(0297) 提示说明：
(0298) 输    入：wrDAdr: write device-address 写器件地址
(0299) 		 wordAdr: word address 字地址
(0300) 		 *pWrDat: p->write data 写入数据指针
(0301) 		 num: number 写入数据个数
(0302) 返    回：
(0303) --------------------------------------------------------------------*/
(0304) //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
(0305) //				  uint8 *pWrDat,uint8 num)
(0306) //{
(0307) //
(0308) //} 
(0309) /*--------------------------------------------------------------------
(0310) 函数名称：I2C读器件，读一个数据
(0311) 函数功能：
(0312) 注意事项：
(0313) 提示说明：
(0314) 输    入：wrDAdr: write device-address 写器件地址
(0315) 		 wordAdr: word address 字地址
(0316) 		 rdDAdr: read device-address 读器件地址
(0317) 		 *pRdDat: p->read data 读取数据指针
(0318) 返    回：
(0319) --------------------------------------------------------------------*/
(0320) bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
(0321) 			  uint8 rdDAdr,uint8 *pRdDat)
(0322) {
(0323) 	if( I2C_Start()==I2C_ERR )
    0017B DF39      RCALL	_I2C_Start
    0017C 2300      TST	R16
    0017D F411      BNE	0x0180
(0324) 		return I2C_ERR;
    0017E 2700      CLR	R16
    0017F C024      RJMP	0x01A4
(0325) 
(0326) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    00180 018A      MOVW	R16,R20
    00181 DF5B      RCALL	_I2C_SendWrDAdr_
    00182 2300      TST	R16
    00183 F411      BNE	0x0186
(0327) 		return I2C_ERR;
    00184 2700      CLR	R16
    00185 C01E      RJMP	0x01A4
(0328) 
(0329) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    00186 2D0E      MOV	R16,R14
    00187 DF9B      RCALL	_I2C_SendDat
    00188 2EE0      MOV	R14,R16
    00189 2300      TST	R16
    0018A F411      BNE	0x018D
(0330) 		return I2C_ERR;
    0018B 2700      CLR	R16
    0018C C017      RJMP	0x01A4
(0331) 
(0332) 	if( I2C_Restart()==I2C_ERR )
    0018D DF34      RCALL	_I2C_Restart
    0018E 2EE0      MOV	R14,R16
    0018F 2300      TST	R16
    00190 F411      BNE	0x0193
(0333) 		return I2C_ERR;
    00191 2700      CLR	R16
    00192 C011      RJMP	0x01A4
(0334) 
(0335) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    00193 2D0C      MOV	R16,R12
    00194 DF65      RCALL	_I2C_SendRdDAdr
    00195 2EC0      MOV	R12,R16
    00196 2300      TST	R16
    00197 F411      BNE	0x019A
(0336) 		return I2C_ERR;
    00198 2700      CLR	R16
    00199 C00A      RJMP	0x01A4
(0337) 
(0338) 	if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
    0019A 0185      MOVW	R16,R10
    0019B DF95      RCALL	_I2C_RcvNAckDat
    0019C 2EA0      MOV	R10,R16
    0019D 2300      TST	R16
    0019E F411      BNE	0x01A1
(0339) 		return I2C_ERR;
    0019F 2700      CLR	R16
    001A0 C003      RJMP	0x01A4
(0340) 
(0341) 	I2C_Stop();
    001A1 E984      LDI	R24,0x94
    001A2 BF86      OUT	0x36,R24
(0342) 
(0343) 	return I2C_CRR;
    001A3 E001      LDI	R16,1
    001A4 940C 0489 JMP	pop_xgset30FC
_I2C_Read_:
  i                    --> R12
  num                  --> R20
  pRdDat               --> R10
  rdDAdr               --> R12
  wordAdr              --> R14
  wrDAdr               --> R22
    001A6 940E 049D CALL	push_xgsetF0FC
    001A8 2EE2      MOV	R14,R18
    001A9 01B8      MOVW	R22,R16
    001AA 84CA      LDD	R12,Y+10
    001AB 84AC      LDD	R10,Y+12
    001AC 84BD      LDD	R11,Y+13
    001AD 854E      LDD	R20,Y+14
(0344) }
(0345) /*--------------------------------------------------------------------
(0346) 函数名称：I2C读器件，读N个数据
(0347) 函数功能：
(0348) 注意事项：
(0349) 提示说明：
(0350) 输    入：wrDAdr: write device-address 写器件地址
(0351) 		 wordAdr: word address 字地址
(0352) 		 rdDAdr: read device-address 读器件地址
(0353) 		 *pRdDat: p->read data 读取数据指针
(0354) 		 num: number 读取数据个数
(0355) 返    回：
(0356) --------------------------------------------------------------------*/
(0357) bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
(0358) 			   uint8 rdDAdr,uint8 *pRdDat,uint8 num)
(0359) {
(0360)  	uint8 i;
(0361) 	
(0362) 	if( I2C_Start()==I2C_ERR )
    001AE DF06      RCALL	_I2C_Start
    001AF 2300      TST	R16
    001B0 F411      BNE	0x01B3
(0363) 		return I2C_ERR;
    001B1 2700      CLR	R16
    001B2 C038      RJMP	0x01EB
(0364) 
(0365) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    001B3 018B      MOVW	R16,R22
    001B4 DF28      RCALL	_I2C_SendWrDAdr_
    001B5 2300      TST	R16
    001B6 F411      BNE	0x01B9
(0366) 		return I2C_ERR;
    001B7 2700      CLR	R16
    001B8 C032      RJMP	0x01EB
(0367) 
(0368) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    001B9 2D0E      MOV	R16,R14
    001BA DF68      RCALL	_I2C_SendDat
    001BB 2EE0      MOV	R14,R16
    001BC 2300      TST	R16
    001BD F411      BNE	0x01C0
(0369) 		return I2C_ERR;
    001BE 2700      CLR	R16
    001BF C02B      RJMP	0x01EB
(0370) 
(0371) 	if( I2C_Restart()==I2C_ERR )
    001C0 DF01      RCALL	_I2C_Restart
    001C1 2EE0      MOV	R14,R16
    001C2 2300      TST	R16
    001C3 F411      BNE	0x01C6
(0372) 		return I2C_ERR;
    001C4 2700      CLR	R16
    001C5 C025      RJMP	0x01EB
(0373) 
(0374) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    001C6 2D0C      MOV	R16,R12
    001C7 DF32      RCALL	_I2C_SendRdDAdr
    001C8 2EC0      MOV	R12,R16
    001C9 2300      TST	R16
    001CA F411      BNE	0x01CD
(0375) 		return I2C_ERR;
    001CB 2700      CLR	R16
    001CC C01E      RJMP	0x01EB
(0376) 
(0377) 	for(i=0;i<num-1;i++)
    001CD 24CC      CLR	R12
    001CE C00B      RJMP	0x01DA
(0378) 		if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
    001CF 2D0C      MOV	R16,R12
    001D0 2711      CLR	R17
    001D1 0D0A      ADD	R16,R10
    001D2 1D1B      ADC	R17,R11
    001D3 DF6D      RCALL	_I2C_RcvAckDat
    001D4 2EE0      MOV	R14,R16
    001D5 2300      TST	R16
    001D6 F411      BNE	0x01D9
(0379) 			return I2C_ERR;
    001D7 2700      CLR	R16
    001D8 C012      RJMP	0x01EB
    001D9 94C3      INC	R12
    001DA 2F84      MOV	R24,R20
    001DB 5081      SUBI	R24,1
    001DC 16C8      CP	R12,R24
    001DD F388      BCS	0x01CF
(0380) 	
(0381) 	if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
    001DE 2D0C      MOV	R16,R12
    001DF 2711      CLR	R17
    001E0 0D0A      ADD	R16,R10
    001E1 1D1B      ADC	R17,R11
    001E2 DF4E      RCALL	_I2C_RcvNAckDat
    001E3 2EA0      MOV	R10,R16
    001E4 2300      TST	R16
    001E5 F411      BNE	0x01E8
(0382) 			return I2C_ERR;
    001E6 2700      CLR	R16
    001E7 C003      RJMP	0x01EB
(0383) 
(0384) 	I2C_Stop();
    001E8 E984      LDI	R24,0x94
    001E9 BF86      OUT	0x36,R24
(0385) 	
(0386) 	return I2C_CRR;
    001EA E001      LDI	R16,1
    001EB 940C 0492 JMP	pop_xgsetF0FC
_delay50us:
  j                    --> R20
  t                    --> R16
    001ED 934A      ST	-Y,R20
FILE: D:\ICC_H\Hardware.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
(0005) 					
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Hardware_H
(0041) #define Hardware_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) #include <stdio.h>
(0046) #include <macros.h>
(0047) #include <eeprom.h>
(0048) //#include <wdt.h>
(0049) 
(0050) /* TWI configs */
(0051) //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
(0052) #if NO_INCLUDE_I2C_H
(0053) ;
(0054) #else
(0055) #include "D:\ICC_H\I2C.H"	//i2c即AVR的"twi"
(0056) #endif
(0057) 
(0058) /* hard configs */
(0059) #ifndef flash
(0060) 	#define flash	const
(0061) #endif
(0062) 
(0063) #ifndef code
(0064) 	#define code	const
(0065) #endif
(0066) 
(0067) #ifndef NOP
(0068) 	#define NOP()	asm("nop")
(0069) #endif
(0070) 
(0071) /* io configs */
(0072) #define sbi(io,bit)		(  io |=  (1<<bit) )	//example: sbi(PORTA,0);sbi(DDRA,0);
(0073) #define cbi(io,bit)		(  io &= ~(1<<bit) )	//example: cbi(PORTA,0);cbi(DDRA,0);
(0074) #define gbi(pin ,bit)	( pin &   (1<<bit) )	//example: gbi(PINA,0);
(0075) 
(0076) /* interrupt configs */
(0077) #define DIS_INT  asm("sei")
(0078) #define EN_INT   asm("cli")
(0079) 
(0080) /* wdt configs */
(0081) #define WDT()    asm("wdr")
(0082) 
(0083) /* bit operation */
(0084) //#ifndef BIT
(0085) //#define BIT(x)	( 1<<(x) )
(0086) //#endif
(0087) 
(0088) /* USART configs for 4 Mhz crystal */
(0089) //#define BAUD9600			25
(0090) //#define BAUD19000			12
(0091) //#define UART_TRAN_ON()	UCR |=  0x08
(0092) //#define UART_TRAN_OFF()	UCR &= ~0x08
(0093) //#define UART_RCV_ON()		UCR |=  0x10
(0094) //#define UART_RCV_OFF()	UCR &= ~0x10
(0095) 
(0096) /*--------------------------------------------------------------------
(0097) 函数全称：50us 延时
(0098) 函数功能：当然是 50us延时 啦
(0099) 注意事项：基于7.3728M晶振，稍微有点误差
(0100) 提示说明：调用delay50us（20），得到1ms延时
(0101) 输    入：	
(0102) 返    回：无 
(0103) --------------------------------------------------------------------*/
(0104) void delay50us(sint16 t)
(0105) {
(0106)     uint8 j;		
(0107)     for(;t>0;t--)			
    001EE C007      RJMP	0x01F6
(0108)         for(j=0;j<70;j++)	
    001EF 2744      CLR	R20
    001F0 C001      RJMP	0x01F2
    001F1 9543      INC	R20
    001F2 3446      CPI	R20,0x46
    001F3 F3E8      BCS	0x01F1
    001F4 5001      SUBI	R16,1
    001F5 4010      SBCI	R17,0
    001F6 2422      CLR	R2
    001F7 2433      CLR	R3
    001F8 1620      CP	R2,R16
    001F9 0631      CPC	R3,R17
    001FA F3A4      BLT	0x01EF
    001FB 9149      LD	R20,Y+
    001FC 9508      RET
_delay50ms:
  i                    --> R20
  t                    --> R16
    001FD 934A      ST	-Y,R20
    001FE 935A      ST	-Y,R21
(0109)             ;
(0110) }
(0111) /*--------------------------------------------------------------------
(0112) 函数全称：50ms 延时
(0113) 函数功能：当然是 50ms延时 啦
(0114) 注意事项：基于7.3728M晶振，稍微有点误差
(0115) 提示说明：调用delay50ms（20），得到1s延时 
(0116) 输    入：
(0117) 返    回：无
(0118) --------------------------------------------------------------------*/
(0119) void delay50ms(sint16 t)
(0120) {
(0121) 	uint16 i; 
(0122) 	for(;t>0;t--)
    001FF C013      RJMP	0x0213
(0123) 		for(i=0;i<52642;i++)
    00200 2744      CLR	R20
    00201 2755      CLR	R21
    00202 C002      RJMP	0x0205
    00203 5F4F      SUBI	R20,0xFF
    00204 4F5F      SBCI	R21,0xFF
    00205 EA82      LDI	R24,0xA2
    00206 EC9D      LDI	R25,0xCD
    00207 E0A0      LDI	R26,0
    00208 E0B0      LDI	R27,0
    00209 011A      MOVW	R2,R20
    0020A 2444      CLR	R4
    0020B 2455      CLR	R5
    0020C 1628      CP	R2,R24
    0020D 0639      CPC	R3,R25
    0020E 064A      CPC	R4,R26
    0020F 065B      CPC	R5,R27
    00210 F394      BLT	0x0203
    00211 5001      SUBI	R16,1
    00212 4010      SBCI	R17,0
    00213 2422      CLR	R2
    00214 2433      CLR	R3
    00215 1620      CP	R2,R16
    00216 0631      CPC	R3,R17
    00217 F344      BLT	0x0200
    00218 9159      LD	R21,Y+
    00219 9149      LD	R20,Y+
    0021A 9508      RET
_delayus:
  i                    --> R20
  t                    --> R16
    0021B 934A      ST	-Y,R20
    0021C 935A      ST	-Y,R21
(0124) 			; 
(0125) }
(0126) 
(0127) 
(0128) void delayus(uint16 t)
(0129) {
(0130) 	uint16 i;
(0131) 	for(i=0;i<t;i++)
    0021D 2744      CLR	R20
    0021E 2755      CLR	R21
    0021F C002      RJMP	0x0222
    00220 5F4F      SUBI	R20,0xFF
    00221 4F5F      SBCI	R21,0xFF
    00222 1740      CP	R20,R16
    00223 0751      CPC	R21,R17
    00224 F3D8      BCS	0x0220
    00225 9159      LD	R21,Y+
    00226 9149      LD	R20,Y+
    00227 9508      RET
FILE: E:\吴泽备份\DVK501光盘内容\STK16_~1.0\LCD128~1\LCD12864_ST7920\LCD12864_ST7920.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 	                                                        
(0004) 目    的:   建立LCD12864_ST7920的串模式操作库
(0005) 
(0006) 目标系统:   基于AVR单片机
(0007) 	                                                                
(0008) 应用软件:   ICCAVR                                               
(0009) 	                                                                
(0010) 版    本:   Version 1.0
(0011) 	                                                                
(0012) 圆版时间:   2005-09-06
(0013) 
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权 
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) 
(0026) 
(0027) ----------------------------------------------------------------------
(0028) 入口参数说明：
(0029) 	//#define OUT_LCD_CS	sbi(DDRD,0)
(0030) 	//#define SET_LCD_CS	sbi(PORTD,0)
(0031) 	//#define CLR_LCD_CS	cbi(PORTD,0)
(0032) 
(0033) ----------------------------------------------------------------------
(0034) 待定参数说明：
(0035) 	
(0036) 
(0037) ----------------------------------------------------------------------	
(0038) 对外变量说明：
(0039) 
(0040) ----------------------------------------------------------------------
(0041) 对外函数说明：
(0042) 
(0043) ----------------------------------------------------------------------
(0044) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0045) 
(0046) 
(0047) /*--------------------------------------------------------------------
(0048) 接口定义：
(0049) 
(0050) LCD12864_ST7920			ATmega16
(0051) 1.GND		--------	GND
(0052) 2.VCC		--------	VCC
(0053) 3.V0		--------	V0
(0054) 4.RS(CS)	--------	VCC
(0055) 5.R/W(SID)	--------	MOSI/PB5
(0056) 6.E(SCLK)	--------	SCK/PB7
(0057) 7.D0		--------	NC
(0058) 8.D1		--------	NC
(0059) 9.D2		--------	NC
(0060) 10.D3		--------	NC
(0061) 11.D4		--------	NC
(0062) 12.D5		--------	NC
(0063) 13.D6		--------	NC
(0064) 14.D7		--------	NC
(0065) 15.PSB		--------	GND
(0066) 16.NC		--------	NC
(0067) 17.RST		--------	NC
(0068) 18.NC		--------	NC
(0069) 19.LED+		--------	VCC
(0070) 20.LED-		--------	GND
(0071) 
(0072) 说明：
(0073) （1）使用ATmega16的硬件SPI操作LCD12864_ST7920
(0074) （2）PIN4/CS接VCC，其实也可接到特定的IO口，但外部程序需要指定
(0075) --------------------------------------------------------------------*/
(0076) 
(0077) #ifndef LCD12864_ST7920_H
(0078) #define LCD12864_ST7920_H
(0079) 
(0080) #include "D:\ICC_H\CmmIcc.h"
(0081) 
(0082) void SPI_init()
(0083) {
(0084) 	DDRB =0xFF;
_SPI_init:
    00228 EF8F      LDI	R24,0xFF
    00229 BB87      OUT	0x17,R24
(0085) 	SPCR = 0x50;	//setup SPI
    0022A E580      LDI	R24,0x50
    0022B B98D      OUT	0x0D,R24
(0086) 	SPSR = 0x01;	//setup SPI
    0022C E081      LDI	R24,1
    0022D B98E      OUT	0x0E,R24
(0087) 	SEI();			
    0022E 9478      BSET	7
    0022F 9508      RET
(0088) }
(0089) 
(0090) void lcd_wrByte(uint8 data)
(0091) {  
(0092) 	SPDR = data;        
_lcd_wrByte:
  data                 --> R16
    00230 B90F      OUT	0x0F,R16
(0093) 	while ((SPSR & 0x80) == 0);  
    00231 9B77      SBIS	0x0E,7
    00232 CFFE      RJMP	0x0231
    00233 9508      RET
_lcd_wrCmd:
  LC                   --> R10
  HC                   --> R12
    00234 92AA      ST	-Y,R10
    00235 92CA      ST	-Y,R12
    00236 2EA2      MOV	R10,R18
    00237 2EC0      MOV	R12,R16
(0094) }
(0095) 
(0096) void lcd_wrCmd(uint8 HC,uint8 LC)
(0097) {
(0098) 	lcd_wrByte(0xF8);
    00238 EF08      LDI	R16,0xF8
    00239 DFF6      RCALL	_lcd_wrByte
(0099) 	lcd_wrByte(HC);		//传输高四位
    0023A 2D0C      MOV	R16,R12
    0023B DFF4      RCALL	_lcd_wrByte
(0100) 	lcd_wrByte(LC);		//传输低四位
    0023C 2D0A      MOV	R16,R10
    0023D DFF2      RCALL	_lcd_wrByte
    0023E 90C9      LD	R12,Y+
    0023F 90A9      LD	R10,Y+
    00240 9508      RET
_lcd_wrDat:
  LD                   --> R10
  HD                   --> R12
    00241 92AA      ST	-Y,R10
    00242 92CA      ST	-Y,R12
    00243 2EA2      MOV	R10,R18
    00244 2EC0      MOV	R12,R16
(0101) }
(0102) 
(0103) void lcd_wrDat(uint8 HD,uint8 LD)
(0104) {
(0105) 	lcd_wrByte(0xFA);
    00245 EF0A      LDI	R16,0xFA
    00246 DFE9      RCALL	_lcd_wrByte
(0106) 	lcd_wrByte(HD);		//传输高四位
    00247 2D0C      MOV	R16,R12
    00248 DFE7      RCALL	_lcd_wrByte
(0107) 	lcd_wrByte(LD);		//传输低四位
    00249 2D0A      MOV	R16,R10
    0024A DFE5      RCALL	_lcd_wrByte
    0024B 90C9      LD	R12,Y+
    0024C 90A9      LD	R10,Y+
    0024D 9508      RET
_lcd_set_xy:
  adr                  --> R20
  y                    --> R22
  x                    --> R10
    0024E 940E 04A8 CALL	push_xgsetF00C
    00250 2F62      MOV	R22,R18
    00251 2EA0      MOV	R10,R16
(0108) } 
(0109) 
(0110) /*
(0111) x表示在第几行显示，y表示在第几列显示
(0112) */
(0113) void lcd_set_xy(uint8 x,uint8 y) 
(0114) {
(0115) 	uint8 adr;
(0116) 
(0117) 	switch(x)
    00252 24BB      CLR	R11
    00253 01C5      MOVW	R24,R10
    00254 3081      CPI	R24,1
    00255 E0E0      LDI	R30,0
    00256 079E      CPC	R25,R30
    00257 F069      BEQ	0x0265
    00258 3082      CPI	R24,2
    00259 E0E0      LDI	R30,0
    0025A 079E      CPC	R25,R30
    0025B F061      BEQ	0x0268
    0025C 3083      CPI	R24,3
    0025D E0E0      LDI	R30,0
    0025E 079E      CPC	R25,R30
    0025F F059      BEQ	0x026B
    00260 3084      CPI	R24,4
    00261 E0E0      LDI	R30,0
    00262 079E      CPC	R25,R30
    00263 F051      BEQ	0x026E
    00264 C00B      RJMP	0x0270
(0118) 	{
(0119) 	case 1: adr = 0x7F + y;
    00265 2F46      MOV	R20,R22
    00266 5841      SUBI	R20,0x81
(0120) 		break;		//在第1行y列显示
    00267 C008      RJMP	0x0270
(0121) 	case 2: adr = 0x8F + y;
    00268 2F46      MOV	R20,R22
    00269 5741      SUBI	R20,0x71
(0122) 		break;		//在第2行y列显示
    0026A C005      RJMP	0x0270
(0123) 	case 3: adr = 0x87 + y;
    0026B 2F46      MOV	R20,R22
    0026C 5749      SUBI	R20,0x79
(0124) 		break;		//在第3行y列显示
    0026D C002      RJMP	0x0270
(0125) 	case 4: adr = 0x97 + y;
    0026E 2F46      MOV	R20,R22
    0026F 5649      SUBI	R20,0x69
(0126) 		break;		//在第4行y列显示
(0127) 	default:	;
(0128) 	}
(0129) 	lcd_wrCmd(adr&0xF0,(adr&0x0F)<<4);
    00270 2F24      MOV	R18,R20
    00271 702F      ANDI	R18,0xF
    00272 702F      ANDI	R18,0xF
    00273 9522      SWAP	R18
    00274 2F04      MOV	R16,R20
    00275 7F00      ANDI	R16,0xF0
    00276 DFBD      RCALL	_lcd_wrCmd
    00277 940C 04AF JMP	pop_xgsetF00C
_lcd_putc:
  ch                   --> R20
  y                    --> R12
  x                    --> R10
    00279 940E 04B6 CALL	push_xgset303C
    0027B 2EC2      MOV	R12,R18
    0027C 2EA0      MOV	R10,R16
    0027D 814E      LDD	R20,Y+6
(0130) }
(0131) 
(0132) void lcd_putc(uint8 x,uint8 y,uint8 ch)
(0133) {
(0134) 	lcd_set_xy(x,y);
    0027E 2D2C      MOV	R18,R12
    0027F 2D0A      MOV	R16,R10
    00280 DFCD      RCALL	_lcd_set_xy
(0135) 	delay50us(20); 
    00281 E104      LDI	R16,0x14
    00282 E010      LDI	R17,0
    00283 DF69      RCALL	_delay50us
(0136) 	lcd_wrDat(ch&0xF0,(ch&0x0F)<<4);
    00284 2F24      MOV	R18,R20
    00285 702F      ANDI	R18,0xF
    00286 702F      ANDI	R18,0xF
    00287 9522      SWAP	R18
    00288 2F04      MOV	R16,R20
    00289 7F00      ANDI	R16,0xF0
    0028A DFB6      RCALL	_lcd_wrDat
    0028B 940C 04BD JMP	pop_xgset303C
_lcd_putd0:
  i                    --> R20
  length               --> R20
  dat                  --> Y,+7
  y                    --> R12
  x                    --> R10
    0028D 940E 04B6 CALL	push_xgset303C
    0028F 2EC2      MOV	R12,R18
    00290 2EA0      MOV	R10,R16
    00291 9721      SBIW	R28,1
    00292 854B      LDD	R20,Y+11
(0137) }
(0138) 
(0139) void lcd_putd0(uint8 x,uint8 y,uint32 dat,uint8 length)
(0140) {
(0141) 	sint8 i;
(0142) 
(0143) 	speaData(dat,length);
    00293 8348      ST	Y,R20
    00294 810F      LDD	R16,Y+7
    00295 8518      LDD	R17,Y+8
    00296 8529      LDD	R18,Y+9
    00297 853A      LDD	R19,Y+10
    00298 DDC3      RCALL	_speaData
(0144) 	lcd_set_xy(x,y);
    00299 2D2C      MOV	R18,R12
    0029A 2D0A      MOV	R16,R10
    0029B DFB2      RCALL	_lcd_set_xy
(0145) 	delay50us(40);
    0029C E208      LDI	R16,0x28
    0029D E010      LDI	R17,0
    0029E DF4E      RCALL	_delay50us
(0146) 	for(i=length-1;i>=0;i--)
    0029F 5041      SUBI	R20,1
    002A0 C01E      RJMP	0x02BF
(0147) 	{
(0148) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    002A1 E78D      LDI	R24,0x7D
    002A2 E090      LDI	R25,0
    002A3 2FE4      MOV	R30,R20
    002A4 27FF      CLR	R31
    002A5 FDE7      SBRC	R30,7
    002A6 95F0      COM	R31
    002A7 0FE8      ADD	R30,R24
    002A8 1FF9      ADC	R31,R25
    002A9 8180      LD	R24,Z
    002AA 2799      CLR	R25
    002AB 96C0      ADIW	R24,0x30
    002AC 019C      MOVW	R18,R24
    002AD 702F      ANDI	R18,0xF
    002AE 7030      ANDI	R19,0
    002AF 0F22      LSL	R18
    002B0 1F33      ROL	R19
    002B1 0F22      LSL	R18
    002B2 1F33      ROL	R19
    002B3 0F22      LSL	R18
    002B4 1F33      ROL	R19
    002B5 0F22      LSL	R18
    002B6 1F33      ROL	R19
    002B7 018C      MOVW	R16,R24
    002B8 7F00      ANDI	R16,0xF0
    002B9 7010      ANDI	R17,0
    002BA DF86      RCALL	_lcd_wrDat
(0149) 		delay50us(40); 
    002BB E208      LDI	R16,0x28
    002BC E010      LDI	R17,0
    002BD DF2F      RCALL	_delay50us
    002BE 954A      DEC	R20
    002BF 3040      CPI	R20,0
    002C0 F704      BGE	0x02A1
    002C1 9621      ADIW	R28,1
    002C2 940C 04BD JMP	pop_xgset303C
_lcd_putd:
  effectLen            --> R22
  i                    --> R20
  length               --> R10
  dat                  --> Y,+11
  y                    --> R14
  x                    --> R12
    002C4 940E 049D CALL	push_xgsetF0FC
    002C6 2EE2      MOV	R14,R18
    002C7 2EC0      MOV	R12,R16
    002C8 9721      SBIW	R28,1
    002C9 84AF      LDD	R10,Y+15
(0150) 	}
(0151) }
(0152) 
(0153) void lcd_putd(uint8 x,uint8 y,uint32 dat,uint8 length)
(0154) {
(0155) 	sint8 i;
(0156) 	sint8 effectLen;
(0157) 
(0158) 	if(dat>999999)
    002CA E38F      LDI	R24,0x3F
    002CB E492      LDI	R25,0x42
    002CC E0AF      LDI	R26,0xF
    002CD E0B0      LDI	R27,0
    002CE 842B      LDD	R2,Y+11
    002CF 843C      LDD	R3,Y+12
    002D0 844D      LDD	R4,Y+13
    002D1 845E      LDD	R5,Y+14
    002D2 1582      CP	R24,R2
    002D3 0593      CPC	R25,R3
    002D4 05A4      CPC	R26,R4
    002D5 05B5      CPC	R27,R5
    002D6 F410      BCC	0x02D9
(0159) 		effectLen=7;
    002D7 E067      LDI	R22,7
    002D8 C04C      RJMP	0x0325
(0160) 	else if(dat>99999)
    002D9 E98F      LDI	R24,0x9F
    002DA E896      LDI	R25,0x86
    002DB E0A1      LDI	R26,1
    002DC E0B0      LDI	R27,0
    002DD 842B      LDD	R2,Y+11
    002DE 843C      LDD	R3,Y+12
    002DF 844D      LDD	R4,Y+13
    002E0 845E      LDD	R5,Y+14
    002E1 1582      CP	R24,R2
    002E2 0593      CPC	R25,R3
    002E3 05A4      CPC	R26,R4
    002E4 05B5      CPC	R27,R5
    002E5 F410      BCC	0x02E8
(0161) 		effectLen=6;
    002E6 E066      LDI	R22,6
    002E7 C03D      RJMP	0x0325
(0162) 	else if(dat>9999)
    002E8 E08F      LDI	R24,0xF
    002E9 E297      LDI	R25,0x27
    002EA E0A0      LDI	R26,0
    002EB E0B0      LDI	R27,0
    002EC 842B      LDD	R2,Y+11
    002ED 843C      LDD	R3,Y+12
    002EE 844D      LDD	R4,Y+13
    002EF 845E      LDD	R5,Y+14
    002F0 1582      CP	R24,R2
    002F1 0593      CPC	R25,R3
    002F2 05A4      CPC	R26,R4
    002F3 05B5      CPC	R27,R5
    002F4 F410      BCC	0x02F7
(0163) 		effectLen=5;
    002F5 E065      LDI	R22,5
    002F6 C02E      RJMP	0x0325
(0164) 	else if(dat>999)
    002F7 EE87      LDI	R24,0xE7
    002F8 E093      LDI	R25,3
    002F9 E0A0      LDI	R26,0
    002FA E0B0      LDI	R27,0
    002FB 842B      LDD	R2,Y+11
    002FC 843C      LDD	R3,Y+12
    002FD 844D      LDD	R4,Y+13
    002FE 845E      LDD	R5,Y+14
    002FF 1582      CP	R24,R2
    00300 0593      CPC	R25,R3
    00301 05A4      CPC	R26,R4
    00302 05B5      CPC	R27,R5
    00303 F410      BCC	0x0306
(0165) 		effectLen=4;
    00304 E064      LDI	R22,4
    00305 C01F      RJMP	0x0325
(0166) 	else if(dat>99)
    00306 E683      LDI	R24,0x63
    00307 E090      LDI	R25,0
    00308 E0A0      LDI	R26,0
    00309 E0B0      LDI	R27,0
    0030A 842B      LDD	R2,Y+11
    0030B 843C      LDD	R3,Y+12
    0030C 844D      LDD	R4,Y+13
    0030D 845E      LDD	R5,Y+14
    0030E 1582      CP	R24,R2
    0030F 0593      CPC	R25,R3
    00310 05A4      CPC	R26,R4
    00311 05B5      CPC	R27,R5
    00312 F410      BCC	0x0315
(0167) 		effectLen=3;
    00313 E063      LDI	R22,3
    00314 C010      RJMP	0x0325
(0168) 	else if(dat>9)
    00315 E089      LDI	R24,0x9
    00316 E090      LDI	R25,0
    00317 E0A0      LDI	R26,0
    00318 E0B0      LDI	R27,0
    00319 842B      LDD	R2,Y+11
    0031A 843C      LDD	R3,Y+12
    0031B 844D      LDD	R4,Y+13
    0031C 845E      LDD	R5,Y+14
    0031D 1582      CP	R24,R2
    0031E 0593      CPC	R25,R3
    0031F 05A4      CPC	R26,R4
    00320 05B5      CPC	R27,R5
    00321 F410      BCC	0x0324
(0169) 		effectLen=2;
    00322 E062      LDI	R22,2
    00323 C001      RJMP	0x0325
(0170) 	else
(0171) 		effectLen=1;
    00324 E061      LDI	R22,1
(0172) 	speaData(dat,effectLen);
    00325 8368      ST	Y,R22
    00326 850B      LDD	R16,Y+11
    00327 851C      LDD	R17,Y+12
    00328 852D      LDD	R18,Y+13
    00329 853E      LDD	R19,Y+14
    0032A DD31      RCALL	_speaData
(0173) 
(0174) 	lcd_set_xy(x,y);
    0032B 2D2E      MOV	R18,R14
    0032C 2D0C      MOV	R16,R12
    0032D DF20      RCALL	_lcd_set_xy
(0175) 	delay50us(40); 
    0032E E208      LDI	R16,0x28
    0032F E010      LDI	R17,0
    00330 DEBC      RCALL	_delay50us
(0176) 	if(length>effectLen)
    00331 2E26      MOV	R2,R22
    00332 2433      CLR	R3
    00333 FC27      SBRC	R2,7
    00334 9430      COM	R3
    00335 2C4A      MOV	R4,R10
    00336 2455      CLR	R5
    00337 1424      CP	R2,R4
    00338 0435      CPC	R3,R5
    00339 F46C      BGE	0x0347
(0177) 	{
(0178) 		for(i=length-effectLen-1;i>=0;i--)
    0033A 2D44      MOV	R20,R4
    0033B 1B46      SUB	R20,R22
    0033C 5041      SUBI	R20,1
    0033D C007      RJMP	0x0345
(0179) 		{
(0180) 			lcd_wrDat(' '&0xF0,(' '&0x0F)<<4);
    0033E 2722      CLR	R18
    0033F E200      LDI	R16,0x20
    00340 DF00      RCALL	_lcd_wrDat
(0181) 			delay50us(40); 
    00341 E208      LDI	R16,0x28
    00342 E010      LDI	R17,0
    00343 DEA9      RCALL	_delay50us
    00344 954A      DEC	R20
    00345 3040      CPI	R20,0
    00346 F7BC      BGE	0x033E
(0182) 		}
(0183) 	}
(0184) 	for(i=effectLen-1;i>=0;i--)
    00347 2F46      MOV	R20,R22
    00348 5041      SUBI	R20,1
    00349 C01E      RJMP	0x0368
(0185) 	{
(0186) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    0034A E78D      LDI	R24,0x7D
    0034B E090      LDI	R25,0
    0034C 2FE4      MOV	R30,R20
    0034D 27FF      CLR	R31
    0034E FDE7      SBRC	R30,7
    0034F 95F0      COM	R31
    00350 0FE8      ADD	R30,R24
    00351 1FF9      ADC	R31,R25
    00352 8180      LD	R24,Z
    00353 2799      CLR	R25
    00354 96C0      ADIW	R24,0x30
    00355 019C      MOVW	R18,R24
    00356 702F      ANDI	R18,0xF
    00357 7030      ANDI	R19,0
    00358 0F22      LSL	R18
    00359 1F33      ROL	R19
    0035A 0F22      LSL	R18
    0035B 1F33      ROL	R19
    0035C 0F22      LSL	R18
    0035D 1F33      ROL	R19
    0035E 0F22      LSL	R18
    0035F 1F33      ROL	R19
    00360 018C      MOVW	R16,R24
    00361 7F00      ANDI	R16,0xF0
    00362 7010      ANDI	R17,0
    00363 DEDD      RCALL	_lcd_wrDat
(0187) 		delay50us(40);
    00364 E208      LDI	R16,0x28
    00365 E010      LDI	R17,0
    00366 DE86      RCALL	_delay50us
    00367 954A      DEC	R20
    00368 3040      CPI	R20,0
    00369 F704      BGE	0x034A
    0036A 9621      ADIW	R28,1
    0036B 940C 0492 JMP	pop_xgsetF0FC
_lcd_puts:
  str                  --> R20
  y                    --> R12
  x                    --> R10
    0036D 940E 04B6 CALL	push_xgset303C
    0036F 2EC2      MOV	R12,R18
    00370 2EA0      MOV	R10,R16
    00371 814E      LDD	R20,Y+6
    00372 815F      LDD	R21,Y+7
(0188) 	}
(0189) }
(0190) 
(0191) void lcd_puts(uint8 x,uint8 y,uint8 *str)
(0192) { 
(0193) 	lcd_set_xy(x,y);
    00373 2D2C      MOV	R18,R12
    00374 2D0A      MOV	R16,R10
    00375 DED8      RCALL	_lcd_set_xy
(0194) 	delay50us(20);   
    00376 E104      LDI	R16,0x14
    00377 E010      LDI	R17,0
    00378 DE74      RCALL	_delay50us
    00379 C00F      RJMP	0x0389
(0195) 	while(*str)
(0196) 	{
(0197) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    0037A 01FA      MOVW	R30,R20
    0037B 8020      LD	R2,Z
    0037C 2433      CLR	R3
    0037D 2D22      MOV	R18,R2
    0037E 702F      ANDI	R18,0xF
    0037F 702F      ANDI	R18,0xF
    00380 9522      SWAP	R18
    00381 2D02      MOV	R16,R2
    00382 7F00      ANDI	R16,0xF0
    00383 DEBD      RCALL	_lcd_wrDat
(0198) 		str++;
    00384 5F4F      SUBI	R20,0xFF
    00385 4F5F      SBCI	R21,0xFF
(0199) 		delay50us(20);
    00386 E104      LDI	R16,0x14
    00387 E010      LDI	R17,0
    00388 DE64      RCALL	_delay50us
    00389 01FA      MOVW	R30,R20
    0038A 8020      LD	R2,Z
    0038B 2022      TST	R2
    0038C F769      BNE	0x037A
    0038D 940C 04BD JMP	pop_xgset303C
_lcd_puts_:
  dlyMs                --> R10
  str                  --> R20
  y                    --> R14
  x                    --> R12
    0038F 940E 049F CALL	push_xgset30FC
    00391 2EE2      MOV	R14,R18
    00392 2EC0      MOV	R12,R16
    00393 8548      LDD	R20,Y+8
    00394 8559      LDD	R21,Y+9
    00395 84AA      LDD	R10,Y+10
(0200) 	} 
(0201) }
(0202) 
(0203) void lcd_puts_(uint8 x,uint8 y,uint8 *str,uint8 dlyMs)
(0204) { 
(0205) 	lcd_set_xy(x,y);
    00396 2D2E      MOV	R18,R14
    00397 2D0C      MOV	R16,R12
    00398 DEB5      RCALL	_lcd_set_xy
(0206) 	delay50us(20);   
    00399 E104      LDI	R16,0x14
    0039A E010      LDI	R17,0
    0039B DE51      RCALL	_delay50us
    0039C C00F      RJMP	0x03AC
(0207) 	while(*str)
(0208) 	{
(0209) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    0039D 01FA      MOVW	R30,R20
    0039E 8020      LD	R2,Z
    0039F 2433      CLR	R3
    003A0 2D22      MOV	R18,R2
    003A1 702F      ANDI	R18,0xF
    003A2 702F      ANDI	R18,0xF
    003A3 9522      SWAP	R18
    003A4 2D02      MOV	R16,R2
    003A5 7F00      ANDI	R16,0xF0
    003A6 DE9A      RCALL	_lcd_wrDat
(0210) 		str++;
    003A7 5F4F      SUBI	R20,0xFF
    003A8 4F5F      SBCI	R21,0xFF
(0211) 		delay50ms(dlyMs);
    003A9 2D0A      MOV	R16,R10
    003AA 2711      CLR	R17
    003AB DE51      RCALL	_delay50ms
    003AC 01FA      MOVW	R30,R20
    003AD 8020      LD	R2,Z
    003AE 2022      TST	R2
    003AF F769      BNE	0x039D
    003B0 940C 0489 JMP	pop_xgset30FC
(0212) 	} 
(0213) }
(0214) 
(0215) void lcd_clr()
(0216) {
(0217) 	lcd_wrCmd(0x00,0x10);
_lcd_clr:
    003B2 E120      LDI	R18,0x10
    003B3 2700      CLR	R16
    003B4 DE7F      RCALL	_lcd_wrCmd
(0218) 	delay50us(200);
    003B5 EC08      LDI	R16,0xC8
    003B6 E010      LDI	R17,0
    003B7 CE35      RJMP	_delay50us
(0219) }
(0220) 
(0221) void lcd_init(void)
(0222) {
(0223) 	SPI_init();	
_lcd_init:
    003B8 DE6F      RCALL	_SPI_init
(0224) 	//OUT_LCD_CS;		//若LCD_CS
(0225) 	//SET_LCD_CS;		
(0226) 	delay50ms(1);
    003B9 E001      LDI	R16,1
    003BA E010      LDI	R17,0
    003BB DE41      RCALL	_delay50ms
(0227) 	lcd_wrCmd(0x30,0x30);	//使用8位控制界面,使用基本指令集
    003BC E320      LDI	R18,0x30
    003BD E300      LDI	R16,0x30
    003BE DE75      RCALL	_lcd_wrCmd
(0228) 	//lcd_wrCmd(0x00,0xF0);	//整体显示ON
(0229) 	lcd_wrCmd(0x00,0xC0);	//整体显示ON
    003BF EC20      LDI	R18,0xC0
    003C0 2700      CLR	R16
    003C1 DE72      RCALL	_lcd_wrCmd
(0230) 	lcd_wrCmd(0x00,0x10);	//清屏
    003C2 E120      LDI	R18,0x10
    003C3 2700      CLR	R16
    003C4 DE6F      RCALL	_lcd_wrCmd
(0231) 	//lcd_wrCmd(0x10,0x00);	//光标
(0232) 	lcd_wrCmd(0x00,0x60);
    003C5 E620      LDI	R18,0x60
    003C6 2700      CLR	R16
    003C7 DE6C      RCALL	_lcd_wrCmd
(0233) 	//lcd_wrCmd(0x00,0x70);	//显示右移
(0234) 	delay50ms(1);		//不可省去！！！
    003C8 E001      LDI	R16,1
    003C9 E010      LDI	R17,0
    003CA CE32      RJMP	_delay50ms
_main:
    003CB 9722      SBIW	R28,2
FILE: E:\吴泽备份\DVK501光盘内容\STK16_~1.0\LCD128~1\LCD12864_ST7920\LCD12864_ST7920.C
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                            
(0004) 项目名称:   LCD12864示例程序
(0005) 		
(0006) 目标系统:   “DVK501” && “M16+ EX”
(0007) 
(0008) 应用软件:   ICCAVR 6.31A                                             
(0009) 		                                                                
(0010) 版    本:   V1.0 
(0011)                                                         
(0012) 圆版时间:   2009-7-1
(0013) 
(0014) 开发人员:   zz
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 		
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 实验内容：
(0027) 通过ATmega48的硬件SPI送数据给LCD12864显示
(0028) ----------------------------------------------------------------------
(0029) 硬件连接： 
(0030) 		 	  DVK501				 STK16+
(0031) 				CS	    ---------	  VCC
(0032) 				SID		---------	  PB5
(0033) 				SCK		---------	  PB7
(0034) 				PSB		---------	  GND
(0035) ----------------------------------------------------------------------
(0036) 注意事项：
(0037) （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
(0038) （2）请详细阅读“使用必读”及相关资料。
(0039) ----------------------------------------------------------------------
(0040) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0041) 
(0042) #include <iom16v.h>
(0043) 
(0044) #include "LCD12864_ST7920.H"
(0045) 
(0046) /*--------------------------------------------------------------------
(0047) 函数名称：
(0048) 函数功能：
(0049) 注意事项：
(0050) 提示说明：
(0051) 输    入：
(0052) 返    回：
(0053) --------------------------------------------------------------------*/
(0054) void main()
(0055) {             
(0056) 	SEI();
    003CC 9478      BSET	7
(0057) 	lcd_init();
    003CD DFEA      RCALL	_lcd_init
(0058) 	lcd_puts(1,1,"  WaveShare.net");
    003CE E68D      LDI	R24,0x6D
    003CF E090      LDI	R25,0
    003D0 8399      STD	Y+1,R25
    003D1 8388      ST	Y,R24
    003D2 E021      LDI	R18,1
    003D3 E001      LDI	R16,1
    003D4 DF98      RCALL	_lcd_puts
(0059) 	lcd_puts(3,1,"    微雪电子");
    003D5 E680      LDI	R24,0x60
    003D6 E090      LDI	R25,0
    003D7 8399      STD	Y+1,R25
    003D8 8388      ST	Y,R24
    003D9 E021      LDI	R18,1
    003DA E003      LDI	R16,3
    003DB DF91      RCALL	_lcd_puts
(0060) 	while(1);
FILE: <library>
    003DC CFFF      RJMP	0x03DC
    003DD 9622      ADIW	R28,2
    003DE 9508      RET
push_arg4:
    003DF 933A      ST	-Y,R19
    003E0 932A      ST	-Y,R18
push_arg2:
    003E1 931A      ST	-Y,R17
    003E2 930A      ST	-Y,R16
    003E3 9508      RET
div32u:
    003E4 94E8      BCLR	6
    003E5 C001      RJMP	0x03E7
mod32u:
    003E6 9468      BSET	6
    003E7 D030      RCALL	long_div_prolog
    003E8 24CC      CLR	R12
    003E9 C009      RJMP	0x03F3
div32s:
    003EA 94E8      BCLR	6
    003EB C001      RJMP	0x03ED
mod32s:
    003EC 9468      BSET	6
    003ED D02A      RCALL	long_div_prolog
    003EE FD37      SBRC	R19,7
    003EF 940E 04D6 CALL	neg32
    003F1 FDB7      SBRC	R27,7
    003F2 D052      RCALL	neg_R24_R27
    003F3 2477      CLR	R7
    003F4 2488      CLR	R8
    003F5 2499      CLR	R9
    003F6 24AA      CLR	R10
    003F7 24BB      CLR	R11
    003F8 D042      RCALL	tst_R16_R19
    003F9 F0C1      BEQ	0x0412
    003FA D045      RCALL	tst_R24_R27
    003FB F0B1      BEQ	0x0412
    003FC E2E8      LDI	R30,0x28
    003FD 0F00      LSL	R16
    003FE 1F11      ROL	R17
    003FF 1F22      ROL	R18
    00400 1F33      ROL	R19
    00401 1C77      ROL	R7
    00402 1C88      ROL	R8
    00403 1C99      ROL	R9
    00404 1CAA      ROL	R10
    00405 1CBB      ROL	R11
    00406 1688      CP	R8,R24
    00407 0699      CPC	R9,R25
    00408 06AA      CPC	R10,R26
    00409 06BB      CPC	R11,R27
    0040A F028      BCS	0x0410
    0040B 1A88      SUB	R8,R24
    0040C 0A99      SBC	R9,R25
    0040D 0AAA      SBC	R10,R26
    0040E 0ABB      SBC	R11,R27
    0040F 9503      INC	R16
    00410 95EA      DEC	R30
    00411 F759      BNE	0x03FD
    00412 F426      BRTC	0x0417
    00413 2D08      MOV	R16,R8
    00414 2D19      MOV	R17,R9
    00415 2D2A      MOV	R18,R10
    00416 2D3B      MOV	R19,R11
    00417 C013      RJMP	long_div_epilog
long_div_prolog:
    00418 927A      ST	-Y,R7
    00419 928A      ST	-Y,R8
    0041A 929A      ST	-Y,R9
    0041B 92AA      ST	-Y,R10
    0041C 92BA      ST	-Y,R11
    0041D 92CA      ST	-Y,R12
    0041E 93EA      ST	-Y,R30
    0041F 938A      ST	-Y,R24
    00420 939A      ST	-Y,R25
    00421 93AA      ST	-Y,R26
    00422 93BA      ST	-Y,R27
    00423 858B      LDD	R24,Y+11
    00424 859C      LDD	R25,Y+12
    00425 85AD      LDD	R26,Y+13
    00426 85BE      LDD	R27,Y+14
    00427 2EC3      MOV	R12,R19
    00428 F00E      BRTS	0x042A
    00429 26CB      EOR	R12,R27
    0042A 9508      RET
long_div_epilog:
    0042B FCC7      SBRC	R12,7
    0042C 940E 04D6 CALL	neg32
    0042E 91B9      LD	R27,Y+
    0042F 91A9      LD	R26,Y+
    00430 9199      LD	R25,Y+
    00431 9189      LD	R24,Y+
    00432 91E9      LD	R30,Y+
    00433 90C9      LD	R12,Y+
    00434 90B9      LD	R11,Y+
    00435 90A9      LD	R10,Y+
    00436 9099      LD	R9,Y+
    00437 9089      LD	R8,Y+
    00438 9079      LD	R7,Y+
    00439 9624      ADIW	R28,4
    0043A 9508      RET
tst_R16_R19:
    0043B 2FE0      MOV	R30,R16
    0043C 2BE1      OR	R30,R17
    0043D 2BE2      OR	R30,R18
    0043E 2BE3      OR	R30,R19
    0043F 9508      RET
tst_R24_R27:
    00440 2FE8      MOV	R30,R24
    00441 2BE9      OR	R30,R25
    00442 2BEA      OR	R30,R26
    00443 2BEB      OR	R30,R27
    00444 9508      RET
neg_R24_R27:
    00445 9580      COM	R24
    00446 9590      COM	R25
    00447 95A0      COM	R26
    00448 95B0      COM	R27
    00449 5F8F      SUBI	R24,0xFF
    0044A 4F9F      SBCI	R25,0xFF
    0044B 4FAF      SBCI	R26,0xFF
    0044C 4FBF      SBCI	R27,0xFF
    0044D 9508      RET
empy32u|empy32s:
    0044E 940E 04DF CALL	long_prolog
    00450 927A      ST	-Y,R7
    00451 940E 04F8 CALL	tstzero1
    00453 F159      BEQ	0x047F
    00454 2477      CLR	R7
    00455 940E 04FE CALL	tstzero2
    00457 F419      BNE	0x045B
    00458 018C      MOVW	R16,R24
    00459 019D      MOVW	R18,R26
    0045A C024      RJMP	0x047F
    0045B 920A      ST	-Y,R0
    0045C 921A      ST	-Y,R1
    0045D 9F08      MUL	R16,R24
    0045E 2CB0      MOV	R11,R0
    0045F 2CA1      MOV	R10,R1
    00460 9F28      MUL	R18,R24
    00461 2C90      MOV	R9,R0
    00462 2C81      MOV	R8,R1
    00463 9F18      MUL	R17,R24
    00464 0CA0      ADD	R10,R0
    00465 1C91      ADC	R9,R1
    00466 1C87      ADC	R8,R7
    00467 9F09      MUL	R16,R25
    00468 0CA0      ADD	R10,R0
    00469 1C91      ADC	R9,R1
    0046A 1C87      ADC	R8,R7
    0046B 9F19      MUL	R17,R25
    0046C 0C90      ADD	R9,R0
    0046D 1C81      ADC	R8,R1
    0046E 9F0A      MUL	R16,R26
    0046F 0C90      ADD	R9,R0
    00470 1C81      ADC	R8,R1
    00471 9F38      MUL	R19,R24
    00472 0C80      ADD	R8,R0
    00473 9F29      MUL	R18,R25
    00474 0C80      ADD	R8,R0
    00475 9F1A      MUL	R17,R26
    00476 0C80      ADD	R8,R0
    00477 9F0B      MUL	R16,R27
    00478 0C80      ADD	R8,R0
    00479 9019      LD	R1,Y+
    0047A 9009      LD	R0,Y+
    0047B 2D0B      MOV	R16,R11
    0047C 2D1A      MOV	R17,R10
    0047D 2D29      MOV	R18,R9
    0047E 2D38      MOV	R19,R8
    0047F 9079      LD	R7,Y+
    00480 940C 04ED JMP	long_epilog
pop_xgset00FC:
    00482 90A9      LD	R10,Y+
    00483 90B9      LD	R11,Y+
    00484 90C9      LD	R12,Y+
    00485 90D9      LD	R13,Y+
    00486 90E9      LD	R14,Y+
    00487 90F9      LD	R15,Y+
    00488 9508      RET
pop_xgset30FC:
    00489 90A9      LD	R10,Y+
    0048A 90B9      LD	R11,Y+
    0048B 90C9      LD	R12,Y+
    0048C 90D9      LD	R13,Y+
    0048D 90E9      LD	R14,Y+
    0048E 90F9      LD	R15,Y+
    0048F 9149      LD	R20,Y+
    00490 9159      LD	R21,Y+
    00491 9508      RET
pop_xgsetF0FC:
    00492 90A9      LD	R10,Y+
    00493 90B9      LD	R11,Y+
    00494 90C9      LD	R12,Y+
    00495 90D9      LD	R13,Y+
    00496 90E9      LD	R14,Y+
    00497 90F9      LD	R15,Y+
    00498 9149      LD	R20,Y+
    00499 9159      LD	R21,Y+
    0049A 9169      LD	R22,Y+
    0049B 9179      LD	R23,Y+
    0049C 9508      RET
push_xgsetF0FC:
    0049D 937A      ST	-Y,R23
    0049E 936A      ST	-Y,R22
push_xgset30FC:
    0049F 935A      ST	-Y,R21
    004A0 934A      ST	-Y,R20
push_xgset00FC:
    004A1 92FA      ST	-Y,R15
    004A2 92EA      ST	-Y,R14
push_xgset003C:
    004A3 92DA      ST	-Y,R13
    004A4 92CA      ST	-Y,R12
    004A5 92BA      ST	-Y,R11
    004A6 92AA      ST	-Y,R10
    004A7 9508      RET
push_xgsetF00C:
    004A8 937A      ST	-Y,R23
    004A9 936A      ST	-Y,R22
    004AA 935A      ST	-Y,R21
    004AB 934A      ST	-Y,R20
    004AC 92BA      ST	-Y,R11
    004AD 92AA      ST	-Y,R10
    004AE 9508      RET
pop_xgsetF00C:
    004AF 90A9      LD	R10,Y+
    004B0 90B9      LD	R11,Y+
    004B1 9149      LD	R20,Y+
    004B2 9159      LD	R21,Y+
    004B3 9169      LD	R22,Y+
    004B4 9179      LD	R23,Y+
    004B5 9508      RET
push_xgset303C:
    004B6 935A      ST	-Y,R21
    004B7 934A      ST	-Y,R20
    004B8 92DA      ST	-Y,R13
    004B9 92CA      ST	-Y,R12
    004BA 92BA      ST	-Y,R11
    004BB 92AA      ST	-Y,R10
    004BC 9508      RET
pop_xgset303C:
    004BD 90A9      LD	R10,Y+
    004BE 90B9      LD	R11,Y+
    004BF 90C9      LD	R12,Y+
    004C0 90D9      LD	R13,Y+
    004C1 9149      LD	R20,Y+
    004C2 9159      LD	R21,Y+
    004C3 9508      RET
push_xgsetF03C:
    004C4 937A      ST	-Y,R23
    004C5 936A      ST	-Y,R22
    004C6 935A      ST	-Y,R21
    004C7 934A      ST	-Y,R20
    004C8 92DA      ST	-Y,R13
    004C9 92CA      ST	-Y,R12
    004CA 92BA      ST	-Y,R11
    004CB 92AA      ST	-Y,R10
    004CC 9508      RET
pop_xgsetF03C:
    004CD 90A9      LD	R10,Y+
    004CE 90B9      LD	R11,Y+
    004CF 90C9      LD	R12,Y+
    004D0 90D9      LD	R13,Y+
    004D1 9149      LD	R20,Y+
    004D2 9159      LD	R21,Y+
    004D3 9169      LD	R22,Y+
    004D4 9179      LD	R23,Y+
    004D5 9508      RET
neg32:
    004D6 9500      COM	R16
    004D7 9510      COM	R17
    004D8 9520      COM	R18
    004D9 9530      COM	R19
    004DA 5F0F      SUBI	R16,0xFF
    004DB 4F1F      SBCI	R17,0xFF
    004DC 4F2F      SBCI	R18,0xFF
    004DD 4F3F      SBCI	R19,0xFF
    004DE 9508      RET
long_prolog:
    004DF 928A      ST	-Y,R8
    004E0 929A      ST	-Y,R9
    004E1 92AA      ST	-Y,R10
    004E2 92BA      ST	-Y,R11
    004E3 93EA      ST	-Y,R30
    004E4 938A      ST	-Y,R24
    004E5 939A      ST	-Y,R25
    004E6 93AA      ST	-Y,R26
    004E7 93BA      ST	-Y,R27
    004E8 8589      LDD	R24,Y+9
    004E9 859A      LDD	R25,Y+10
    004EA 85AB      LDD	R26,Y+11
    004EB 85BC      LDD	R27,Y+12
    004EC 9508      RET
long_epilog:
    004ED 91B9      LD	R27,Y+
    004EE 91A9      LD	R26,Y+
    004EF 9199      LD	R25,Y+
    004F0 9189      LD	R24,Y+
    004F1 91E9      LD	R30,Y+
    004F2 90B9      LD	R11,Y+
    004F3 90A9      LD	R10,Y+
    004F4 9099      LD	R9,Y+
    004F5 9089      LD	R8,Y+
    004F6 9624      ADIW	R28,4
    004F7 9508      RET
tstzero1:
    004F8 27EE      CLR	R30
    004F9 2BE0      OR	R30,R16
    004FA 2BE1      OR	R30,R17
    004FB 2BE2      OR	R30,R18
    004FC 2BE3      OR	R30,R19
    004FD 9508      RET
tstzero2:
    004FE 27EE      CLR	R30
    004FF 2BE8      OR	R30,R24
    00500 2BE9      OR	R30,R25
    00501 2BEA      OR	R30,R26
    00502 2BEB      OR	R30,R27
    00503 9508      RET
