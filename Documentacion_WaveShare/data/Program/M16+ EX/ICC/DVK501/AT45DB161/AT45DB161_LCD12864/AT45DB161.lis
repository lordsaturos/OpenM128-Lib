                        .module AT45DB161.C
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\..\STK16_~1.0\AT45DB~1\AT45DB161_LCD12864\AT45DB161.C
 0000                   .dbfile D:\ICC_H\Software.H
 0000                   .dbfunc e speaData _speaData fV
 0000           ;              y -> y+4
 0000           ;              j -> y+0
 0000           ;              i -> R10
 0000           ;            len -> R12
 0000           ;            dat -> y+16
                        .even
 0000           _speaData::
 0000 00D0              rcall push_arg4
 0002 00D0              rcall push_xgsetF03C
 0004 2897              sbiw R28,8
 0006 CC88              ldd R12,y+20
 0008                   .dbline -1
 0008                   .dbline 116
 0008           ; /*********************************************************************
 0008           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0008           ;                                                                       
 0008           ; 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
 0008           ;       
 0008           ; 目标系统:   基于AVR单片机
 0008           ;                                                                               
 0008           ; 应用软件:   ICCAVR
 0008           ;                                                                               
 0008           ; 版    本:   Version 1.0                                                       
 0008           ;                                                                               
 0008           ; 圆版时间:   2005-06-25
 0008           ;       
 0008           ; 开发人员:   SEE
 0008           ; 
 0008           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0008           ;       
 0008           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0008           ; *********************************************************************/
 0008           ; 
 0008           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0008           ; ----------------------------------------------------------------------
 0008           ; 版本更新记录：
 0008           ; 
 0008           ; ----------------------------------------------------------------------
 0008           ; 入口参数说明：
 0008           ; 
 0008           ; ----------------------------------------------------------------------
 0008           ; 待定参数说明：
 0008           ; 
 0008           ; ----------------------------------------------------------------------        
 0008           ; 对外变量说明：
 0008           ;     
 0008           ; ----------------------------------------------------------------------
 0008           ; 对外函数说明：
 0008           ;    
 0008           ; ----------------------------------------------------------------------
 0008           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 0008           ; 
 0008           ; #ifndef Software_H
 0008           ; #define Software_H
 0008           ; 
 0008           ; #include <math.h>
 0008           ; #include <string.h>
 0008           ; 
 0008           ; /* 兼容一般程序员的常用写法 */
 0008           ; typedef unsigned char uchar;
 0008           ; typedef unsigned int  uint;
 0008           ; typedef unsigned long ulong;
 0008           ; typedef signed char           schar;
 0008           ; typedef signed int            sint;
 0008           ; typedef signed long           slong;
 0008           ; 
 0008           ; /* 为方便移植，建议使用下面写法 */
 0008           ; typedef unsigned char bool;
 0008           ; typedef unsigned char uint8;
 0008           ; typedef unsigned int  uint16;
 0008           ; typedef unsigned long   uint32;
 0008           ; typedef signed  char  sint8;
 0008           ; typedef signed        int             sint16;
 0008           ; typedef signed        long    sint32;
 0008           ; typedef signed  char  int8;
 0008           ; typedef signed  int           int16;
 0008           ; typedef signed  long  int32;
 0008           ; 
 0008           ; /* 下面写法一般不推荐 */
 0008           ; //typedef unsigned char ubyte;
 0008           ; //typedef unsigned int        uword;
 0008           ; //typedef unsigned long udword;
 0008           ; //typedef signed   char       sbyte;
 0008           ; //typedef signed   int        sword;
 0008           ; //typedef signed   long       sdword;
 0008           ; 
 0008           ; /* 一般程序定义的默认值 */
 0008           ; //#define NULL                        0
 0008           ; //#define EOF                 -1
 0008           ; //#define TRUE                1
 0008           ; //#define FALSE               0
 0008           ; //#define YES                 1
 0008           ; //#define NO                          0
 0008           ; //#define ON                  1
 0008           ; //#define OFF                 0
 0008           ; //#define ENABLE              1
 0008           ; //#define DISABLE             0
 0008           ; //#define CRR                 1
 0008           ; //#define ERR                 0
 0008           ; //#define RIGHT                       1
 0008           ; //#define WRONG                       0
 0008           ; //#define SUCCESS             1
 0008           ; //#define FAILURE             0
 0008           ; //#define PI                  3.1415926       //3.1415926535897932
 0008           ; 
 0008           ; /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
 0008           ; //#define _CALLOC(a)          ( (a *)calloc(n,sizeof(a)) )
 0008           ; //#define _MALLOC(a)          ( (a *)malloc(sizeof(a)) )
 0008           ; //#define _MIN(a,b)                   ( (a) < (b) ? (a) : (b) )
 0008           ; //#define _MAX(a,b)                   ( (a) > (b) ? (a) : (b) )
 0008           ; //#define _EXCHANGE(a,b)      { int t; t=a; a=b; b=t; }
 0008           ; //#define _TOLOWER(c)         ( (c)+32 )
 0008           ; //#define _TOUPPER(c)         ( (c)-32 )
 0008           ; 
 0008           ; //#ifndef BIT
 0008           ; //#define BIT(x)      ( 1<<(x) )
 0008           ; //#endif
 0008           ; 
 0008           ; /*--------------------------------------------------------------------
 0008           ; 函数全称：数据拆字
 0008           ; 函数功能：
 0008           ; 注意事项：D<=999999,C<=6
 0008           ; 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
 0008           ; 输    入：
 0008           ; 返    回：无
 0008           ; --------------------------------------------------------------------*/
 0008           ; uint8 dataElem[6];
 0008           ; void speaData(uint32 dat,sint8 len)
 0008           ; {
 0008                   .dbline 119
 0008           ;     uint8 i;
 0008           ;     uint32 j,y;
 0008           ;     for(i=0,j=1;i<len;i++)
 0008 AA24              clr R10
 000A 81E0              ldi R24,1
 000C 8883              std y+0,R24
 000E 80E0              ldi R24,0
 0010 8983              std y+1,R24
 0012 8A83              std y+2,R24
 0014 8B83              std y+3,R24
 0016 39C0              rjmp L5
 0018           L2:
 0018                   .dbline 120
 0018           ;     {
 0018                   .dbline 121
 0018           ;         y=dat/j;
 0018 2880              ldd R2,y+0
 001A 3980              ldd R3,y+1
 001C 4A80              ldd R4,y+2
 001E 5B80              ldd R5,y+3
 0020 0889              ldd R16,y+16
 0022 1989              ldd R17,y+17
 0024 2A89              ldd R18,y+18
 0026 3B89              ldd R19,y+19
 0028 5A92              st -y,R5
 002A 4A92              st -y,R4
 002C 3A92              st -y,R3
 002E 2A92              st -y,R2
 0030 00D0              rcall div32u
 0032 0C83              std y+4,R16
 0034 1D83              std y+5,R17
 0036 2E83              std y+6,R18
 0038 3F83              std y+7,R19
 003A                   .dbline 122
 003A           ;         dataElem[i]=y%10;
 003A 4AE0              ldi R20,10
 003C 50E0              ldi R21,0
 003E 60E0              ldi R22,0
 0040 70E0              ldi R23,0
 0042 0C81              ldd R16,y+4
 0044 1D81              ldd R17,y+5
 0046 2E81              ldd R18,y+6
 0048 3F81              ldd R19,y+7
 004A 7A93              st -y,R23
 004C 6A93              st -y,R22
 004E 5A93              st -y,R21
 0050 4A93              st -y,R20
 0052 00D0              rcall mod32u
 0054 80E0              ldi R24,<_dataElem
 0056 90E0              ldi R25,>_dataElem
 0058 EA2D              mov R30,R10
 005A FF27              clr R31
 005C E80F              add R30,R24
 005E F91F              adc R31,R25
 0060 0083              std z+0,R16
 0062                   .dbline 123
 0062           ;         j*=10;
 0062 2880              ldd R2,y+0
 0064 3980              ldd R3,y+1
 0066 4A80              ldd R4,y+2
 0068 5B80              ldd R5,y+3
 006A 4AE0              ldi R20,10
 006C 50E0              ldi R21,0
 006E 60E0              ldi R22,0
 0070 70E0              ldi R23,0
 0072 5A92              st -y,R5
 0074 4A92              st -y,R4
 0076 3A92              st -y,R3
 0078 2A92              st -y,R2
 007A 8A01              movw R16,R20
 007C 9B01              movw R18,R22
 007E 00D0              rcall empy32u
 0080 0883              std y+0,R16
 0082 1983              std y+1,R17
 0084 2A83              std y+2,R18
 0086 3B83              std y+3,R19
 0088                   .dbline 124
 0088           ;     }
 0088           L3:
 0088                   .dbline 119
 0088 A394              inc R10
 008A           L5:
 008A                   .dbline 119
 008A 2C2C              mov R2,R12
 008C 3324              clr R3
 008E 27FC              sbrc R2,7
 0090 3094              com R3
 0092 4A2C              mov R4,R10
 0094 5524              clr R5
 0096 4214              cp R4,R2
 0098 5304              cpc R5,R3
 009A 0CF4              brge X1
 009C BDCF              rjmp L2
 009E           X1:
 009E           X0:
 009E                   .dbline -2
 009E           L1:
 009E                   .dbline 0 ; func end
 009E 2896              adiw R28,8
 00A0 00D0              rcall pop_xgsetF03C
 00A2 2496              adiw R28,4
 00A4 0895              ret
 00A6                   .dbsym l y 4 l
 00A6                   .dbsym l j 0 l
 00A6                   .dbsym r i 10 c
 00A6                   .dbsym r len 12 C
 00A6                   .dbsym l dat 16 l
 00A6                   .dbend
 00A6                   .dbfile D:\ICC_H\I2C.H
 00A6                   .dbfunc e I2C_Start _I2C_Start fc
                        .even
 00A6           _I2C_Start::
 00A6                   .dbline -1
 00A6                   .dbline 126
 00A6           ; /*********************************************************************
 00A6           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 00A6           ;                                                                       
 00A6           ; 目    的:   建立I2C操作库
 00A6           ;       
 00A6           ; 目标系统:   基于AVR单片机
 00A6           ;                                                                               
 00A6           ; 应用软件:   ICCAVR
 00A6           ;                                                                               
 00A6           ; 版    本:   Version 1.0                                                          
 00A6           ;                                                                               
 00A6           ; 圆版时间:   2005-06-25
 00A6           ;       
 00A6           ; 开发人员:   SEE
 00A6           ; 
 00A6           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 00A6           ;       
 00A6           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 00A6           ; *********************************************************************/
 00A6           ; 
 00A6           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 版本更新记录：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 入口参数说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 待定参数说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------        
 00A6           ; 对外变量说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 对外函数说明：
 00A6           ; 
 00A6           ; ----------------------------------------------------------------------
 00A6           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 00A6           ; 
 00A6           ; #ifndef I2C_H
 00A6           ; #define I2C_H
 00A6           ; 
 00A6           ; /* TWSR values (not bits) */
 00A6           ; /* Master */
 00A6           ; #define I2C_START                     0x08
 00A6           ; #define I2C_RESTART                   0x10
 00A6           ; 
 00A6           ; /* Master Transmitter */
 00A6           ; #define I2C_MT_SLA_ACK                0x18
 00A6           ; #define I2C_MT_SLA_NACK               0x20
 00A6           ; #define I2C_MT_DATA_ACK               0x28
 00A6           ; #define I2C_MT_DATA_NACK      0x30
 00A6           ; #define I2C_MT_ARB_LOST               0x38
 00A6           ; 
 00A6           ; /* Master Receiver */
 00A6           ; #define I2C_MR_ARB_LOST               0x38
 00A6           ; #define I2C_MR_SLA_ACK                0x40
 00A6           ; #define I2C_MR_SLA_NACK               0x48
 00A6           ; #define I2C_MR_DATA_ACK               0x50
 00A6           ; #define I2C_MR_DATA_NACK      0x58
 00A6           ; 
 00A6           ; /* Slave Transmitter */
 00A6           ; #define I2C_ST_SLA_ACK                        0xA8
 00A6           ; #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
 00A6           ; #define I2C_ST_DATA_ACK                       0xB8
 00A6           ; #define I2C_ST_DATA_NACK              0xC0
 00A6           ; #define I2C_ST_LAST_DATA              0xC8
 00A6           ; 
 00A6           ; /* Slave Receiver */
 00A6           ; #define I2C_SR_SLA_ACK                                0x60
 00A6           ; #define I2C_SR_ARB_LOST_SLA_ACK               0x68
 00A6           ; #define I2C_SR_GCALL_ACK                      0x70
 00A6           ; #define I2C_SR_ARB_LOST_GCALL_ACK     0x78
 00A6           ; #define I2C_SR_DATA_ACK                               0x80
 00A6           ; #define I2C_SR_DATA_NACK                      0x88
 00A6           ; #define I2C_SR_GCALL_DATA_ACK         0x90
 00A6           ; #define I2C_SR_GCALL_DATA_NACK                0x98
 00A6           ; #define I2C_SR_STOP                                   0xA0
 00A6           ; 
 00A6           ; /* Misc */
 00A6           ; #define I2C_NO_INFO                   0xF8
 00A6           ; #define I2C_BUS_ERROR         0x00
 00A6           ; 
 00A6           ; /*
 00A6           ;  * The lower 3 bits of TWSR are reserved on the ATmega163.
 00A6           ;  * The 2 LSB carry the prescaler bits on the newer ATmegas.
 00A6           ;  */
 00A6           ; #define I2C_STATUS_MASK       (_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
 00A6           ; #define I2C_STATUS            (TWSR & I2C_STATUS_MASK)
 00A6           ; 
 00A6           ; /*
 00A6           ;  * R/~W bit in SLA+R/W address field.
 00A6           ;  */
 00A6           ; #define I2C_READ              1
 00A6           ; #define I2C_WRITE             0
 00A6           ; 
 00A6           ; #define I2CStart()            (TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
 00A6           ; #define I2CStop()             (TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
 00A6           ; #define I2CWaitAck()  {while(!(TWCR&(1<<TWINT)));}
 00A6           ; #define I2CChkAck()   (TWSR&0xf8)                                     //check ack
 00A6           ; #define I2CSendAck()  (TWCR|=(1<<TWEA))
 00A6           ; #define I2CSendNoAck()        (TWCR&=~(1<<TWEA))
 00A6           ; #define I2CSendByte(x)        {TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
 00A6           ; #define I2CRcvNckByte()       (TWCR=(1<<TWINT)|(1<<TWEN))
 00A6           ; #define I2CRcvAckByte()       (TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
 00A6           ; 
 00A6           ; /* For Program */
 00A6           ; #define I2C_Stop()            I2CStop()
 00A6           ; #define I2C_SendAck() I2CSendAck()
 00A6           ; #define I2C_SendNoAck() I2CSendNoAck()
 00A6           ; #define I2C_WaitAck() I2CWaitAck()
 00A6           ; 
 00A6           ; /* I2C Config */
 00A6           ; #define I2C_ERR                       0
 00A6           ; #define I2C_CRR                       1
 00A6           ; 
 00A6           ; /*--------------------------------------------------------------------
 00A6           ; 函数名称：I2C Start
 00A6           ; 函数功能：
 00A6           ; 注意事项：
 00A6           ; 提示说明：
 00A6           ; 输    入：
 00A6           ; 返    回：
 00A6           ; --------------------------------------------------------------------*/
 00A6           ; bool I2C_Start()                                      
 00A6           ; {
 00A6                   .dbline 127
 00A6           ;       I2CStart();                                             
 00A6 84EA              ldi R24,164
 00A8 86BF              out 0x36,R24
 00AA                   .dbline 128
 00AA           ;       I2CWaitAck();
 00AA           L7:
 00AA                   .dbline 128
 00AA           L8:
 00AA                   .dbline 128
 00AA 26B6              in R2,0x36
 00AC 27FE              sbrs R2,7
 00AE FDCF              rjmp L7
 00B0           X2:
 00B0                   .dbline 128
 00B0                   .dbline 128
 00B0                   .dbline 129
 00B0           ;       if( I2CChkAck()!=I2C_START ) 
 00B0 81B1              in R24,0x1
 00B2 887F              andi R24,248
 00B4 8830              cpi R24,8
 00B6 11F0              breq L10
 00B8           X3:
 00B8                   .dbline 130
 00B8           ;               return I2C_ERR;
 00B8 0027              clr R16
 00BA 01C0              rjmp L6
 00BC           L10:
 00BC                   .dbline 131
 00BC           ;       return I2C_CRR;
 00BC 01E0              ldi R16,1
 00BE                   .dbline -2
 00BE           L6:
 00BE                   .dbline 0 ; func end
 00BE 0895              ret
 00C0                   .dbend
 00C0                   .dbfunc e I2C_Restart _I2C_Restart fc
                        .even
 00C0           _I2C_Restart::
 00C0                   .dbline -1
 00C0                   .dbline 142
 00C0           ; }
 00C0           ; /*--------------------------------------------------------------------
 00C0           ; 函数名称：I2C ReStart
 00C0           ; 函数功能：
 00C0           ; 注意事项：
 00C0           ; 提示说明：
 00C0           ; 输    入：
 00C0           ; 返    回：
 00C0           ; --------------------------------------------------------------------*/
 00C0           ; bool I2C_Restart()                                    
 00C0           ; {
 00C0                   .dbline 143
 00C0           ;       I2CStart();                                             
 00C0 84EA              ldi R24,164
 00C2 86BF              out 0x36,R24
 00C4                   .dbline 144
 00C4           ;       I2CWaitAck();
 00C4           L13:
 00C4                   .dbline 144
 00C4           L14:
 00C4                   .dbline 144
 00C4 26B6              in R2,0x36
 00C6 27FE              sbrs R2,7
 00C8 FDCF              rjmp L13
 00CA           X4:
 00CA                   .dbline 144
 00CA                   .dbline 144
 00CA                   .dbline 145
 00CA           ;       if( I2CChkAck()!=I2C_RESTART ) 
 00CA 81B1              in R24,0x1
 00CC 887F              andi R24,248
 00CE 8031              cpi R24,16
 00D0 11F0              breq L16
 00D2           X5:
 00D2                   .dbline 146
 00D2           ;               return I2C_ERR;
 00D2 0027              clr R16
 00D4 01C0              rjmp L12
 00D6           L16:
 00D6                   .dbline 147
 00D6           ;       return I2C_CRR;
 00D6 01E0              ldi R16,1
 00D8                   .dbline -2
 00D8           L12:
 00D8                   .dbline 0 ; func end
 00D8 0895              ret
 00DA                   .dbend
 00DA                   .dbfunc e I2C_SendWrDAdr _I2C_SendWrDAdr fc
 00DA           ;         wrDAdr -> R16
                        .even
 00DA           _I2C_SendWrDAdr::
 00DA                   .dbline -1
 00DA                   .dbline 158
 00DA           ; }
 00DA           ; /*--------------------------------------------------------------------
 00DA           ; 函数名称：发送 7位 器件写地址: XXXX XXX0
 00DA           ; 函数功能：
 00DA           ; 注意事项：
 00DA           ; 提示说明：
 00DA           ; 输    入：
 00DA           ; 返    回：
 00DA           ; --------------------------------------------------------------------*/
 00DA           ; bool I2C_SendWrDAdr(uint8 wrDAdr)     
 00DA           ; {
 00DA                   .dbline 159
 00DA           ;       I2CSendByte(wrDAdr);                    //设置 器件写地址
 00DA                   .dbline 159
 00DA 03B9              out 0x3,R16
 00DC                   .dbline 159
 00DC 84E8              ldi R24,132
 00DE 86BF              out 0x36,R24
 00E0                   .dbline 159
 00E0                   .dbline 159
 00E0                   .dbline 160
 00E0           ;       I2CWaitAck();
 00E0           L19:
 00E0                   .dbline 160
 00E0           L20:
 00E0                   .dbline 160
 00E0 26B6              in R2,0x36
 00E2 27FE              sbrs R2,7
 00E4 FDCF              rjmp L19
 00E6           X6:
 00E6                   .dbline 160
 00E6                   .dbline 160
 00E6                   .dbline 161
 00E6           ;       if( I2CChkAck()!=I2C_MT_SLA_ACK )  
 00E6 81B1              in R24,0x1
 00E8 887F              andi R24,248
 00EA 8831              cpi R24,24
 00EC 11F0              breq L22
 00EE           X7:
 00EE                   .dbline 162
 00EE           ;               return I2C_ERR;
 00EE 0027              clr R16
 00F0 01C0              rjmp L18
 00F2           L22:
 00F2                   .dbline 163
 00F2           ;       return I2C_CRR;         
 00F2 01E0              ldi R16,1
 00F4                   .dbline -2
 00F4           L18:
 00F4                   .dbline 0 ; func end
 00F4 0895              ret
 00F6                   .dbsym r wrDAdr 16 c
 00F6                   .dbend
 00F6                   .dbfunc e I2C_SendWrDAdr_ _I2C_SendWrDAdr_ fc
 00F6           ;         wrDAdr -> R10,R11
                        .even
 00F6           _I2C_SendWrDAdr_::
 00F6 AA92              st -y,R10
 00F8 BA92              st -y,R11
 00FA 5801              movw R10,R16
 00FC                   .dbline -1
 00FC                   .dbline 174
 00FC           ; }
 00FC           ; /*--------------------------------------------------------------------
 00FC           ; 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
 00FC           ; 函数功能：
 00FC           ; 注意事项：
 00FC           ; 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
 00FC           ; 输    入：
 00FC           ; 返    回：
 00FC           ; --------------------------------------------------------------------*/
 00FC           ; bool I2C_SendWrDAdr_(uint16 wrDAdr)   
 00FC           ; {
 00FC                   .dbline 175
 00FC           ;       if( wrDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 00FC A0FE              sbrs R10,0
 00FE 0EC0              rjmp L25
 0100           X8:
 0100                   .dbline 176
 0100           ;               if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )       //设置 （高位）器件写地址
 0100 0A2D              mov R16,R10
 0102 0695              lsr R16
 0104 0695              lsr R16
 0106 0695              lsr R16
 0108 0695              lsr R16
 010A 0695              lsr R16
 010C 0695              lsr R16
 010E 0695              lsr R16
 0110 0695              lsr R16
 0112 E3DF              rcall _I2C_SendWrDAdr
 0114 0023              tst R16
 0116 11F4              brne L27
 0118           X9:
 0118                   .dbline 177
 0118           ;                       return I2C_ERR;
 0118 0027              clr R16
 011A 07C0              rjmp L24
 011C           L27:
 011C           L25:
 011C                   .dbline 178
 011C           ;       if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )  //设置 （低位）器件写地址
 011C 0A2D              mov R16,R10
 011E DDDF              rcall _I2C_SendWrDAdr
 0120 0023              tst R16
 0122 11F4              brne L29
 0124           X10:
 0124                   .dbline 179
 0124           ;               return I2C_ERR;
 0124 0027              clr R16
 0126 01C0              rjmp L24
 0128           L29:
 0128                   .dbline 180
 0128           ;       return I2C_CRR;
 0128 01E0              ldi R16,1
 012A                   .dbline -2
 012A           L24:
 012A                   .dbline 0 ; func end
 012A B990              ld R11,y+
 012C A990              ld R10,y+
 012E 0895              ret
 0130                   .dbsym r wrDAdr 10 i
 0130                   .dbend
 0130                   .dbfunc e I2C_SendRdDAdr _I2C_SendRdDAdr fc
 0130           ;         rdDAdr -> R16
                        .even
 0130           _I2C_SendRdDAdr::
 0130                   .dbline -1
 0130                   .dbline 191
 0130           ; }
 0130           ; /*--------------------------------------------------------------------
 0130           ; 函数名称：发送 7位 器件读地址: XXXX XXX1
 0130           ; 函数功能：
 0130           ; 注意事项：
 0130           ; 提示说明：
 0130           ; 输    入：
 0130           ; 返    回：
 0130           ; --------------------------------------------------------------------*/
 0130           ; bool I2C_SendRdDAdr(uint8 rdDAdr)     
 0130           ; {
 0130                   .dbline 192
 0130           ;       I2CSendByte(rdDAdr);                    //设置 器件读地址
 0130                   .dbline 192
 0130 03B9              out 0x3,R16
 0132                   .dbline 192
 0132 84E8              ldi R24,132
 0134 86BF              out 0x36,R24
 0136                   .dbline 192
 0136                   .dbline 192
 0136                   .dbline 193
 0136           ;       I2CWaitAck();
 0136           L32:
 0136                   .dbline 193
 0136           L33:
 0136                   .dbline 193
 0136 26B6              in R2,0x36
 0138 27FE              sbrs R2,7
 013A FDCF              rjmp L32
 013C           X11:
 013C                   .dbline 193
 013C                   .dbline 193
 013C                   .dbline 194
 013C           ;       if( I2CChkAck()!=I2C_MR_SLA_ACK )  
 013C 81B1              in R24,0x1
 013E 887F              andi R24,248
 0140 8034              cpi R24,64
 0142 11F0              breq L35
 0144           X12:
 0144                   .dbline 195
 0144           ;               return I2C_ERR;
 0144 0027              clr R16
 0146 01C0              rjmp L31
 0148           L35:
 0148                   .dbline 196
 0148           ;       return I2C_CRR; 
 0148 01E0              ldi R16,1
 014A                   .dbline -2
 014A           L31:
 014A                   .dbline 0 ; func end
 014A 0895              ret
 014C                   .dbsym r rdDAdr 16 c
 014C                   .dbend
 014C                   .dbfunc e I2C_SendRdDAdr_ _I2C_SendRdDAdr_ fc
 014C           ;         rdDAdr -> R10
                        .even
 014C           _I2C_SendRdDAdr_::
 014C AA92              st -y,R10
 014E A02E              mov R10,R16
 0150                   .dbline -1
 0150                   .dbline 207
 0150           ; }
 0150           ; /*--------------------------------------------------------------------
 0150           ; 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
 0150           ; 函数功能：
 0150           ; 注意事项：
 0150           ; 提示说明：
 0150           ; 输    入：
 0150           ; 返    回：
 0150           ; --------------------------------------------------------------------*/
 0150           ; bool I2C_SendRdDAdr_(uint8 rdDAdr)    
 0150           ; {
 0150                   .dbline 208
 0150           ;       if( rdDAdr&0xF000 == 0xF000 )   //判断是否为 10位 器件地址
 0150 A0FE              sbrs R10,0
 0152 0EC0              rjmp L38
 0154           X13:
 0154                   .dbline 209
 0154           ;               if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )       //设置 （高位）器件读地址
 0154 0A2D              mov R16,R10
 0156 0695              lsr R16
 0158 0695              lsr R16
 015A 0695              lsr R16
 015C 0695              lsr R16
 015E 0695              lsr R16
 0160 0695              lsr R16
 0162 0695              lsr R16
 0164 0695              lsr R16
 0166 B9DF              rcall _I2C_SendWrDAdr
 0168 0023              tst R16
 016A 11F4              brne L40
 016C           X14:
 016C                   .dbline 210
 016C           ;                       return I2C_ERR;
 016C 0027              clr R16
 016E 07C0              rjmp L37
 0170           L40:
 0170           L38:
 0170                   .dbline 211
 0170           ;       if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )  //设置 （低位）器件读地址
 0170 0A2D              mov R16,R10
 0172 B3DF              rcall _I2C_SendWrDAdr
 0174 0023              tst R16
 0176 11F4              brne L42
 0178           X15:
 0178                   .dbline 212
 0178           ;               return I2C_ERR;
 0178 0027              clr R16
 017A 01C0              rjmp L37
 017C           L42:
 017C                   .dbline 213
 017C           ;       return I2C_CRR;
 017C 01E0              ldi R16,1
 017E                   .dbline -2
 017E           L37:
 017E                   .dbline 0 ; func end
 017E A990              ld R10,y+
 0180 0895              ret
 0182                   .dbsym r rdDAdr 10 c
 0182                   .dbend
 0182                   .dbfunc e I2C_SendDat _I2C_SendDat fc
 0182           ;      configDat -> R16
                        .even
 0182           _I2C_SendDat::
 0182                   .dbline -1
 0182                   .dbline 224
 0182           ; }
 0182           ; /*--------------------------------------------------------------------
 0182           ; 函数名称：I2C发送数据
 0182           ; 函数功能：
 0182           ; 注意事项：
 0182           ; 提示说明：
 0182           ; 输    入：
 0182           ; 返    回：
 0182           ; --------------------------------------------------------------------*/
 0182           ; bool I2C_SendDat(uint8 configDat)     
 0182           ; {
 0182                   .dbline 225
 0182           ;       I2CSendByte(configDat);                 
 0182                   .dbline 225
 0182 03B9              out 0x3,R16
 0184                   .dbline 225
 0184 84E8              ldi R24,132
 0186 86BF              out 0x36,R24
 0188                   .dbline 225
 0188                   .dbline 225
 0188                   .dbline 226
 0188           ;       I2CWaitAck();
 0188           L45:
 0188                   .dbline 226
 0188           L46:
 0188                   .dbline 226
 0188 26B6              in R2,0x36
 018A 27FE              sbrs R2,7
 018C FDCF              rjmp L45
 018E           X16:
 018E                   .dbline 226
 018E                   .dbline 226
 018E                   .dbline 227
 018E           ;       if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
 018E 81B1              in R24,0x1
 0190 887F              andi R24,248
 0192 8832              cpi R24,40
 0194 11F0              breq L48
 0196           X17:
 0196                   .dbline 228
 0196           ;               return I2C_ERR;
 0196 0027              clr R16
 0198 01C0              rjmp L44
 019A           L48:
 019A                   .dbline 229
 019A           ;       return I2C_CRR; 
 019A 01E0              ldi R16,1
 019C                   .dbline -2
 019C           L44:
 019C                   .dbline 0 ; func end
 019C 0895              ret
 019E                   .dbsym r configDat 16 c
 019E                   .dbend
 019E                   .dbfunc e I2C_RcvNAckDat _I2C_RcvNAckDat fc
 019E           ;         pRdDat -> R16,R17
                        .even
 019E           _I2C_RcvNAckDat::
 019E                   .dbline -1
 019E                   .dbline 240
 019E           ; }
 019E           ; /*--------------------------------------------------------------------
 019E           ; 函数名称：I2C接收数据且不产生应答
 019E           ; 函数功能：
 019E           ; 注意事项：
 019E           ; 提示说明：
 019E           ; 输    入：
 019E           ; 返    回：
 019E           ; --------------------------------------------------------------------*/
 019E           ; bool I2C_RcvNAckDat(uint8 *pRdDat)    
 019E           ; {
 019E                   .dbline 241
 019E           ;       I2CRcvNckByte();
 019E 84E8              ldi R24,132
 01A0 86BF              out 0x36,R24
 01A2                   .dbline 242
 01A2           ;       I2CWaitAck();
 01A2           L51:
 01A2                   .dbline 242
 01A2           L52:
 01A2                   .dbline 242
 01A2 26B6              in R2,0x36
 01A4 27FE              sbrs R2,7
 01A6 FDCF              rjmp L51
 01A8           X18:
 01A8                   .dbline 242
 01A8                   .dbline 242
 01A8                   .dbline 243
 01A8           ;       if( I2CChkAck()!=I2C_MR_DATA_NACK )
 01A8 81B1              in R24,0x1
 01AA 887F              andi R24,248
 01AC 8835              cpi R24,88
 01AE 11F0              breq L54
 01B0           X19:
 01B0                   .dbline 244
 01B0           ;               return I2C_ERR;
 01B0 0027              clr R16
 01B2 04C0              rjmp L50
 01B4           L54:
 01B4                   .dbline 245
 01B4           ;       *pRdDat=TWDR;
 01B4 23B0              in R2,0x3
 01B6 F801              movw R30,R16
 01B8 2082              std z+0,R2
 01BA                   .dbline 246
 01BA           ;       return I2C_CRR;
 01BA 01E0              ldi R16,1
 01BC                   .dbline -2
 01BC           L50:
 01BC                   .dbline 0 ; func end
 01BC 0895              ret
 01BE                   .dbsym r pRdDat 16 pc
 01BE                   .dbend
 01BE                   .dbfunc e I2C_RcvAckDat _I2C_RcvAckDat fc
 01BE           ;         pRdDat -> R16,R17
                        .even
 01BE           _I2C_RcvAckDat::
 01BE                   .dbline -1
 01BE                   .dbline 257
 01BE           ; }
 01BE           ; /*--------------------------------------------------------------------
 01BE           ; 函数名称：I2C接收数据且产生应答
 01BE           ; 函数功能：
 01BE           ; 注意事项：
 01BE           ; 提示说明：
 01BE           ; 输    入：
 01BE           ; 返    回：
 01BE           ; --------------------------------------------------------------------*/
 01BE           ; bool I2C_RcvAckDat(uint8 *pRdDat)     
 01BE           ; {
 01BE                   .dbline 258
 01BE           ;       I2CRcvAckByte();                                        
 01BE 84EC              ldi R24,196
 01C0 86BF              out 0x36,R24
 01C2                   .dbline 259
 01C2           ;       I2CWaitAck();
 01C2           L57:
 01C2                   .dbline 259
 01C2           L58:
 01C2                   .dbline 259
 01C2 26B6              in R2,0x36
 01C4 27FE              sbrs R2,7
 01C6 FDCF              rjmp L57
 01C8           X20:
 01C8                   .dbline 259
 01C8                   .dbline 259
 01C8                   .dbline 260
 01C8           ;       if( I2CChkAck()!=I2C_MR_DATA_ACK )
 01C8 81B1              in R24,0x1
 01CA 887F              andi R24,248
 01CC 8035              cpi R24,80
 01CE 11F0              breq L60
 01D0           X21:
 01D0                   .dbline 261
 01D0           ;               return I2C_ERR;
 01D0 0027              clr R16
 01D2 04C0              rjmp L56
 01D4           L60:
 01D4                   .dbline 262
 01D4           ;       *pRdDat=TWDR;
 01D4 23B0              in R2,0x3
 01D6 F801              movw R30,R16
 01D8 2082              std z+0,R2
 01DA                   .dbline 263
 01DA           ;       return I2C_CRR;
 01DA 01E0              ldi R16,1
 01DC                   .dbline -2
 01DC           L56:
 01DC                   .dbline 0 ; func end
 01DC 0895              ret
 01DE                   .dbsym r pRdDat 16 pc
 01DE                   .dbend
 01DE                   .dbfunc e I2C_Write _I2C_Write fc
 01DE           ;            dat -> R10
 01DE           ;        wordAdr -> R12
 01DE           ;         wrDAdr -> R14,R15
                        .even
 01DE           _I2C_Write::
 01DE 00D0              rcall push_xgset00FC
 01E0 C22E              mov R12,R18
 01E2 7801              movw R14,R16
 01E4 AE80              ldd R10,y+6
 01E6                   .dbline -1
 01E6                   .dbline 276
 01E6           ; }
 01E6           ; /*--------------------------------------------------------------------
 01E6           ; 函数名称：I2C写器件，写一个数据
 01E6           ; 函数功能：
 01E6           ; 注意事项：
 01E6           ; 提示说明：
 01E6           ; 输    入：wrDAdr: write device-address 写器件地址
 01E6           ;                wordAdr: word address 字地址
 01E6           ;                dat: data 数据
 01E6           ; 返    回：
 01E6           ; --------------------------------------------------------------------*/
 01E6           ; bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
 01E6           ; {
 01E6                   .dbline 277
 01E6           ;       if( I2C_Start()==I2C_ERR )
 01E6 5FDF              rcall _I2C_Start
 01E8 0023              tst R16
 01EA 11F4              brne L63
 01EC           X22:
 01EC                   .dbline 278
 01EC           ;               return I2C_ERR;
 01EC 0027              clr R16
 01EE 17C0              rjmp L62
 01F0           L63:
 01F0                   .dbline 280
 01F0           ; 
 01F0           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 01F0 8701              movw R16,R14
 01F2 81DF              rcall _I2C_SendWrDAdr_
 01F4 0023              tst R16
 01F6 11F4              brne L65
 01F8           X23:
 01F8                   .dbline 281
 01F8           ;               return I2C_ERR;
 01F8 0027              clr R16
 01FA 11C0              rjmp L62
 01FC           L65:
 01FC                   .dbline 283
 01FC           ; 
 01FC           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 01FC 0C2D              mov R16,R12
 01FE C1DF              rcall _I2C_SendDat
 0200 C02E              mov R12,R16
 0202 0023              tst R16
 0204 11F4              brne L67
 0206           X24:
 0206                   .dbline 284
 0206           ;               return I2C_ERR;
 0206 0027              clr R16
 0208 0AC0              rjmp L62
 020A           L67:
 020A                   .dbline 286
 020A           ; 
 020A           ;       if( I2C_SendDat(dat)==I2C_ERR )
 020A 0A2D              mov R16,R10
 020C BADF              rcall _I2C_SendDat
 020E A02E              mov R10,R16
 0210 0023              tst R16
 0212 11F4              brne L69
 0214           X25:
 0214                   .dbline 287
 0214           ;               return I2C_ERR;
 0214 0027              clr R16
 0216 03C0              rjmp L62
 0218           L69:
 0218                   .dbline 289
 0218           ; 
 0218           ;       I2C_Stop();
 0218 84E9              ldi R24,148
 021A 86BF              out 0x36,R24
 021C                   .dbline 291
 021C           ; 
 021C           ;       return I2C_CRR;
 021C 01E0              ldi R16,1
 021E                   .dbline -2
 021E           L62:
 021E                   .dbline 0 ; func end
 021E 00C0              rjmp pop_xgset00FC
 0220                   .dbsym r dat 10 c
 0220                   .dbsym r wordAdr 12 c
 0220                   .dbsym r wrDAdr 14 i
 0220                   .dbend
 0220                   .dbfunc e I2C_Read _I2C_Read fc
 0220           ;         pRdDat -> R10,R11
 0220           ;         rdDAdr -> R12
 0220           ;        wordAdr -> R14
 0220           ;         wrDAdr -> R20,R21
                        .even
 0220           _I2C_Read::
 0220 00D0              rcall push_xgset30FC
 0222 E22E              mov R14,R18
 0224 A801              movw R20,R16
 0226 C884              ldd R12,y+8
 0228 AA84              ldd R10,y+10
 022A BB84              ldd R11,y+11
 022C                   .dbline -1
 022C                   .dbline 322
 022C           ; }
 022C           ; /*--------------------------------------------------------------------
 022C           ; 函数名称：I2C写器件，写N个数据
 022C           ; 函数功能：
 022C           ; 注意事项：
 022C           ; 提示说明：
 022C           ; 输    入：wrDAdr: write device-address 写器件地址
 022C           ;                wordAdr: word address 字地址
 022C           ;                *pWrDat: p->write data 写入数据指针
 022C           ;                num: number 写入数据个数
 022C           ; 返    回：
 022C           ; --------------------------------------------------------------------*/
 022C           ; //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
 022C           ; //                              uint8 *pWrDat,uint8 num)
 022C           ; //{
 022C           ; //
 022C           ; //} 
 022C           ; /*--------------------------------------------------------------------
 022C           ; 函数名称：I2C读器件，读一个数据
 022C           ; 函数功能：
 022C           ; 注意事项：
 022C           ; 提示说明：
 022C           ; 输    入：wrDAdr: write device-address 写器件地址
 022C           ;                wordAdr: word address 字地址
 022C           ;                rdDAdr: read device-address 读器件地址
 022C           ;                *pRdDat: p->read data 读取数据指针
 022C           ; 返    回：
 022C           ; --------------------------------------------------------------------*/
 022C           ; bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
 022C           ;                         uint8 rdDAdr,uint8 *pRdDat)
 022C           ; {
 022C                   .dbline 323
 022C           ;       if( I2C_Start()==I2C_ERR )
 022C 3CDF              rcall _I2C_Start
 022E 0023              tst R16
 0230 11F4              brne L72
 0232           X26:
 0232                   .dbline 324
 0232           ;               return I2C_ERR;
 0232 0027              clr R16
 0234 24C0              rjmp L71
 0236           L72:
 0236                   .dbline 326
 0236           ; 
 0236           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 0236 8A01              movw R16,R20
 0238 5EDF              rcall _I2C_SendWrDAdr_
 023A 0023              tst R16
 023C 11F4              brne L74
 023E           X27:
 023E                   .dbline 327
 023E           ;               return I2C_ERR;
 023E 0027              clr R16
 0240 1EC0              rjmp L71
 0242           L74:
 0242                   .dbline 329
 0242           ; 
 0242           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 0242 0E2D              mov R16,R14
 0244 9EDF              rcall _I2C_SendDat
 0246 E02E              mov R14,R16
 0248 0023              tst R16
 024A 11F4              brne L76
 024C           X28:
 024C                   .dbline 330
 024C           ;               return I2C_ERR;
 024C 0027              clr R16
 024E 17C0              rjmp L71
 0250           L76:
 0250                   .dbline 332
 0250           ; 
 0250           ;       if( I2C_Restart()==I2C_ERR )
 0250 37DF              rcall _I2C_Restart
 0252 E02E              mov R14,R16
 0254 0023              tst R16
 0256 11F4              brne L78
 0258           X29:
 0258                   .dbline 333
 0258           ;               return I2C_ERR;
 0258 0027              clr R16
 025A 11C0              rjmp L71
 025C           L78:
 025C                   .dbline 335
 025C           ; 
 025C           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 025C 0C2D              mov R16,R12
 025E 68DF              rcall _I2C_SendRdDAdr
 0260 C02E              mov R12,R16
 0262 0023              tst R16
 0264 11F4              brne L80
 0266           X30:
 0266                   .dbline 336
 0266           ;               return I2C_ERR;
 0266 0027              clr R16
 0268 0AC0              rjmp L71
 026A           L80:
 026A                   .dbline 338
 026A           ; 
 026A           ;       if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
 026A 8501              movw R16,R10
 026C 98DF              rcall _I2C_RcvNAckDat
 026E A02E              mov R10,R16
 0270 0023              tst R16
 0272 11F4              brne L82
 0274           X31:
 0274                   .dbline 339
 0274           ;               return I2C_ERR;
 0274 0027              clr R16
 0276 03C0              rjmp L71
 0278           L82:
 0278                   .dbline 341
 0278           ; 
 0278           ;       I2C_Stop();
 0278 84E9              ldi R24,148
 027A 86BF              out 0x36,R24
 027C                   .dbline 343
 027C           ; 
 027C           ;       return I2C_CRR;
 027C 01E0              ldi R16,1
 027E                   .dbline -2
 027E           L71:
 027E                   .dbline 0 ; func end
 027E 00C0              rjmp pop_xgset30FC
 0280                   .dbsym r pRdDat 10 pc
 0280                   .dbsym r rdDAdr 12 c
 0280                   .dbsym r wordAdr 14 c
 0280                   .dbsym r wrDAdr 20 i
 0280                   .dbend
 0280                   .dbfunc e I2C_Read_ _I2C_Read_ fc
 0280           ;              i -> R12
 0280           ;            num -> R20
 0280           ;         pRdDat -> R10,R11
 0280           ;         rdDAdr -> R12
 0280           ;        wordAdr -> R14
 0280           ;         wrDAdr -> R22,R23
                        .even
 0280           _I2C_Read_::
 0280 00D0              rcall push_xgsetF0FC
 0282 E22E              mov R14,R18
 0284 B801              movw R22,R16
 0286 CA84              ldd R12,y+10
 0288 AC84              ldd R10,y+12
 028A BD84              ldd R11,y+13
 028C 4E85              ldd R20,y+14
 028E                   .dbline -1
 028E                   .dbline 359
 028E           ; }
 028E           ; /*--------------------------------------------------------------------
 028E           ; 函数名称：I2C读器件，读N个数据
 028E           ; 函数功能：
 028E           ; 注意事项：
 028E           ; 提示说明：
 028E           ; 输    入：wrDAdr: write device-address 写器件地址
 028E           ;                wordAdr: word address 字地址
 028E           ;                rdDAdr: read device-address 读器件地址
 028E           ;                *pRdDat: p->read data 读取数据指针
 028E           ;                num: number 读取数据个数
 028E           ; 返    回：
 028E           ; --------------------------------------------------------------------*/
 028E           ; bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
 028E           ;                          uint8 rdDAdr,uint8 *pRdDat,uint8 num)
 028E           ; {
 028E                   .dbline 362
 028E           ;       uint8 i;
 028E           ;       
 028E           ;       if( I2C_Start()==I2C_ERR )
 028E 0BDF              rcall _I2C_Start
 0290 0023              tst R16
 0292 11F4              brne L85
 0294           X32:
 0294                   .dbline 363
 0294           ;               return I2C_ERR;
 0294 0027              clr R16
 0296 38C0              rjmp L84
 0298           L85:
 0298                   .dbline 365
 0298           ; 
 0298           ;       if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
 0298 8B01              movw R16,R22
 029A 2DDF              rcall _I2C_SendWrDAdr_
 029C 0023              tst R16
 029E 11F4              brne L87
 02A0           X33:
 02A0                   .dbline 366
 02A0           ;               return I2C_ERR;
 02A0 0027              clr R16
 02A2 32C0              rjmp L84
 02A4           L87:
 02A4                   .dbline 368
 02A4           ; 
 02A4           ;       if( I2C_SendDat(wordAdr)==I2C_ERR )
 02A4 0E2D              mov R16,R14
 02A6 6DDF              rcall _I2C_SendDat
 02A8 E02E              mov R14,R16
 02AA 0023              tst R16
 02AC 11F4              brne L89
 02AE           X34:
 02AE                   .dbline 369
 02AE           ;               return I2C_ERR;
 02AE 0027              clr R16
 02B0 2BC0              rjmp L84
 02B2           L89:
 02B2                   .dbline 371
 02B2           ; 
 02B2           ;       if( I2C_Restart()==I2C_ERR )
 02B2 06DF              rcall _I2C_Restart
 02B4 E02E              mov R14,R16
 02B6 0023              tst R16
 02B8 11F4              brne L91
 02BA           X35:
 02BA                   .dbline 372
 02BA           ;               return I2C_ERR;
 02BA 0027              clr R16
 02BC 25C0              rjmp L84
 02BE           L91:
 02BE                   .dbline 374
 02BE           ; 
 02BE           ;       if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
 02BE 0C2D              mov R16,R12
 02C0 37DF              rcall _I2C_SendRdDAdr
 02C2 C02E              mov R12,R16
 02C4 0023              tst R16
 02C6 11F4              brne L93
 02C8           X36:
 02C8                   .dbline 375
 02C8           ;               return I2C_ERR;
 02C8 0027              clr R16
 02CA 1EC0              rjmp L84
 02CC           L93:
 02CC                   .dbline 377
 02CC           ; 
 02CC           ;       for(i=0;i<num-1;i++)
 02CC CC24              clr R12
 02CE 0BC0              rjmp L98
 02D0           L95:
 02D0                   .dbline 378
 02D0           ;               if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
 02D0 0C2D              mov R16,R12
 02D2 1127              clr R17
 02D4 0A0D              add R16,R10
 02D6 1B1D              adc R17,R11
 02D8 72DF              rcall _I2C_RcvAckDat
 02DA E02E              mov R14,R16
 02DC 0023              tst R16
 02DE 11F4              brne L99
 02E0           X37:
 02E0                   .dbline 379
 02E0           ;                       return I2C_ERR;
 02E0 0027              clr R16
 02E2 12C0              rjmp L84
 02E4           L99:
 02E4           L96:
 02E4                   .dbline 377
 02E4 C394              inc R12
 02E6           L98:
 02E6                   .dbline 377
 02E6 842F              mov R24,R20
 02E8 8150              subi R24,1
 02EA C816              cp R12,R24
 02EC 88F3              brlo L95
 02EE           X38:
 02EE                   .dbline 381
 02EE           ;       
 02EE           ;       if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
 02EE 0C2D              mov R16,R12
 02F0 1127              clr R17
 02F2 0A0D              add R16,R10
 02F4 1B1D              adc R17,R11
 02F6 53DF              rcall _I2C_RcvNAckDat
 02F8 A02E              mov R10,R16
 02FA 0023              tst R16
 02FC 11F4              brne L101
 02FE           X39:
 02FE                   .dbline 382
 02FE           ;                       return I2C_ERR;
 02FE 0027              clr R16
 0300 03C0              rjmp L84
 0302           L101:
 0302                   .dbline 384
 0302           ; 
 0302           ;       I2C_Stop();
 0302 84E9              ldi R24,148
 0304 86BF              out 0x36,R24
 0306                   .dbline 386
 0306           ;       
 0306           ;       return I2C_CRR;
 0306 01E0              ldi R16,1
 0308                   .dbline -2
 0308           L84:
 0308                   .dbline 0 ; func end
 0308 00C0              rjmp pop_xgsetF0FC
 030A                   .dbsym r i 12 c
 030A                   .dbsym r num 20 c
 030A                   .dbsym r pRdDat 10 pc
 030A                   .dbsym r rdDAdr 12 c
 030A                   .dbsym r wordAdr 14 c
 030A                   .dbsym r wrDAdr 22 i
 030A                   .dbend
 030A                   .dbfile D:\ICC_H\Hardware.H
 030A                   .dbfunc e delay50us _delay50us fV
 030A           ;              j -> R20
 030A           ;              t -> R16,R17
                        .even
 030A           _delay50us::
 030A 4A93              st -y,R20
 030C                   .dbline -1
 030C                   .dbline 105
 030C           ; /*********************************************************************
 030C           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 030C           ;                                                                       
 030C           ; 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
 030C           ;                                       
 030C           ; 目标系统:   基于AVR单片机
 030C           ;                                                                               
 030C           ; 应用软件:   ICCAVR
 030C           ;                                                                               
 030C           ; 版    本:   Version 1.0                                                          
 030C           ;                                                                               
 030C           ; 圆版时间:   2005-06-25
 030C           ;       
 030C           ; 开发人员:   SEE
 030C           ; 
 030C           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 030C           ;       
 030C           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 030C           ; *********************************************************************/
 030C           ; 
 030C           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 030C           ; ----------------------------------------------------------------------
 030C           ; 版本更新记录：
 030C           ; 
 030C           ; ----------------------------------------------------------------------
 030C           ; 入口参数说明：
 030C           ; 
 030C           ; ----------------------------------------------------------------------
 030C           ; 待定参数说明：
 030C           ; 
 030C           ; ----------------------------------------------------------------------        
 030C           ; 对外变量说明：
 030C           ;     
 030C           ; ----------------------------------------------------------------------
 030C           ; 对外函数说明：
 030C           ;    
 030C           ; ----------------------------------------------------------------------
 030C           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 030C           ; 
 030C           ; #ifndef Hardware_H
 030C           ; #define Hardware_H
 030C           ; 
 030C           ; #include <math.h>
 030C           ; #include <string.h>
 030C           ; #include <stdio.h>
 030C           ; #include <macros.h>
 030C           ; #include <eeprom.h>
 030C           ; //#include <wdt.h>
 030C           ; 
 030C           ; /* TWI configs */
 030C           ; //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
 030C           ; #if NO_INCLUDE_I2C_H
 030C           ; ;
 030C           ; #else
 030C           ; #include "D:\ICC_H\I2C.H"     //i2c即AVR的"twi"
 030C           ; #endif
 030C           ; 
 030C           ; /* hard configs */
 030C           ; #ifndef flash
 030C           ;       #define flash   const
 030C           ; #endif
 030C           ; 
 030C           ; #ifndef code
 030C           ;       #define code    const
 030C           ; #endif
 030C           ; 
 030C           ; #ifndef NOP
 030C           ;       #define NOP()   asm("nop")
 030C           ; #endif
 030C           ; 
 030C           ; /* io configs */
 030C           ; #define sbi(io,bit)           (  io |=  (1<<bit) )    //example: sbi(PORTA,0);sbi(DDRA,0);
 030C           ; #define cbi(io,bit)           (  io &= ~(1<<bit) )    //example: cbi(PORTA,0);cbi(DDRA,0);
 030C           ; #define gbi(pin ,bit) ( pin &   (1<<bit) )    //example: gbi(PINA,0);
 030C           ; 
 030C           ; /* interrupt configs */
 030C           ; #define DIS_INT  asm("sei")
 030C           ; #define EN_INT   asm("cli")
 030C           ; 
 030C           ; /* wdt configs */
 030C           ; #define WDT()    asm("wdr")
 030C           ; 
 030C           ; /* bit operation */
 030C           ; //#ifndef BIT
 030C           ; //#define BIT(x)      ( 1<<(x) )
 030C           ; //#endif
 030C           ; 
 030C           ; /* USART configs for 4 Mhz crystal */
 030C           ; //#define BAUD9600                    25
 030C           ; //#define BAUD19000                   12
 030C           ; //#define UART_TRAN_ON()      UCR |=  0x08
 030C           ; //#define UART_TRAN_OFF()     UCR &= ~0x08
 030C           ; //#define UART_RCV_ON()               UCR |=  0x10
 030C           ; //#define UART_RCV_OFF()      UCR &= ~0x10
 030C           ; 
 030C           ; /*--------------------------------------------------------------------
 030C           ; 函数全称：50us 延时
 030C           ; 函数功能：当然是 50us延时 啦
 030C           ; 注意事项：基于7.3728M晶振，稍微有点误差
 030C           ; 提示说明：调用delay50us（20），得到1ms延时
 030C           ; 输    入：    
 030C           ; 返    回：无 
 030C           ; --------------------------------------------------------------------*/
 030C           ; void delay50us(sint16 t)
 030C           ; {
 030C                   .dbline 107
 030C           ;     uint8 j;          
 030C           ;     for(;t>0;t--)                     
 030C 07C0              rjmp L107
 030E           L104:
 030E                   .dbline 108
 030E           ;         for(j=0;j<70;j++)     
 030E 4427              clr R20
 0310 01C0              rjmp L111
 0312           L108:
 0312                   .dbline 109
 0312           ;             ;
 0312           L109:
 0312                   .dbline 108
 0312 4395              inc R20
 0314           L111:
 0314                   .dbline 108
 0314 4634              cpi R20,70
 0316 E8F3              brlo L108
 0318           X40:
 0318           L105:
 0318                   .dbline 107
 0318 0150              subi R16,1
 031A 1040              sbci R17,0
 031C           L107:
 031C                   .dbline 107
 031C 2224              clr R2
 031E 3324              clr R3
 0320 2016              cp R2,R16
 0322 3106              cpc R3,R17
 0324 A4F3              brlt L104
 0326           X41:
 0326                   .dbline -2
 0326           L103:
 0326                   .dbline 0 ; func end
 0326 4991              ld R20,y+
 0328 0895              ret
 032A                   .dbsym r j 20 c
 032A                   .dbsym r t 16 I
 032A                   .dbend
 032A                   .dbfunc e delay50ms _delay50ms fV
 032A           ;              i -> R20,R21
 032A           ;              t -> R16,R17
                        .even
 032A           _delay50ms::
 032A 4A93              st -y,R20
 032C 5A93              st -y,R21
 032E                   .dbline -1
 032E                   .dbline 120
 032E           ; }
 032E           ; /*--------------------------------------------------------------------
 032E           ; 函数全称：50ms 延时
 032E           ; 函数功能：当然是 50ms延时 啦
 032E           ; 注意事项：基于7.3728M晶振，稍微有点误差
 032E           ; 提示说明：调用delay50ms（20），得到1s延时 
 032E           ; 输    入：
 032E           ; 返    回：无
 032E           ; --------------------------------------------------------------------*/
 032E           ; void delay50ms(sint16 t)
 032E           ; {
 032E                   .dbline 122
 032E           ;       uint16 i; 
 032E           ;       for(;t>0;t--)
 032E 13C0              rjmp L116
 0330           L113:
 0330                   .dbline 123
 0330           ;               for(i=0;i<52642;i++)
 0330 4427              clr R20
 0332 5527              clr R21
 0334 02C0              rjmp L120
 0336           L117:
 0336                   .dbline 124
 0336           ;                       ; 
 0336           L118:
 0336                   .dbline 123
 0336 4F5F              subi R20,255  ; offset = 1
 0338 5F4F              sbci R21,255
 033A           L120:
 033A                   .dbline 123
 033A 82EA              ldi R24,162
 033C 9DEC              ldi R25,205
 033E A0E0              ldi R26,0
 0340 B0E0              ldi R27,0
 0342 1A01              movw R2,R20
 0344 4424              clr R4
 0346 5524              clr R5
 0348 2816              cp R2,R24
 034A 3906              cpc R3,R25
 034C 4A06              cpc R4,R26
 034E 5B06              cpc R5,R27
 0350 94F3              brlt L117
 0352           X42:
 0352           L114:
 0352                   .dbline 122
 0352 0150              subi R16,1
 0354 1040              sbci R17,0
 0356           L116:
 0356                   .dbline 122
 0356 2224              clr R2
 0358 3324              clr R3
 035A 2016              cp R2,R16
 035C 3106              cpc R3,R17
 035E 44F3              brlt L113
 0360           X43:
 0360                   .dbline -2
 0360           L112:
 0360                   .dbline 0 ; func end
 0360 5991              ld R21,y+
 0362 4991              ld R20,y+
 0364 0895              ret
 0366                   .dbsym r i 20 i
 0366                   .dbsym r t 16 I
 0366                   .dbend
 0366                   .dbfunc e delayus _delayus fV
 0366           ;              i -> R20,R21
 0366           ;              t -> R16,R17
                        .even
 0366           _delayus::
 0366 4A93              st -y,R20
 0368 5A93              st -y,R21
 036A                   .dbline -1
 036A                   .dbline 129
 036A           ; }
 036A           ; 
 036A           ; 
 036A           ; void delayus(uint16 t)
 036A           ; {
 036A                   .dbline 131
 036A           ;       uint16 i;
 036A           ;       for(i=0;i<t;i++)
 036A 4427              clr R20
 036C 5527              clr R21
 036E 02C0              rjmp L125
 0370           L122:
 0370                   .dbline 132
 0370           ;               {
 0370                   .dbline 135
 0370           ;                       //asm("NOP\n");
 0370           ;                       //asm("NOP\n");
 0370           ;               }
 0370           L123:
 0370                   .dbline 131
 0370 4F5F              subi R20,255  ; offset = 1
 0372 5F4F              sbci R21,255
 0374           L125:
 0374                   .dbline 131
 0374 4017              cp R20,R16
 0376 5107              cpc R21,R17
 0378 D8F3              brlo L122
 037A           X44:
 037A                   .dbline -2
 037A           L121:
 037A                   .dbline 0 ; func end
 037A 5991              ld R21,y+
 037C 4991              ld R20,y+
 037E 0895              ret
 0380                   .dbsym r i 20 i
 0380                   .dbsym r t 16 i
 0380                   .dbend
 0380                   .dbfile D:\ICC_H\AT45DB161.H
 0380                   .dbfunc e spi_init _spi_init fV
                        .even
 0380           _spi_init::
 0380                   .dbline -1
 0380                   .dbline 24
 0380           ; /*********************************************************************
 0380           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0380           ;                                                                       
 0380           ; 目    的:   建立使用AT45DB161的示例程序
 0380           ;       
 0380           ; 目标系统:   基于AVR单片机
 0380           ;                                                                               
 0380           ; 应用软件:   ICCAVR
 0380           ;                                                                               
 0380           ; 版    本:   Version 1.0                                                          
 0380           ;                                                                               
 0380           ; 圆版时间:   2005-03-1
 0380           ;       
 0380           ; 开发人员:   SEE
 0380           ; 
 0380           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0380           ;       
 0380           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0380           ; *********************************************************************/
 0380           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0380           ; --------------------------------------------------------------------*/                        
 0380           ; //==================================                                  
 0380           ; void spi_init(void)
 0380           ; {
 0380                   .dbline 25
 0380           ;       SPCR=0x5C;    
 0380 8CE5              ldi R24,92
 0382 8DB9              out 0xd,R24
 0384                   .dbline -2
 0384           L126:
 0384                   .dbline 0 ; func end
 0384 0895              ret
 0386                   .dbend
 0386                   .dbfunc e spi_transmit_byte _spi_transmit_byte fV
 0386           ;           Data -> R16
                        .even
 0386           _spi_transmit_byte::
 0386                   .dbline -1
 0386                   .dbline 29
 0386           ; }
 0386           ; //==================================
 0386           ; void spi_transmit_byte(uchar Data)
 0386           ; {     
 0386                   .dbline 30
 0386           ;       SPDR=Data;                                                              
 0386 0FB9              out 0xf,R16
 0388           L128:
 0388                   .dbline 31
 0388           ;     while(!(SPSR&0x80));
 0388           L129:
 0388                   .dbline 31
 0388 779B              sbis 0xe,7
 038A FECF              rjmp L128
 038C           X45:
 038C                   .dbline -2
 038C           L127:
 038C                   .dbline 0 ; func end
 038C 0895              ret
 038E                   .dbsym r Data 16 c
 038E                   .dbend
 038E                   .dbfunc e write_buffer _write_buffer fV
 038E           ;           data -> R10
 038E           ;   BufferOffset -> R12,R13
                        .even
 038E           _write_buffer::
 038E 00D0              rcall push_xgset003C
 0390 A22E              mov R10,R18
 0392 6801              movw R12,R16
 0394                   .dbline -1
 0394                   .dbline 35
 0394           ; }
 0394           ; //============================================================
 0394           ; void write_buffer(uint BufferOffset,uchar data)
 0394           ; {                                     
 0394                   .dbline 36
 0394           ;       spi_transmit_byte(0x84);                                                                        
 0394 04E8              ldi R16,132
 0396 F7DF              rcall _spi_transmit_byte
 0398                   .dbline 37
 0398           ;       spi_transmit_byte(0xff);                                                
 0398 0FEF              ldi R16,255
 039A F5DF              rcall _spi_transmit_byte
 039C                   .dbline 38
 039C           ;       spi_transmit_byte(BufferOffset>>8);     
 039C 8601              movw R16,R12
 039E 012F              mov R16,R17
 03A0 1127              clr R17
 03A2 F1DF              rcall _spi_transmit_byte
 03A4                   .dbline 39
 03A4           ;       spi_transmit_byte(BufferOffset);                
 03A4 0C2D              mov R16,R12
 03A6 EFDF              rcall _spi_transmit_byte
 03A8                   .dbline 40
 03A8           ;       spi_transmit_byte(data);                        
 03A8 0A2D              mov R16,R10
 03AA EDDF              rcall _spi_transmit_byte
 03AC                   .dbline -2
 03AC           L131:
 03AC                   .dbline 0 ; func end
 03AC 00C0              rjmp pop_xgset003C
 03AE                   .dbsym r data 10 c
 03AE                   .dbsym r BufferOffset 12 i
 03AE                   .dbend
 03AE                   .dbfunc e read_buffer _read_buffer fc
 03AE           ;           temp -> R10
 03AE           ;   BufferOffset -> R10,R11
                        .even
 03AE           _read_buffer::
 03AE AA92              st -y,R10
 03B0 BA92              st -y,R11
 03B2 5801              movw R10,R16
 03B4                   .dbline -1
 03B4                   .dbline 44
 03B4           ; }
 03B4           ; //================================================================
 03B4           ; uchar read_buffer(uint BufferOffset)
 03B4           ; {             
 03B4                   .dbline 46
 03B4           ;     uchar temp;               
 03B4           ;       spi_transmit_byte(0x54);                        
 03B4 04E5              ldi R16,84
 03B6 E7DF              rcall _spi_transmit_byte
 03B8                   .dbline 47
 03B8           ;       spi_transmit_byte(0xff);                                                
 03B8 0FEF              ldi R16,255
 03BA E5DF              rcall _spi_transmit_byte
 03BC                   .dbline 48
 03BC           ;       spi_transmit_byte(BufferOffset>>8);     
 03BC 8501              movw R16,R10
 03BE 012F              mov R16,R17
 03C0 1127              clr R17
 03C2 E1DF              rcall _spi_transmit_byte
 03C4                   .dbline 49
 03C4           ;       spi_transmit_byte(BufferOffset);                
 03C4 0A2D              mov R16,R10
 03C6 DFDF              rcall _spi_transmit_byte
 03C8                   .dbline 50
 03C8           ;       spi_transmit_byte(0xff);                                                
 03C8 0FEF              ldi R16,255
 03CA DDDF              rcall _spi_transmit_byte
 03CC                   .dbline 51
 03CC           ;       spi_transmit_byte(0xff);                                        
 03CC 0FEF              ldi R16,255
 03CE DBDF              rcall _spi_transmit_byte
 03D0                   .dbline 52
 03D0           ;       temp=SPDR;        
 03D0 AFB0              in R10,0xf
 03D2                   .dbline 53
 03D2           ;     return temp;                                                              
 03D2 0A2D              mov R16,R10
 03D4                   .dbline -2
 03D4           L132:
 03D4                   .dbline 0 ; func end
 03D4 B990              ld R11,y+
 03D6 A990              ld R10,y+
 03D8 0895              ret
 03DA                   .dbsym r temp 10 c
 03DA                   .dbsym r BufferOffset 10 i
 03DA                   .dbend
 03DA                   .dbfile D:\ICC_H\LCD12864_ST7920.H
 03DA                   .dbfunc e SPI_init _SPI_init fV
                        .even
 03DA           _SPI_init::
 03DA                   .dbline -1
 03DA                   .dbline 83
 03DA           ; /*********************************************************************
 03DA           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 03DA           ;                                                               
 03DA           ; 目    的:   建立LCD12864_ST7920的串模式操作库
 03DA           ; 
 03DA           ; 目标系统:   基于AVR单片机
 03DA           ;                                                                       
 03DA           ; 应用软件:   ICCAVR                                               
 03DA           ;                                                                       
 03DA           ; 版    本:   Version 1.0
 03DA           ;                                                                       
 03DA           ; 圆版时间:   2005-09-06
 03DA           ; 
 03DA           ; 开发人员:   SEE
 03DA           ; 
 03DA           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 03DA           ; 
 03DA           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权 
 03DA           ; *********************************************************************/
 03DA           ; 
 03DA           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 03DA           ; ----------------------------------------------------------------------
 03DA           ; 版本更新记录：
 03DA           ; 
 03DA           ; 
 03DA           ; 
 03DA           ; ----------------------------------------------------------------------
 03DA           ; 入口参数说明：
 03DA           ;       //#define OUT_LCD_CS    sbi(DDRD,0)
 03DA           ;       //#define SET_LCD_CS    sbi(PORTD,0)
 03DA           ;       //#define CLR_LCD_CS    cbi(PORTD,0)
 03DA           ; 
 03DA           ; ----------------------------------------------------------------------
 03DA           ; 待定参数说明：
 03DA           ;       
 03DA           ; 
 03DA           ; ----------------------------------------------------------------------        
 03DA           ; 对外变量说明：
 03DA           ; 
 03DA           ; ----------------------------------------------------------------------
 03DA           ; 对外函数说明：
 03DA           ; 
 03DA           ; ----------------------------------------------------------------------
 03DA           ; 10101010101010101010101010101010101010101010101010101010101010101010*/
 03DA           ; 
 03DA           ; 
 03DA           ; /*--------------------------------------------------------------------
 03DA           ; 接口定义：
 03DA           ; 
 03DA           ; LCD12864_ST7920                       ATmega16
 03DA           ; 1.GND         --------        GND
 03DA           ; 2.VCC         --------        VCC
 03DA           ; 3.V0          --------        V0
 03DA           ; 4.RS(CS)      --------        VCC
 03DA           ; 5.R/W(SID)    --------        MOSI/PB5
 03DA           ; 6.E(SCLK)     --------        SCK/PB7
 03DA           ; 7.D0          --------        NC
 03DA           ; 8.D1          --------        NC
 03DA           ; 9.D2          --------        NC
 03DA           ; 10.D3         --------        NC
 03DA           ; 11.D4         --------        NC
 03DA           ; 12.D5         --------        NC
 03DA           ; 13.D6         --------        NC
 03DA           ; 14.D7         --------        NC
 03DA           ; 15.PSB                --------        GND
 03DA           ; 16.NC         --------        NC
 03DA           ; 17.RST                --------        NC
 03DA           ; 18.NC         --------        NC
 03DA           ; 19.LED+               --------        VCC
 03DA           ; 20.LED-               --------        GND
 03DA           ; 
 03DA           ; 说明：
 03DA           ; （1）使用ATmega16的硬件SPI操作LCD12864_ST7920
 03DA           ; （2）PIN4/CS接VCC，其实也可接到特定的IO口，但外部程序需要指定
 03DA           ; --------------------------------------------------------------------*/
 03DA           ; 
 03DA           ; #ifndef LCD12864_ST7920_H
 03DA           ; #define LCD12864_ST7920_H
 03DA           ; 
 03DA           ; #include "D:\ICC_H\CmmIcc.h"
 03DA           ; 
 03DA           ; void SPI_init()
 03DA           ; {
 03DA                   .dbline 84
 03DA           ;       DDRB |= 0xB0;
 03DA 87B3              in R24,0x17
 03DC 806B              ori R24,176
 03DE 87BB              out 0x17,R24
 03E0                   .dbline 85
 03E0           ;       SPCR = 0x50;    //setup SPI
 03E0 80E5              ldi R24,80
 03E2 8DB9              out 0xd,R24
 03E4                   .dbline 86
 03E4           ;       SPSR = 0x01;    //setup SPI
 03E4 81E0              ldi R24,1
 03E6 8EB9              out 0xe,R24
 03E8                   .dbline 87
 03E8           ;       SEI();
 03E8 7894              sei
 03EA                   .dbline -2
 03EA           L133:
 03EA                   .dbline 0 ; func end
 03EA 0895              ret
 03EC                   .dbend
 03EC                   .dbfunc e lcd_wrByte _lcd_wrByte fV
 03EC           ;           data -> R16
                        .even
 03EC           _lcd_wrByte::
 03EC                   .dbline -1
 03EC                   .dbline 91
 03EC           ; }
 03EC           ; 
 03EC           ; void lcd_wrByte(uint8 data)
 03EC           ; {  
 03EC                   .dbline 92
 03EC           ;       SPDR = data;        
 03EC 0FB9              out 0xf,R16
 03EE           L135:
 03EE                   .dbline 93
 03EE           ;       while ((SPSR & 0x80) == 0);  
 03EE           L136:
 03EE                   .dbline 93
 03EE 779B              sbis 0xe,7
 03F0 FECF              rjmp L135
 03F2           X46:
 03F2                   .dbline -2
 03F2           L134:
 03F2                   .dbline 0 ; func end
 03F2 0895              ret
 03F4                   .dbsym r data 16 c
 03F4                   .dbend
 03F4                   .dbfunc e lcd_wrCmd _lcd_wrCmd fV
 03F4           ;             LC -> R10
 03F4           ;             HC -> R12
                        .even
 03F4           _lcd_wrCmd::
 03F4 AA92              st -y,R10
 03F6 CA92              st -y,R12
 03F8 A22E              mov R10,R18
 03FA C02E              mov R12,R16
 03FC                   .dbline -1
 03FC                   .dbline 97
 03FC           ; }
 03FC           ; 
 03FC           ; void lcd_wrCmd(uint8 HC,uint8 LC)
 03FC           ; {
 03FC                   .dbline 98
 03FC           ;       lcd_wrByte(0xF8);
 03FC 08EF              ldi R16,248
 03FE F6DF              rcall _lcd_wrByte
 0400                   .dbline 99
 0400           ;       lcd_wrByte(HC);         //传输高四位
 0400 0C2D              mov R16,R12
 0402 F4DF              rcall _lcd_wrByte
 0404                   .dbline 100
 0404           ;       lcd_wrByte(LC);         //传输低四位
 0404 0A2D              mov R16,R10
 0406 F2DF              rcall _lcd_wrByte
 0408                   .dbline -2
 0408           L138:
 0408                   .dbline 0 ; func end
 0408 C990              ld R12,y+
 040A A990              ld R10,y+
 040C 0895              ret
 040E                   .dbsym r LC 10 c
 040E                   .dbsym r HC 12 c
 040E                   .dbend
 040E                   .dbfunc e lcd_wrDat _lcd_wrDat fV
 040E           ;             LD -> R10
 040E           ;             HD -> R12
                        .even
 040E           _lcd_wrDat::
 040E AA92              st -y,R10
 0410 CA92              st -y,R12
 0412 A22E              mov R10,R18
 0414 C02E              mov R12,R16
 0416                   .dbline -1
 0416                   .dbline 104
 0416           ; }
 0416           ; 
 0416           ; void lcd_wrDat(uint8 HD,uint8 LD)
 0416           ; {
 0416                   .dbline 105
 0416           ;       lcd_wrByte(0xFA);
 0416 0AEF              ldi R16,250
 0418 E9DF              rcall _lcd_wrByte
 041A                   .dbline 106
 041A           ;       lcd_wrByte(HD);         //传输高四位
 041A 0C2D              mov R16,R12
 041C E7DF              rcall _lcd_wrByte
 041E                   .dbline 107
 041E           ;       lcd_wrByte(LD);         //传输低四位
 041E 0A2D              mov R16,R10
 0420 E5DF              rcall _lcd_wrByte
 0422                   .dbline -2
 0422           L139:
 0422                   .dbline 0 ; func end
 0422 C990              ld R12,y+
 0424 A990              ld R10,y+
 0426 0895              ret
 0428                   .dbsym r LD 10 c
 0428                   .dbsym r HD 12 c
 0428                   .dbend
 0428                   .dbfunc e lcd_set_xy _lcd_set_xy fV
 0428           ;            adr -> R20
 0428           ;              y -> R22
 0428           ;              x -> R10
                        .even
 0428           _lcd_set_xy::
 0428 00D0              rcall push_xgsetF00C
 042A 622F              mov R22,R18
 042C A02E              mov R10,R16
 042E                   .dbline -1
 042E                   .dbline 114
 042E           ; } 
 042E           ; 
 042E           ; /*
 042E           ; x表示在第几行显示，y表示在第几列显示
 042E           ; */
 042E           ; void lcd_set_xy(uint8 x,uint8 y) 
 042E           ; {
 042E                   .dbline 117
 042E           ;       uint8 adr;
 042E           ; 
 042E           ;       switch(x)
 042E BB24              clr R11
 0430 C501              movw R24,R10
 0432 8130              cpi R24,1
 0434 E0E0              ldi R30,0
 0436 9E07              cpc R25,R30
 0438 69F0              breq L144
 043A           X47:
 043A 8230              cpi R24,2
 043C E0E0              ldi R30,0
 043E 9E07              cpc R25,R30
 0440 61F0              breq L145
 0442           X48:
 0442 8330              cpi R24,3
 0444 E0E0              ldi R30,0
 0446 9E07              cpc R25,R30
 0448 59F0              breq L146
 044A           X49:
 044A 8430              cpi R24,4
 044C E0E0              ldi R30,0
 044E 9E07              cpc R25,R30
 0450 51F0              breq L147
 0452           X50:
 0452 0BC0              rjmp L141
 0454           L144:
 0454                   .dbline 119
 0454           ;       {
 0454           ;       case 1: adr = 0x7F + y;
 0454 462F              mov R20,R22
 0456 4158              subi R20,129    ; addi 127
 0458                   .dbline 120
 0458           ;               break;          //在第1行y列显示
 0458 08C0              rjmp L142
 045A           L145:
 045A                   .dbline 121
 045A           ;       case 2: adr = 0x8F + y;
 045A 462F              mov R20,R22
 045C 4157              subi R20,113    ; addi 143
 045E                   .dbline 122
 045E           ;               break;          //在第2行y列显示
 045E 05C0              rjmp L142
 0460           L146:
 0460                   .dbline 123
 0460           ;       case 3: adr = 0x87 + y;
 0460 462F              mov R20,R22
 0462 4957              subi R20,121    ; addi 135
 0464                   .dbline 124
 0464           ;               break;          //在第3行y列显示
 0464 02C0              rjmp L142
 0466           L147:
 0466                   .dbline 125
 0466           ;       case 4: adr = 0x97 + y;
 0466 462F              mov R20,R22
 0468 4956              subi R20,105    ; addi 151
 046A                   .dbline 126
 046A           ;               break;          //在第4行y列显示
 046A           L141:
 046A                   .dbline 127
 046A           ;       default:        ;
 046A                   .dbline 128
 046A           ;       }
 046A           L142:
 046A                   .dbline 129
 046A           ;       lcd_wrCmd(adr&0xF0,(adr&0x0F)<<4);
 046A 242F              mov R18,R20
 046C 2F70              andi R18,15
 046E 2F70              andi R18,#0x0F
 0470 2295              swap R18
 0472 042F              mov R16,R20
 0474 007F              andi R16,240
 0476 BEDF              rcall _lcd_wrCmd
 0478                   .dbline -2
 0478           L140:
 0478                   .dbline 0 ; func end
 0478 00C0              rjmp pop_xgsetF00C
 047A                   .dbsym r adr 20 c
 047A                   .dbsym r y 22 c
 047A                   .dbsym r x 10 c
 047A                   .dbend
 047A                   .dbfunc e lcd_putc _lcd_putc fV
 047A           ;             ch -> R20
 047A           ;              y -> R12
 047A           ;              x -> R10
                        .even
 047A           _lcd_putc::
 047A 00D0              rcall push_xgset303C
 047C C22E              mov R12,R18
 047E A02E              mov R10,R16
 0480 4E81              ldd R20,y+6
 0482                   .dbline -1
 0482                   .dbline 133
 0482           ; }
 0482           ; 
 0482           ; void lcd_putc(uint8 x,uint8 y,uint8 ch)
 0482           ; {
 0482                   .dbline 134
 0482           ;       lcd_set_xy(x,y);
 0482 2C2D              mov R18,R12
 0484 0A2D              mov R16,R10
 0486 D0DF              rcall _lcd_set_xy
 0488                   .dbline 135
 0488           ;       delay50us(20); 
 0488 04E1              ldi R16,20
 048A 10E0              ldi R17,0
 048C 3EDF              rcall _delay50us
 048E                   .dbline 136
 048E           ;       lcd_wrDat(ch&0xF0,(ch&0x0F)<<4);
 048E 242F              mov R18,R20
 0490 2F70              andi R18,15
 0492 2F70              andi R18,#0x0F
 0494 2295              swap R18
 0496 042F              mov R16,R20
 0498 007F              andi R16,240
 049A B9DF              rcall _lcd_wrDat
 049C                   .dbline -2
 049C           L148:
 049C                   .dbline 0 ; func end
 049C 00C0              rjmp pop_xgset303C
 049E                   .dbsym r ch 20 c
 049E                   .dbsym r y 12 c
 049E                   .dbsym r x 10 c
 049E                   .dbend
 049E                   .dbfunc e lcd_putd0 _lcd_putd0 fV
 049E           ;              i -> R20
 049E           ;         length -> R20
 049E           ;            dat -> y+7
 049E           ;              y -> R12
 049E           ;              x -> R10
                        .even
 049E           _lcd_putd0::
 049E 00D0              rcall push_xgset303C
 04A0 C22E              mov R12,R18
 04A2 A02E              mov R10,R16
 04A4 2197              sbiw R28,1
 04A6 4B85              ldd R20,y+11
 04A8                   .dbline -1
 04A8                   .dbline 140
 04A8           ; }
 04A8           ; 
 04A8           ; void lcd_putd0(uint8 x,uint8 y,uint32 dat,uint8 length)
 04A8           ; {
 04A8                   .dbline 143
 04A8           ;       sint8 i;
 04A8           ; 
 04A8           ;       speaData(dat,length);
 04A8 4883              std y+0,R20
 04AA 0F81              ldd R16,y+7
 04AC 1885              ldd R17,y+8
 04AE 2985              ldd R18,y+9
 04B0 3A85              ldd R19,y+10
 04B2 A6DD              rcall _speaData
 04B4                   .dbline 144
 04B4           ;       lcd_set_xy(x,y);
 04B4 2C2D              mov R18,R12
 04B6 0A2D              mov R16,R10
 04B8 B7DF              rcall _lcd_set_xy
 04BA                   .dbline 145
 04BA           ;       delay50us(40);
 04BA 08E2              ldi R16,40
 04BC 10E0              ldi R17,0
 04BE 25DF              rcall _delay50us
 04C0                   .dbline 146
 04C0           ;       for(i=length-1;i>=0;i--)
 04C0 4150              subi R20,1
 04C2 1EC0              rjmp L153
 04C4           L150:
 04C4                   .dbline 147
 04C4           ;       {
 04C4                   .dbline 148
 04C4           ;               lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
 04C4 80E0              ldi R24,<_dataElem
 04C6 90E0              ldi R25,>_dataElem
 04C8 E42F              mov R30,R20
 04CA FF27              clr R31
 04CC E7FD              sbrc R30,7
 04CE F095              com R31
 04D0 E80F              add R30,R24
 04D2 F91F              adc R31,R25
 04D4 8081              ldd R24,z+0
 04D6 9927              clr R25
 04D8 C096              adiw R24,48
 04DA 9C01              movw R18,R24
 04DC 2F70              andi R18,15
 04DE 3070              andi R19,0
 04E0 220F              lsl R18
 04E2 331F              rol R19
 04E4 220F              lsl R18
 04E6 331F              rol R19
 04E8 220F              lsl R18
 04EA 331F              rol R19
 04EC 220F              lsl R18
 04EE 331F              rol R19
 04F0 8C01              movw R16,R24
 04F2 007F              andi R16,240
 04F4 1070              andi R17,0
 04F6 8BDF              rcall _lcd_wrDat
 04F8                   .dbline 149
 04F8           ;               delay50us(40); 
 04F8 08E2              ldi R16,40
 04FA 10E0              ldi R17,0
 04FC 06DF              rcall _delay50us
 04FE                   .dbline 150
 04FE           ;       }
 04FE           L151:
 04FE                   .dbline 146
 04FE 4A95              dec R20
 0500           L153:
 0500                   .dbline 146
 0500 4030              cpi R20,0
 0502 04F7              brge L150
 0504           X51:
 0504                   .dbline -2
 0504           L149:
 0504                   .dbline 0 ; func end
 0504 2196              adiw R28,1
 0506 00C0              rjmp pop_xgset303C
 0508                   .dbsym r i 20 C
 0508                   .dbsym r length 20 c
 0508                   .dbsym l dat 7 l
 0508                   .dbsym r y 12 c
 0508                   .dbsym r x 10 c
 0508                   .dbend
 0508                   .dbfunc e lcd_putd _lcd_putd fV
 0508           ;      effectLen -> R22
 0508           ;              i -> R20
 0508           ;         length -> R10
 0508           ;            dat -> y+11
 0508           ;              y -> R14
 0508           ;              x -> R12
                        .even
 0508           _lcd_putd::
 0508 00D0              rcall push_xgsetF0FC
 050A E22E              mov R14,R18
 050C C02E              mov R12,R16
 050E 2197              sbiw R28,1
 0510 AF84              ldd R10,y+15
 0512                   .dbline -1
 0512                   .dbline 154
 0512           ; }
 0512           ; 
 0512           ; void lcd_putd(uint8 x,uint8 y,uint32 dat,uint8 length)
 0512           ; {
 0512                   .dbline 158
 0512           ;       sint8 i;
 0512           ;       sint8 effectLen;
 0512           ; 
 0512           ;       if(dat>999999)
 0512 8FE3              ldi R24,63
 0514 92E4              ldi R25,66
 0516 AFE0              ldi R26,15
 0518 B0E0              ldi R27,0
 051A 2B84              ldd R2,y+11
 051C 3C84              ldd R3,y+12
 051E 4D84              ldd R4,y+13
 0520 5E84              ldd R5,y+14
 0522 8215              cp R24,R2
 0524 9305              cpc R25,R3
 0526 A405              cpc R26,R4
 0528 B505              cpc R27,R5
 052A 10F4              brsh L155
 052C           X52:
 052C                   .dbline 159
 052C           ;               effectLen=7;
 052C 67E0              ldi R22,7
 052E 4CC0              rjmp L156
 0530           L155:
 0530                   .dbline 160
 0530           ;       else if(dat>99999)
 0530 8FE9              ldi R24,159
 0532 96E8              ldi R25,134
 0534 A1E0              ldi R26,1
 0536 B0E0              ldi R27,0
 0538 2B84              ldd R2,y+11
 053A 3C84              ldd R3,y+12
 053C 4D84              ldd R4,y+13
 053E 5E84              ldd R5,y+14
 0540 8215              cp R24,R2
 0542 9305              cpc R25,R3
 0544 A405              cpc R26,R4
 0546 B505              cpc R27,R5
 0548 10F4              brsh L157
 054A           X53:
 054A                   .dbline 161
 054A           ;               effectLen=6;
 054A 66E0              ldi R22,6
 054C 3DC0              rjmp L158
 054E           L157:
 054E                   .dbline 162
 054E           ;       else if(dat>9999)
 054E 8FE0              ldi R24,15
 0550 97E2              ldi R25,39
 0552 A0E0              ldi R26,0
 0554 B0E0              ldi R27,0
 0556 2B84              ldd R2,y+11
 0558 3C84              ldd R3,y+12
 055A 4D84              ldd R4,y+13
 055C 5E84              ldd R5,y+14
 055E 8215              cp R24,R2
 0560 9305              cpc R25,R3
 0562 A405              cpc R26,R4
 0564 B505              cpc R27,R5
 0566 10F4              brsh L159
 0568           X54:
 0568                   .dbline 163
 0568           ;               effectLen=5;
 0568 65E0              ldi R22,5
 056A 2EC0              rjmp L160
 056C           L159:
 056C                   .dbline 164
 056C           ;       else if(dat>999)
 056C 87EE              ldi R24,231
 056E 93E0              ldi R25,3
 0570 A0E0              ldi R26,0
 0572 B0E0              ldi R27,0
 0574 2B84              ldd R2,y+11
 0576 3C84              ldd R3,y+12
 0578 4D84              ldd R4,y+13
 057A 5E84              ldd R5,y+14
 057C 8215              cp R24,R2
 057E 9305              cpc R25,R3
 0580 A405              cpc R26,R4
 0582 B505              cpc R27,R5
 0584 10F4              brsh L161
 0586           X55:
 0586                   .dbline 165
 0586           ;               effectLen=4;
 0586 64E0              ldi R22,4
 0588 1FC0              rjmp L162
 058A           L161:
 058A                   .dbline 166
 058A           ;       else if(dat>99)
 058A 83E6              ldi R24,99
 058C 90E0              ldi R25,0
 058E A0E0              ldi R26,0
 0590 B0E0              ldi R27,0
 0592 2B84              ldd R2,y+11
 0594 3C84              ldd R3,y+12
 0596 4D84              ldd R4,y+13
 0598 5E84              ldd R5,y+14
 059A 8215              cp R24,R2
 059C 9305              cpc R25,R3
 059E A405              cpc R26,R4
 05A0 B505              cpc R27,R5
 05A2 10F4              brsh L163
 05A4           X56:
 05A4                   .dbline 167
 05A4           ;               effectLen=3;
 05A4 63E0              ldi R22,3
 05A6 10C0              rjmp L164
 05A8           L163:
 05A8                   .dbline 168
 05A8           ;       else if(dat>9)
 05A8 89E0              ldi R24,9
 05AA 90E0              ldi R25,0
 05AC A0E0              ldi R26,0
 05AE B0E0              ldi R27,0
 05B0 2B84              ldd R2,y+11
 05B2 3C84              ldd R3,y+12
 05B4 4D84              ldd R4,y+13
 05B6 5E84              ldd R5,y+14
 05B8 8215              cp R24,R2
 05BA 9305              cpc R25,R3
 05BC A405              cpc R26,R4
 05BE B505              cpc R27,R5
 05C0 10F4              brsh L165
 05C2           X57:
 05C2                   .dbline 169
 05C2           ;               effectLen=2;
 05C2 62E0              ldi R22,2
 05C4 01C0              rjmp L166
 05C6           L165:
 05C6                   .dbline 171
 05C6           ;       else
 05C6           ;               effectLen=1;
 05C6 61E0              ldi R22,1
 05C8           L166:
 05C8           L164:
 05C8           L162:
 05C8           L160:
 05C8           L158:
 05C8           L156:
 05C8                   .dbline 172
 05C8           ;       speaData(dat,effectLen);
 05C8 6883              std y+0,R22
 05CA 0B85              ldd R16,y+11
 05CC 1C85              ldd R17,y+12
 05CE 2D85              ldd R18,y+13
 05D0 3E85              ldd R19,y+14
 05D2 16DD              rcall _speaData
 05D4                   .dbline 174
 05D4           ; 
 05D4           ;       lcd_set_xy(x,y);
 05D4 2E2D              mov R18,R14
 05D6 0C2D              mov R16,R12
 05D8 27DF              rcall _lcd_set_xy
 05DA                   .dbline 175
 05DA           ;       delay50us(40); 
 05DA 08E2              ldi R16,40
 05DC 10E0              ldi R17,0
 05DE 95DE              rcall _delay50us
 05E0                   .dbline 176
 05E0           ;       if(length>effectLen)
 05E0 262E              mov R2,R22
 05E2 3324              clr R3
 05E4 27FC              sbrc R2,7
 05E6 3094              com R3
 05E8 4A2C              mov R4,R10
 05EA 5524              clr R5
 05EC 2414              cp R2,R4
 05EE 3504              cpc R3,R5
 05F0 6CF4              brge L167
 05F2           X58:
 05F2                   .dbline 177
 05F2           ;       {
 05F2                   .dbline 178
 05F2           ;               for(i=length-effectLen-1;i>=0;i--)
 05F2 442D              mov R20,R4
 05F4 461B              sub R20,R22
 05F6 4150              subi R20,1
 05F8 07C0              rjmp L172
 05FA           L169:
 05FA                   .dbline 179
 05FA           ;               {
 05FA                   .dbline 180
 05FA           ;                       lcd_wrDat(' '&0xF0,(' '&0x0F)<<4);
 05FA 2227              clr R18
 05FC 00E2              ldi R16,32
 05FE 07DF              rcall _lcd_wrDat
 0600                   .dbline 181
 0600           ;                       delay50us(40); 
 0600 08E2              ldi R16,40
 0602 10E0              ldi R17,0
 0604 82DE              rcall _delay50us
 0606                   .dbline 182
 0606           ;               }
 0606           L170:
 0606                   .dbline 178
 0606 4A95              dec R20
 0608           L172:
 0608                   .dbline 178
 0608 4030              cpi R20,0
 060A BCF7              brge L169
 060C           X59:
 060C                   .dbline 183
 060C           ;       }
 060C           L167:
 060C                   .dbline 184
 060C           ;       for(i=effectLen-1;i>=0;i--)
 060C 462F              mov R20,R22
 060E 4150              subi R20,1
 0610 1EC0              rjmp L176
 0612           L173:
 0612                   .dbline 185
 0612           ;       {
 0612                   .dbline 186
 0612           ;               lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
 0612 80E0              ldi R24,<_dataElem
 0614 90E0              ldi R25,>_dataElem
 0616 E42F              mov R30,R20
 0618 FF27              clr R31
 061A E7FD              sbrc R30,7
 061C F095              com R31
 061E E80F              add R30,R24
 0620 F91F              adc R31,R25
 0622 8081              ldd R24,z+0
 0624 9927              clr R25
 0626 C096              adiw R24,48
 0628 9C01              movw R18,R24
 062A 2F70              andi R18,15
 062C 3070              andi R19,0
 062E 220F              lsl R18
 0630 331F              rol R19
 0632 220F              lsl R18
 0634 331F              rol R19
 0636 220F              lsl R18
 0638 331F              rol R19
 063A 220F              lsl R18
 063C 331F              rol R19
 063E 8C01              movw R16,R24
 0640 007F              andi R16,240
 0642 1070              andi R17,0
 0644 E4DE              rcall _lcd_wrDat
 0646                   .dbline 187
 0646           ;               delay50us(40);
 0646 08E2              ldi R16,40
 0648 10E0              ldi R17,0
 064A 5FDE              rcall _delay50us
 064C                   .dbline 188
 064C           ;       }
 064C           L174:
 064C                   .dbline 184
 064C 4A95              dec R20
 064E           L176:
 064E                   .dbline 184
 064E 4030              cpi R20,0
 0650 04F7              brge L173
 0652           X60:
 0652                   .dbline -2
 0652           L154:
 0652                   .dbline 0 ; func end
 0652 2196              adiw R28,1
 0654 00C0              rjmp pop_xgsetF0FC
 0656                   .dbsym r effectLen 22 C
 0656                   .dbsym r i 20 C
 0656                   .dbsym r length 10 c
 0656                   .dbsym l dat 11 l
 0656                   .dbsym r y 14 c
 0656                   .dbsym r x 12 c
 0656                   .dbend
 0656                   .dbfunc e lcd_puts _lcd_puts fV
 0656           ;            str -> R20,R21
 0656           ;              y -> R12
 0656           ;              x -> R10
                        .even
 0656           _lcd_puts::
 0656 00D0              rcall push_xgset303C
 0658 C22E              mov R12,R18
 065A A02E              mov R10,R16
 065C 4E81              ldd R20,y+6
 065E 5F81              ldd R21,y+7
 0660                   .dbline -1
 0660                   .dbline 192
 0660           ; }
 0660           ; 
 0660           ; void lcd_puts(uint8 x,uint8 y,uint8 *str)
 0660           ; { 
 0660                   .dbline 193
 0660           ;       lcd_set_xy(x,y);
 0660 2C2D              mov R18,R12
 0662 0A2D              mov R16,R10
 0664 E1DE              rcall _lcd_set_xy
 0666                   .dbline 194
 0666           ;       delay50us(20);   
 0666 04E1              ldi R16,20
 0668 10E0              ldi R17,0
 066A 4FDE              rcall _delay50us
 066C 0FC0              rjmp L179
 066E           L178:
 066E                   .dbline 196
 066E           ;       while(*str)
 066E           ;       {
 066E                   .dbline 197
 066E           ;               lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
 066E FA01              movw R30,R20
 0670 2080              ldd R2,z+0
 0672 3324              clr R3
 0674 222D              mov R18,R2
 0676 2F70              andi R18,15
 0678 2F70              andi R18,#0x0F
 067A 2295              swap R18
 067C 022D              mov R16,R2
 067E 007F              andi R16,240
 0680 C6DE              rcall _lcd_wrDat
 0682                   .dbline 198
 0682           ;               str++;
 0682 4F5F              subi R20,255  ; offset = 1
 0684 5F4F              sbci R21,255
 0686                   .dbline 199
 0686           ;               delay50us(20);
 0686 04E1              ldi R16,20
 0688 10E0              ldi R17,0
 068A 3FDE              rcall _delay50us
 068C                   .dbline 200
 068C           ;       } 
 068C           L179:
 068C                   .dbline 195
 068C FA01              movw R30,R20
 068E 2080              ldd R2,z+0
 0690 2220              tst R2
 0692 69F7              brne L178
 0694           X61:
 0694                   .dbline -2
 0694           L177:
 0694                   .dbline 0 ; func end
 0694 00C0              rjmp pop_xgset303C
 0696                   .dbsym r str 20 pc
 0696                   .dbsym r y 12 c
 0696                   .dbsym r x 10 c
 0696                   .dbend
 0696                   .dbfunc e lcd_puts_ _lcd_puts_ fV
 0696           ;          dlyMs -> R10
 0696           ;            str -> R20,R21
 0696           ;              y -> R14
 0696           ;              x -> R12
                        .even
 0696           _lcd_puts_::
 0696 00D0              rcall push_xgset30FC
 0698 E22E              mov R14,R18
 069A C02E              mov R12,R16
 069C 4885              ldd R20,y+8
 069E 5985              ldd R21,y+9
 06A0 AA84              ldd R10,y+10
 06A2                   .dbline -1
 06A2                   .dbline 204
 06A2           ; }
 06A2           ; 
 06A2           ; void lcd_puts_(uint8 x,uint8 y,uint8 *str,uint8 dlyMs)
 06A2           ; { 
 06A2                   .dbline 205
 06A2           ;       lcd_set_xy(x,y);
 06A2 2E2D              mov R18,R14
 06A4 0C2D              mov R16,R12
 06A6 C0DE              rcall _lcd_set_xy
 06A8                   .dbline 206
 06A8           ;       delay50us(20);   
 06A8 04E1              ldi R16,20
 06AA 10E0              ldi R17,0
 06AC 2EDE              rcall _delay50us
 06AE 0FC0              rjmp L183
 06B0           L182:
 06B0                   .dbline 208
 06B0           ;       while(*str)
 06B0           ;       {
 06B0                   .dbline 209
 06B0           ;               lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
 06B0 FA01              movw R30,R20
 06B2 2080              ldd R2,z+0
 06B4 3324              clr R3
 06B6 222D              mov R18,R2
 06B8 2F70              andi R18,15
 06BA 2F70              andi R18,#0x0F
 06BC 2295              swap R18
 06BE 022D              mov R16,R2
 06C0 007F              andi R16,240
 06C2 A5DE              rcall _lcd_wrDat
 06C4                   .dbline 210
 06C4           ;               str++;
 06C4 4F5F              subi R20,255  ; offset = 1
 06C6 5F4F              sbci R21,255
 06C8                   .dbline 211
 06C8           ;               delay50ms(dlyMs);
 06C8 0A2D              mov R16,R10
 06CA 1127              clr R17
 06CC 2EDE              rcall _delay50ms
 06CE                   .dbline 212
 06CE           ;       } 
 06CE           L183:
 06CE                   .dbline 207
 06CE FA01              movw R30,R20
 06D0 2080              ldd R2,z+0
 06D2 2220              tst R2
 06D4 69F7              brne L182
 06D6           X62:
 06D6                   .dbline -2
 06D6           L181:
 06D6                   .dbline 0 ; func end
 06D6 00C0              rjmp pop_xgset30FC
 06D8                   .dbsym r dlyMs 10 c
 06D8                   .dbsym r str 20 pc
 06D8                   .dbsym r y 14 c
 06D8                   .dbsym r x 12 c
 06D8                   .dbend
 06D8                   .dbfunc e lcd_clr _lcd_clr fV
                        .even
 06D8           _lcd_clr::
 06D8                   .dbline -1
 06D8                   .dbline 216
 06D8           ; }
 06D8           ; 
 06D8           ; void lcd_clr()
 06D8           ; {
 06D8                   .dbline 217
 06D8           ;       lcd_wrCmd(0x00,0x10);
 06D8 20E1              ldi R18,16
 06DA 0027              clr R16
 06DC 8BDE              rcall _lcd_wrCmd
 06DE                   .dbline 218
 06DE           ;       delay50us(200);
 06DE 08EC              ldi R16,200
 06E0 10E0              ldi R17,0
 06E2                   .dbline -2
 06E2           L185:
 06E2                   .dbline 0 ; func end
 06E2 13CE              rjmp _delay50us
 06E4                   .dbend
 06E4                   .dbfunc e lcd_init _lcd_init fV
                        .even
 06E4           _lcd_init::
 06E4                   .dbline -1
 06E4                   .dbline 222
 06E4           ; }
 06E4           ; 
 06E4           ; void lcd_init(void)
 06E4           ; {
 06E4                   .dbline 223
 06E4           ;       SPI_init();     
 06E4 7ADE              rcall _SPI_init
 06E6                   .dbline 226
 06E6           ;       //OUT_LCD_CS;           //若LCD_CS
 06E6           ;       //SET_LCD_CS;           
 06E6           ;       delay50ms(1);
 06E6 01E0              ldi R16,1
 06E8 10E0              ldi R17,0
 06EA 1FDE              rcall _delay50ms
 06EC                   .dbline 227
 06EC           ;       lcd_wrCmd(0x30,0x30);   //使用8位控制界面,使用基本指令集
 06EC 20E3              ldi R18,48
 06EE 00E3              ldi R16,48
 06F0 81DE              rcall _lcd_wrCmd
 06F2                   .dbline 229
 06F2           ;       //lcd_wrCmd(0x00,0xF0); //整体显示ON
 06F2           ;       lcd_wrCmd(0x00,0xC0);   //整体显示ON
 06F2 20EC              ldi R18,192
 06F4 0027              clr R16
 06F6 7EDE              rcall _lcd_wrCmd
 06F8                   .dbline 230
 06F8           ;       lcd_wrCmd(0x00,0x10);   //清屏
 06F8 20E1              ldi R18,16
 06FA 0027              clr R16
 06FC 7BDE              rcall _lcd_wrCmd
 06FE                   .dbline 232
 06FE           ;       //lcd_wrCmd(0x10,0x00); //光标
 06FE           ;       lcd_wrCmd(0x00,0x60);
 06FE 20E6              ldi R18,96
 0700 0027              clr R16
 0702 78DE              rcall _lcd_wrCmd
 0704                   .dbline 234
 0704           ;       //lcd_wrCmd(0x00,0x70); //显示右移
 0704           ;       delay50ms(1);           //不可省去！！！
 0704 01E0              ldi R16,1
 0706 10E0              ldi R17,0
 0708                   .dbline -2
 0708           L186:
 0708                   .dbline 0 ; func end
 0708 10CE              rjmp _delay50ms
 070A                   .dbend
 070A                   .dbfile E:\吴泽备份\DVK501光盘内容\STK16_~1.0\AT45DB~1\AT45DB161_LCD12864\AT45DB161.C
 070A                   .dbfunc e main _main fV
 070A           ;            tmp -> y+5
 070A           ;              i -> R20,R21
                        .even
 070A           _main::
 070A EF97              sbiw R28,63
 070C EF97              sbiw R28,63
 070E EF97              sbiw R28,63
 0710 EF97              sbiw R28,63
 0712 2997              sbiw R28,9  ; offset = 261
 0714                   .dbline -1
 0714                   .dbline 63
 0714           ; /*********************************************************************
 0714           ;       微 雪 电 子   WaveShare   http://www.waveShare.net              
 0714           ;                                                                           
 0714           ; 项目名称:   AT45DB161示例程序
 0714           ;               
 0714           ; 目标系统:   “DVK501” && “M16+ EX”
 0714           ; 
 0714           ; 应用软件:   ICCAVR 6.31A                                             
 0714           ;                                                                               
 0714           ; 版    本:   V1.0 
 0714           ;                                                         
 0714           ; 圆版时间:   2009-7-1
 0714           ; 
 0714           ; 开发人员:   zz
 0714           ; 
 0714           ; 说    明:   若用于商业用途，请保留此段文字或注明代码来源
 0714           ;               
 0714           ;       深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
 0714           ; *********************************************************************/
 0714           ; 
 0714           ; /*01010101010101010101010101010101010101010101010101010101010101010101
 0714           ; ----------------------------------------------------------------------
 0714           ; 版本更新记录：
 0714           ; 
 0714           ; ----------------------------------------------------------------------
 0714           ; 实验内容：
 0714           ; 通过MCU的硬件SPI接口，将数据存入AT45DB161中，然后再从中读取数据并通过LCD12864显示
 0714           ; ----------------------------------------------------------------------
 0714           ; 硬件连接：      DVK501                                 ATmega16
 0714           ;                               RST             ---------         VCC
 0714           ;                               WP              ---------         VCC
 0714           ;                               CS              ---------         PB4
 0714           ;                               SI              ---------         PB5   
 0714           ;                               SO              ---------         PB6
 0714           ;                               SCK             ---------         PB7
 0714           ;             
 0714           ;             LCD:
 0714           ;             SID     ---------     PB5
 0714           ;             SCK     ---------     PB7
 0714           ;             CS      ---------     PB3
 0714           ; ----------------------------------------------------------------------
 0714           ; 注意事项：
 0714           ; （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘
 0714           ; （2）请详细阅读“使用必读”及相关资料。
 0714           ; ----------------------------------------------------------------------
 0714           ; 10101010101010101010101010101010101010101010101010101
 0714           ; 010101010101010*/
 0714           ; #include <iom16v.h>
 0714           ; #include <macros.h>
 0714           ; #include "D:\ICC_H\CmmICC.H"
 0714           ; #include "D:\ICC_H\AT45DB161.H" 
 0714           ; #include "D:\ICC_H\LCD12864_ST7920.H"  
 0714           ; 
 0714           ; #define OUT_DBCS sbi(DDRB,4)
 0714           ; #define SET_DBCS sbi(PORTB,4)
 0714           ; #define CLR_DBCS cbi(PORTB,4)
 0714           ; 
 0714           ; #define OUT_LCDCS sbi(DDRB,3)
 0714           ; #define SET_LCDCS sbi(PORTB,3)
 0714           ; #define CLR_LCDCS cbi(PORTB,3)
 0714           ; 
 0714           ; void main(void)
 0714           ; {
 0714                   .dbline 66
 0714           ;       uint i;
 0714           ;       uchar tmp[256];
 0714           ;       DDRB=0xFF;      
 0714 8FEF              ldi R24,255
 0716 87BB              out 0x17,R24
 0718                   .dbline 67
 0718           ;       CLR_LCDCS;
 0718 C398              cbi 0x18,3
 071A                   .dbline 68
 071A           ;       spi_init();  
 071A 32DE              rcall _spi_init
 071C                   .dbline 69
 071C           ;     delay50ms(1); 
 071C 01E0              ldi R16,1
 071E 10E0              ldi R17,0
 0720 04DE              rcall _delay50ms
 0722                   .dbline 71
 0722           ;       
 0722           ;       SET_DBCS;
 0722 C49A              sbi 0x18,4
 0724                   .dbline 72
 0724           ;     for(i=0;i<256;i++)//把256个数据写入dataflash缓存器 
 0724 4427              clr R20
 0726 5527              clr R21
 0728 07C0              rjmp L191
 072A           L188:
 072A                   .dbline 73
 072A           ;     {  
 072A                   .dbline 74
 072A           ;               CLR_DBCS;
 072A C498              cbi 0x18,4
 072C                   .dbline 75
 072C           ;         write_buffer(i,i);        
 072C 242F              mov R18,R20
 072E 8A01              movw R16,R20
 0730 2EDE              rcall _write_buffer
 0732                   .dbline 76
 0732           ;               SET_DBCS;
 0732 C49A              sbi 0x18,4
 0734                   .dbline 77
 0734           ;     }   
 0734           L189:
 0734                   .dbline 72
 0734 4F5F              subi R20,255  ; offset = 1
 0736 5F4F              sbci R21,255
 0738           L191:
 0738                   .dbline 72
 0738 4030              cpi R20,0
 073A E1E0              ldi R30,1
 073C 5E07              cpc R21,R30
 073E A8F3              brlo L188
 0740           X63:
 0740                   .dbline 78
 0740           ;       for(i=0;i<256;i++)           //从dataflash缓存器把256个数据读出
 0740 4427              clr R20
 0742 5527              clr R21
 0744 0CC0              rjmp L195
 0746           L192:
 0746                   .dbline 79
 0746           ;       {
 0746                   .dbline 80
 0746           ;               CLR_DBCS;
 0746 C498              cbi 0x18,4
 0748                   .dbline 81
 0748           ;               tmp[i]=read_buffer(i);          //暂存数据
 0748 8A01              movw R16,R20
 074A 31DE              rcall _read_buffer
 074C CE01              movw R24,R28
 074E 0596              adiw R24,5
 0750 FA01              movw R30,R20
 0752 E80F              add R30,R24
 0754 F91F              adc R31,R25
 0756 0083              std z+0,R16
 0758                   .dbline 82
 0758           ;               SET_DBCS;  
 0758 C49A              sbi 0x18,4
 075A                   .dbline 83
 075A           ;       } 
 075A           L193:
 075A                   .dbline 78
 075A 4F5F              subi R20,255  ; offset = 1
 075C 5F4F              sbci R21,255
 075E           L195:
 075E                   .dbline 78
 075E 4030              cpi R20,0
 0760 E1E0              ldi R30,1
 0762 5E07              cpc R21,R30
 0764 80F3              brlo L192
 0766           X64:
 0766                   .dbline 84
 0766           ;       OUT_LCDCS;                            
 0766 BB9A              sbi 0x17,3
 0768                   .dbline 85
 0768           ;       SET_LCDCS;
 0768 C39A              sbi 0x18,3
 076A                   .dbline 86
 076A           ;       lcd_init();
 076A BCDF              rcall _lcd_init
 076C                   .dbline 87
 076C           ;       lcd_clr();
 076C B5DF              rcall _lcd_clr
 076E                   .dbline 88
 076E           ;       lcd_puts(1,1,"AT45DBX-LCD12864");
 076E 80E0              ldi R24,<L196
 0770 90E0              ldi R25,>L196
 0772 9983              std y+1,R25
 0774 8883              std y+0,R24
 0776 21E0              ldi R18,1
 0778 01E0              ldi R16,1
 077A 6DDF              rcall _lcd_puts
 077C                   .dbline 89
 077C           ;       lcd_puts(2,1,"FLASH   液晶显示");
 077C 80E0              ldi R24,<L197
 077E 90E0              ldi R25,>L197
 0780 9983              std y+1,R25
 0782 8883              std y+0,R24
 0784 21E0              ldi R18,1
 0786 02E0              ldi R16,2
 0788 66DF              rcall _lcd_puts
 078A                   .dbline 90
 078A           ;       lcd_puts(3,1,"内容:");
 078A 80E0              ldi R24,<L198
 078C 90E0              ldi R25,>L198
 078E 9983              std y+1,R25
 0790 8883              std y+0,R24
 0792 21E0              ldi R18,1
 0794 03E0              ldi R16,3
 0796 5FDF              rcall _lcd_puts
 0798                   .dbline 91
 0798           ;       for(i=0;i<256;i++)
 0798 4427              clr R20
 079A 5527              clr R21
 079C 17C0              rjmp L202
 079E           L199:
 079E                   .dbline 92
 079E           ;       {
 079E                   .dbline 93
 079E           ;               lcd_putd(3,5,tmp[i],2);
 079E 82E0              ldi R24,2
 07A0 8C83              std y+4,R24
 07A2 CE01              movw R24,R28
 07A4 0596              adiw R24,5
 07A6 FA01              movw R30,R20
 07A8 E80F              add R30,R24
 07AA F91F              adc R31,R25
 07AC 2080              ldd R2,z+0
 07AE 3324              clr R3
 07B0 4424              clr R4
 07B2 5524              clr R5
 07B4 2882              std y+0,R2
 07B6 3982              std y+1,R3
 07B8 4A82              std y+2,R4
 07BA 5B82              std y+3,R5
 07BC 25E0              ldi R18,5
 07BE 03E0              ldi R16,3
 07C0 A3DE              rcall _lcd_putd
 07C2                   .dbline 94
 07C2           ;               delay50ms(20);
 07C2 04E1              ldi R16,20
 07C4 10E0              ldi R17,0
 07C6 B1DD              rcall _delay50ms
 07C8                   .dbline 95
 07C8           ;       }
 07C8           L200:
 07C8                   .dbline 91
 07C8 4F5F              subi R20,255  ; offset = 1
 07CA 5F4F              sbci R21,255
 07CC           L202:
 07CC                   .dbline 91
 07CC 4030              cpi R20,0
 07CE E1E0              ldi R30,1
 07D0 5E07              cpc R21,R30
 07D2 28F3              brlo L199
 07D4           X65:
 07D4           L203:
 07D4                   .dbline 96
 07D4           ;       while(1);
 07D4           L204:
 07D4                   .dbline 96
 07D4 FFCF              rjmp L203
 07D6           X66:
 07D6                   .dbline -2
 07D6           L187:
 07D6                   .dbline 0 ; func end
 07D6 EF96              adiw R28,63
 07D8 EF96              adiw R28,63
 07DA EF96              adiw R28,63
 07DC EF96              adiw R28,63
 07DE 2996              adiw R28,9  ; offset = 261
 07E0 0895              ret
 07E2                   .dbsym l tmp 5 A[256:256]c
 07E2                   .dbsym r i 20 i
 07E2                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile E:\吴泽备份\DVK501光盘内容\STK16_~1.0\AT45DB~1\AT45DB161_LCD12864\AT45DB161.C
 0000           _dataElem::
 0000                   .blkb 6
 0006                   .dbfile D:\ICC_H\Software.H
 0006                   .dbsym e dataElem _dataElem A[6:6]c
                        .area data(ram, con, rel)
 0000                   .dbfile D:\ICC_H\Software.H
 0000           L198:
 0000                   .blkb 6
                        .area idata
 0000 C4DAC8DD3A00      .byte 196,218,200,221,58,0
                        .area data(ram, con, rel)
 0006                   .dbfile D:\ICC_H\Software.H
 0006           L197:
 0006                   .blkb 17
                        .area idata
 0006 464C415348202020D2BABEA7CFD4CABE  .byte 'F,'L,'A,'S,'H,32,32,32,210,186,190,167,207,212,202,190
 0016 00                .byte 0
                        .area data(ram, con, rel)
 0017                   .dbfile D:\ICC_H\Software.H
 0017           L196:
 0017                   .blkb 17
                        .area idata
 0017 415434354442582D4C43443132383634  .byte 'A,'T,52,53,'D,'B,'X,45,'L,'C,'D,49,50,56,54,52
 0027 00                .byte 0
                        .area data(ram, con, rel)
 0028                   .dbfile D:\ICC_H\Software.H
 0028           ; }
 0028           ; 
